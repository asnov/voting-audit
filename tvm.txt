Виртуальная машина ТОН (TVM.pdf) от Николая Дурова
Перейти к навигацииПерейти к поиску
Введение

Основная цель платформы Telegram Open Network Virtual Machine (виртуальная машина TON, или TVM) заключается в выполнении кода смарт-контракта в блокчейне TON. TVM должна поддерживать все операции, необходимые для парсинга входящих сообщений и перманентных данных, для создания новых сообщений и изменения перманентных данных.

Помимо прочего, TVM должна отвечать следующим требованиям:

TVM должна предусматривать возможные расширения и улучшения в будущем, сохраняя при этом полную совместимость с предыдущими версиями и интероперабельность в связи с тем, что после внедрения в блокчейн код смарт-контракта должен выполняться предсказуемо вне зависимости от будущих модификаций Виртуальной машины.
TVM должна стремиться обеспечить высокую плотность «(виртуального) машинного кода», чтобы код типичного смарт-контракта занимал как можно меньше постоянного хранилища блокчейна.
TVM должна быть полностью детерминированной. Иными словами, каждый запуск одного и того же кода с одинаковыми входными данными должен приводить к одному и тому же результату вне зависимости от особенностей программно-технического обеспечения. (сноска 1)
В процессе создания TVM учитываются все данные требования. Несмотря на то, что в настоящем документе описывается предварительная экспериментальная версия TVM (сноска 2), внедренные механизмы обратной совместимости позволяют нам не переживать по поводу эффективности кодировки операций в предварительной версии кода TVM.

TVM не предусматривает аппаратную реализацию (например, в специальном кристалле микропроцессора). Подразумевается программная реализация на стандартном аппаратном оборудовании. Благодаря этому, нам удалось внедрить в TVM некоторые понятия высокого уровня и операции, в рамках аппаратной реализации которых требовался бы сложный код, но программная реализация этих понятий и операций не представляет проблем. Подобные операции эффективны для обеспечения высокой плотности кода и минимизации байтового (или ячейки хранения) профиля кода смарт-контракта в TON-блокчейне.


Содержание
1	Обзор
1.1	1.0 Запись битовой строки
1.1.1	1.0.1 Шестнадцатеричная запись битовой строки
1.1.2	1.0.2 Битовые строки, не кратные четырем
1.1.3	1.0.3 Подчеркиваем, что строка является шестнадцатеричным представлением битовой строки.
1.1.4	1.0.4 Сериализация битовой строки в последовательность октетов
1.2	1.1 TVM – это стековая машина
1.2.1	1.1.1. Значения TVM.
1.2.2	1.1.2. Статическая типизация, динамическая типизация и типизация во время выполнения.
1.2.3	1.1.3 Предварительный список типов значений
1.3	1.2 Категории машинных команд TVM
1.4	1.3 Регистр управления
1.4.1	1.3.1. Значения в регистрах управления
1.4.2	1.3.2. Список регистров управления
1.5	1.4 Состояние TVM в целом (SCCCG)
1.6	1.5 Арифметика целых чисел
1.6.1	1.5.1. Отсутствие автоматического преобразования целых чисел.
1.6.2	1.5.2. Автоматические проверки переполнения
1.6.3	1.5.3. Пользовательские проверки переполнения
1.6.4	1.5.4. Приведение по модулю {\displaystyle 2^{n}}{\displaystyle 2^{n}}
1.6.5	1.5.5. Целое число является 257-битным, а не 256-битным.
1.6.6	1.5.6. Деление и округление.
1.6.7	1.5.7. Комбинированные операции умножение-деление, умножение-сдвиг и сдвиг-деление.
2	2 Стек
2.1	2.1 Соглашения о вызове стека
2.1.1	2.1.1. Представление «стековых регистров»
2.1.2	2.1.2. Проталкивание и извлечение значений
2.1.3	2.1.3. Представление гипотетических универсальных регистров
2.1.4	2.1.4. Регистр вершины стека s0 vs аккумулятор r0
2.1.5	2.1.5. Соглашения о вызове регистра
2.1.6	2.1.6. Порядок аргументов функции
2.1.7	2.1.7. Аргументы арифметических элементарных действий на регистровых машинах
2.1.8	2.1.8. Возвращаемые значения функций
2.1.9	2.1.9. Возврат нескольких значений
2.1.10	2.1.10. Представление стека
2.1.11	2.1.11. Явное определение количества аргументов функции
2.2	2.2 Элементарные действия стековой обработки
2.2.1	2.2.1.
2.2.2	2.2.2. Применение базовых элементарных действий стековой обработки
2.2.3	2.2.3. Составные элементарные действия стековой обработки
2.2.4	2.2.4. Символика составных элементарных действий стековой обработки
2.2.5	2.2.5. Семантика составных элементарных действий стековой обработки
2.2.6	2.2.6. Команды по стековой обработке полиморфны
2.3	2.3 Эффективность элементарных действий стековой обработки
2.3.1	2.3.1. Реализация элементарных действий стековой обработки:
2.3.2	2.3.2. Эффективная реализация команд DUP и PUSH с использованием COW (копирование при записи).
2.3.3	2.3.3. Сборка мусора и подсчет ссылок.
2.3.4	2.3.4. Прозрачность реализации: значения стека – это «значения», а не «ссылки».
2.3.5	2.3.5. Отсутствие циклических ссылок.
3	3 Ячейки, память и база данных
3.1	3.1 Общие сведения о ячейках
3.1.1	3.1.1. Память TVM и база данных состоят из ячеек.
3.1.2	3.1.2. Обыкновенные и особые ячейки.
3.1.3	3.1.3. Уровень ячейки
3.1.4	3.1.4. Стандартное представление ячейки
3.1.5	3.1.5. Репрезентативный хеш ячейки
3.1.6	3.1.6. Старшие хэши ячейки
3.1.7	3.1.7. Виды особых ячеек
3.1.8	3.1.8. Все значения алгебраических типов данных являются древами ячеек
3.1.9	3.1.9. Код TVM - это древо ячеек
3.1.10	3.1.10. Парадигма «Все – неупорядоченная совокупность ячеек»
3.2	3.2 Команды обработки данных и ячейки
3.2.1	3.2.1. Классы команд обработки данных
3.2.2	3.2.2. Значения Builder(компоновщик) и Slice(срез)
3.2.3	3.2.3. Значения Builder и Slice существуют только как значения стека
3.2.4	3.2.4. В TVM нет отдельного типа значения Bitstring
3.2.5	3.2.5. Ячейки и элементарные действия ячеек ориентированы на биты, а не на байты
3.2.6	3.2.6. Таксономия элементарных действий создания (сериализации) ячеек.
3.2.7	3.2.7. Элементарные действия целочисленной сериализации
3.2.8	3.2.8. По умолчанию, целые числа в ячейках имеют обратный порядок битов
3.2.9	3.2.9. Прочие элементарные действия сериализации
3.2.10	3.2.10. Прочие элементарные действия по созданию ячеек
3.2.11	3.2.11. Таксономия элементарных действий по десериализации ячейки
3.2.12	3.2.12. Прочие элементарные действия среза ячейки
3.2.13	3.2.13. Изменение сериализованного значения в ячейке
3.2.14	3.2.14. Изменение постоянного хранилища смарт-контракта
3.3	3.3 Хеш-таблицы или словари
3.3.1	3.3.1. Основные типы хеш-таблиц
3.3.2	3.3.2. Хеш-таблицы в виде деревьев Патриции.
3.3.3	3.3.3. Сериализация хеш-таблиц
3.3.4	3.3.4. Краткое описание TL-B схем
3.3.5	3.3.5. Применение сериализации хеш-таблиц.
3.3.6	3.3.6. Сериализация меток
3.3.7	3.3.7. Пример сериализации словаря.
3.3.8	3.3.8. Способы описания сериализации типа X
3.3.9	3.3.9. Упрощающее допущение о сериализации X
3.3.10	3.3.10. Основные операции со словарем
3.3.11	3.3.11. Таксономия элементарных действий со словарем
3.4	3.4 Хеш-таблицы с ключами переменной длины
3.4.1	3.4.1. Сериализация словарей с ключами переменной длины
3.4.2	3.4.2. Сериализация префиксных кодов
4	4. Управляющая логика, продолжения и ошибки
4.1	4.1 Продолжение и подпрограммы
4.1.1	4.1.1. Обычные продолжения.
4.1.2	4.1.2. Простые обычные продолжения.
4.1.3	4.1.3. Текущее продолжение cc.
4.1.4	4.1.4. Нормальная работа TVM, или основного цикла.
4.1.5	4.1.5. Особые продолжения.
4.1.6	4.1.6. Переход к другому продолжению:
4.1.7	4.1.7. Определение количества n аргументов, переданных следующему продолжению c.
4.1.8	4.1.8. Восстановление регистров управления из нового продолжения c.
4.1.9	4.1.9. Вызов подпрограмм: элементарные действия CALLX или EXECUTE.
4.1.10	4.1.10. Определение количества переданных аргументов и/или возвращаемых значений, принятых от подпрограммы.
4.1.11	4.1.11. CALLCC: вызов с текущим продолжением.
4.2	4.2 Элементарные действия управляющей логики: условное и итерационное исполнение
4.2.1	4.2.1. Условное исполнение:
4.2.2	4.2.2. Итерационное исполнение и циклы.
4.2.3	4.2.3. Константные, или литеральные, продолжения.
4.2.4	4.2.4. Константные продолжения в сочетании с условными или итерационными элементарными действиями исполнения.
4.3	4.3 Операции с продолжениями
4.3.1	4.3.1. Продолжения непрозрачны.
4.3.2	4.3.2. Допустимые операции с продолжениями.
4.3.3	4.3.3. Пример: операции с регистрами управления.
4.3.4	4.3.4. Пример: настройка количества аргументов функции в коде.
4.3.5	4.3.5. Булевы схемы.
4.3.6	4.3.6. Формирование продолжений.
4.3.7	4.3.7. Базовые элементарные действия формирования продолжений.
4.3.8	4.3.8. Продвинутые элементарные действия формирования продолжений.
4.4	4.4 Продолжения как объекты
4.4.1	4.4.1. Представление объектов с помощью продолжений.
4.4.2	4.4.2. Сериализуемые объекты.
4.4.3	4.4.3. Уникальные продолжения и возможности.
4.5	4.5 Обработка ошибок
4.5.1	4.5.1. Два аргумента обработчика ошибок: параметр ошибки и номер ошибки.
4.5.2	4.5.2. Элементарные действия генерации ошибок.
4.5.3	4.5.3. Ошибки, генерируемые TVM.
4.5.4	4.5.4. Обработка ошибок.
4.5.5	4.5.5. Обработчик ошибок по умолчанию.
4.5.6	4.5.6. Элементарное действие TRY.
4.5.7	4.5.7. Список предопределенных ошибок.
4.5.8	4.5.8. Порядок обработки ошибок исчерпания стека, проверки типа и проверки диапазона.
4.6	4.6 Функции, рекурсия и словари
4.6.1	4.6.1. Проблема рекурсии.
4.6.2	4.6.2. Решение Y -комбинатор: передать продолжение как собственный аргумент.
4.6.3	4.6.3. Вариант решения Y -комбинатор.
4.6.4	4.6.4. Сравнение: нерекурсивное определение факториальной функции.
4.6.5	4.6.5. Некоторые взаимно рекурсивные функции.
4.6.6	4.6.6. Объединение нескольких функций в один кортеж.
4.6.7	4.6.7. Объединение нескольких функций в функцию-селектор.
4.6.8	4.6.8. Использование специального регистра для сохранения функции-селектора.
4.6.9	4.6.9. Специальный регистр c3 для функции-селектора.
4.6.10	4.6.10. Инициализация c3.
4.6.11	4.6.11. Создание функций-селекторов и операторов переключения.
4.6.12	4.6.12. Альтернатива: использование хеш-таблицы для выбора правильной функции.
5	5 Кодовые страницы и кодировка команд
5.1	5.1 Кодовые страницы и взаимодействие различных версий TVM
5.1.1	5.1.1. Кодовые страницы в продолжениях.
5.1.2	5.1.3. В разных версиях TVM могут использоваться разные кодовые страницы.
5.1.3	5.1.4. Изменение поведения старых операций.
5.1.4	5.1.5. Улучшение кодировки команд.
5.1.5	5.1.6. Зависимая от контекста кодировка команд.
5.1.6	5.1.7. Использование кодовых страниц для флажков состояния и управления.
5.1.7	5.1.8. Установка кодовой страницы в самом коде.
5.2	5.2 Кодировка команд
5.2.1	5.2.1. Кодировка команд осуществляется двоичным префиксным кодом.
5.2.2	5.2.2. Определение первой команды кодового потока.
5.2.3	5.2.3. Неверный код операции.
5.2.4	5.2.4. Особый случай: заполнение конца кода.
5.2.5	5.2.5. Код TVM - это битный код, а не байт-код.
5.2.6	5.2.6. Объем кода операции, используемый полной командой.
5.2.7	5.2.7. Объем кода операции, используемый командой, или классом команд.
5.2.8	5.2.8. Объем кода операции для байт-кодов.
5.2.9	5.2.9. Практически оптимальные кодировки.
5.2.10	5.2.10. Пример: элементарные действия обработки стека.
5.2.11	5.2.11. Простая кодировка команд.
5.2.12	5.2.12. Дальнейшая оптимизация плотности кода: коды Хаффмана.
5.2.13	5.2.13. Кодировка команд на практике.
5.3	5.3 Кодировка команд на нулевой кодовой странице
5.3.1	5.3.1. Возможность модернизации.
5.3.2	5.3.2. Выбор команды.
5.3.3	5.3.3. Применение экспериментальных команд.
5.3.4	5.3.4. Выбор байт-кода.
5.3.5	5.3.5. Проста кодировка всех команд.
5.3.6	5.3.6. Отсутствие контекстно-зависимых кодировок.
6	A Команды и коды операций
6.1	А.1. Цена газа
6.2	A.2 Элементарные действия стековой обработки
6.2.1	А.2.1. Базовые элементарные действия стековой обработки.
6.2.2	А.2.2. Составные элементарные действия стековой обработки.
6.2.3	А.2.3. Особые элементарные действия стековой обработки.
6.3	A.3 Элементарные действия кортежа, списка и нуля
6.3.1	А.3.1. Нулевые элементарные действия.
6.3.2	А.3.2. Элементарные действия кортежей.
6.4	A.4 Константы или литеральные элементарные действия
6.4.1	А.4.1. Целочисленные и булевы константы.
6.4.2	А.4.2. Постоянные срезы, продолжения, ячейки и ссылки.
6.5	А.5 Арифметические элементарные действия
6.5.1	А.5.1. Сложение, вычитание, умножение.
6.5.2	А.5.2. Деление.
6.5.3	А.5.3. Сдвиги, логические операции.
6.5.4	А.5.4. Тихие арифметические элементарные действия.
6.6	A.6 Примитивы сравнения
6.6.1	А.6.1. Целочисленное сравнение.
6.6.2	А.6.2. Прочие сравнения.
6.7	A.7 Элементарные действия с ячейками
6.7.1	А.7.1. Элементарные действия сериализации ячеек.
6.7.2	А.7.2. Элементарные действия десериализации ячеек.
6.8	A.8 Элементарные действия продолжения и управляющей логики
6.8.1	А.8.1. Безусловные элементарные действия управляющей логики.
6.8.2	А.8.2. Условные элементарные действия управляющей логики.
6.8.3	А.8.3. Элементарные действия управляющей логики: циклы.
6.8.4	А.8.4. Управление стеком продолжений.
6.8.5	А.8.5. Создание простых продолжений и завершений.
6.8.6	А.8.6. Операции с продолжением сейвлистов и регистрами управления.
6.8.7	А.8.7. Вызов и переход подпрограмм словаря.
6.9	A.9 Элементарные действия генерирования и обработки ошибок
6.9.1	А.9.1. Генерирование ошибки.
6.9.2	А.9.2. Перехват и обработка ошибок.
6.10	A.10 Элементарные действия управления словарем
6.10.1	А.10.1. Создание словаря.
6.10.2	А.10.2. Сериализация и десериализация словаря.
6.10.3	А.10.3. Словарные операции GET
6.10.4	А.10.4. Словарные операции SET/REPLACE/ADD.
6.10.5	А.10.5. Варианты операций SET со словарем, принимающие значения Builder.
6.10.6	А.10.6. Словарные операции DELETE.
6.10.7	А.10.7. Словарные операции с «Возможно, ссылка».
6.10.8	А.10.8. Операции по созданию словарей с префиксным кодом.
6.10.9	А.10.9. Варианты операций GetNext и GetPrev.
6.10.10	А.10.10. Операции GetMin, GetMax, RemoveMin, RemoveMax.
6.10.11	А.10.11. Особые операции GET со словарями, словарями с префиксным кодом и постоянными словарями
6.10.12	А.10.12. SUBDICT операции со словарем.
6.11	A.11 Элементарные действия для конкретных приложений
6.11.1	А.11.1. Внешние действия и доступ к конфигурации данных блокчейна.
6.11.2	А.11.2. Элементарные действия, связанные с газом.
6.11.3	А.11.3. Элементарные действия генератора псевдослучайных чисел.
6.11.4	А.11.4. Конфигурационные элементарные действия.
6.11.5	А.11.5. Элементарные действия глобальных переменных.
6.11.6	А.11.6. Примитивы хеширования и криптографии.
6.11.7	А.11.7. Прочие элементарные действия.
6.11.8	А.11.8. Элементарные действия с валютой.
6.11.9	А.11.9. Элементарные действия с сообщениями и адресами.
6.11.10	А.11.10. Элементарные действия исходящих сообщений и выходного воздействия.
6.12	A.12 Элементарных действий отладки
6.12.1	А.12.1 Элементарные действия отладки как многобайтовые рабочие протоколы
6.12.2	А.12.2. Элементарные действия отладки как операции без побочных эффектов.
6.13	A.13 Элементарные действия кодовой страницы
7	B. Формальные свойства и характеристики TVM
7.1	B.1 Сериализация состояния TVM
7.1.1	В.1.2. Стек TVM.
7.1.2	В.1.3. Регистры управления TVM.
7.1.3	В.1.4. Лимиты газа TVM.
7.1.4	В.1.5. Библиотечная среда TVM.
7.1.5	В.1.6. Продолжения TVM.
7.1.6	В.1.7. Состояние TVM.
7.2	В.2 Ступенчатая функция TVM
7.2.1	В.2.1. Высокоуровневое определение ступенчатой функции.
7.2.2	В.2.2. Операционное определение ступенчатой функции.
7.2.3	В.2.3. Эталонная реализация эмулятора TVM.
7.2.4	В.2.4. Эталонная реализация в урезанной версии TVM.
7.2.5	В.2.5. Актуальность для блокчейна TON.
7.2.6	В.2.6. Кодовая страница -1.
7.2.7	В.2.7. Кодовая страница −2.
8	C. Плотность кода стековых и регистровых машин
8.1	C.1 Пример листовой функции
8.1.1	C.1.1. Пример исходного файла для листовой функции.
8.1.2	C.1.2. Трехадресная регистровая машина.
8.1.3	C.1.3. Двухадресная регистровая машина.
8.1.4	C.1.4. Одноадресная регистровая машина.
8.1.5	C.1.5. Стековая машина с базовыми элементарными действиями стековой обработки.
8.1.6	C.1.6. Стековая машина с составными элементарными действиями стековой обработки.
8.1.7	C.1.7. Стековая машина с составными элементарными действиями и неавтоматической оптимизацией.
8.2	C.2 Сравнение машинного кода для примера листовой функции
8.2.1	C.2.1. Соглашения о вызове регистров: некоторые регистры должны быть сохранены функциями.
8.2.2	C.2.2. m = 0: регистров для сохранения нет.
8.2.3	C.2.3. Случай m = n = 16: все регистры должны быть сохранены.
8.2.4	C.2.4. Случай m = 8, n = 16: регистры r8 ... r15 должны быть сохранены.
8.2.5	C.2.5. Более справедливое сравнение с использованием двоичного кода вместо байтового.
8.3	C.3 Пример нелистовой функции
8.3.1	C.3.1. Пример исходного кода для функции, не являющейся листовой.
8.3.2	C.3.2. Трехадресные и двухадресные регистровые машины, m = 0 сохраненных регистров.
8.3.3	C.3.3. Трехадресные и двухадресные регистровые машины, m = 8 сохраненных регистров.
8.3.4	C.3.5. Одноадресная регистровая машина, m = 0 сохраненных регистров.
8.3.5	C.3.6. Одноадресная регистровая машина, m = 8 сохраняемых регистров.
8.3.6	C.3.7. Одноадресная регистровая машина, m = 16 сохраняемых регистров.
8.3.7	C.3.8. Стековая машина с базовыми элементарными действиями стековой обработки.
8.3.8	C.3.9. Стековая машина с составными элементарными действиями стековой обработки.
8.4	C.4 Сравнение машинного кода для образца нелистовой функции
8.4.1	C.4.1. Объединение с результатами листовых функций.
8.4.2	C.4.2. Более справедливое сравнение с использованием двоичного кода вместо байтового.
8.4.3	C.4.3. Сравнение с реальными машинами.
8.4.4	C.4.4. Автоматическая генерация оптимизированного кода.
9	Сноски
Обзор
В данной главе представлен обзор ключевых особенностей и принципов TVM. Более подробное описание содержится в следующих главах.

1.0 Запись битовой строки
В данном документе битовая строки (строки) – конечные последовательности битов, состоящие из двоичных символов (битов), 0 и 1 – записываются следующим образом.

1.0.1 Шестнадцатеричная запись битовой строки
Если длина битовой строки кратна 4, мы подразделяем данную строку на группы, состоящие из 4 битов. Каждая такая группа стандартно записывается одной из 16 шестнадцатеричных символов 0-9, A-F: {\displaystyle {\texttt {0}}_{16}\leftrightarrow {\texttt {0000}},{\texttt {1}}_{16}\leftrightarrow {\texttt {0001}},\dots ,{\texttt {F}}_{16}\leftrightarrow {\texttt {1111}}}{\displaystyle {\texttt {0}}_{16}\leftrightarrow {\texttt {0000}},{\texttt {1}}_{16}\leftrightarrow {\texttt {0001}},\dots ,{\texttt {F}}_{16}\leftrightarrow {\texttt {1111}}}. Полученная в результате шестнадцатеричная строка – эквивалентное представление исходной битовой строки.

1.0.2 Битовые строки, не кратные четырем
Если длина битовой строки не кратна 4, мы добавляем в конец такой строки одну 1 и несколько (при необходимости) 0, чтобы длина битовой строки стала кратна 4. Затем данная строка преобразовывается в шестнадцатеричную, как описано в предыдущем пункте. В конец шестнадцатеричной строки добавляется особый заключительный тег _, указывающий на то, что данная строка подвергнута преобразованию. Обратное преобразование (применяется, если присутствует заключительный тег) осуществляется следующим образом: сначала каждое шестнадцатеричное число заменяется на 4 соответствующих бита, затем удаляются все конечные нули (при необходимости) и последняя 1 перед конечными нулями (если получившаяся в результате битовая строка непустая).

Обращаем внимание на то, что одна и та же битовая строка имеет несколько допустимых шестнадцатеричных представлений, одно из которых, самое короткое, является «каноническим». Данное представление может быть детерминированно получено описанным выше методом.

Например, 8А соответствует битовой сроке 10001010, а 8A_ и 8A0_ соответствуют 100010. Пустая битовая строка может быть представлена как ‘’, ‘8_’, ‘0_’, ‘_’ или ‘00_’.

1.0.3 Подчеркиваем, что строка является шестнадцатеричным представлением битовой строки.
Иногда необходимо подчеркнуть, что строка шестнадцатеричных символов (как с _, так и без него) является шестнадцатеричным представлением битовой строки. В таком случае мы можем либо добавить к началу получившейся строки x (например, x8A) или добавить в начале x{ и в конце строки } (например, x{2D9_}, что соответствует 00101101100). Однако, данное представление нельзя путать с шестнадцатеричными символами, в начале которых обычно ставится 0x (например, 0x2D9 или 0x2d9, соответствующих целому числу 729).

1.0.4 Сериализация битовой строки в последовательность октетов
Если битовую строку необходимо записать в виде последовательности 8-битовых байтов (октетов), значения которых представлены целыми числами 0 … 255, то мы следуем описанному выше принципу: разделяем битовую строку на группы из 8 битов и записываем каждую группу в качестве двоичной формы целого числа 0 … 255.Если длина битовой строки не кратна 8, то к строке добавляется двоичная 1 и до семи двоичных 0, затем строка разделяется на группы. На это обычно указывает заключительный тег.

Например, 00101101100 соответствует последовательности двух октетов (0x2d, 0x90) или (45, 144) (десятичный формат). Заключительный тег 1 (подчеркивающий дополнение битовой строки) хранится отдельно.

В некоторых случаях удобнее предположить, что дополнение проводилось по умолчанию, чем хранить дополнительный тег. Так, 8n-битовые строки представлены n+1 октетами, последний октет из которых всегда равен 0x80=128.

1.1 TVM – это стековая машина
Прежде всего TVM – это стековая машина. Это означает, что вместо сохранения значения в каких-то «переменных» или «регистрах общего назначения», они хранятся в стеках, организованных по принципу LIFO, по крайней мере, с «низкоуровневой» (TVM) точки зрения. (сноска 3)

Большинство операций и пользовательских функций забирают аргументы с верха стека и заменяют их результатом. Например, элементарное действие сложения целых чисел (встроенная операция) ADD не принимает никаких аргументов, описывающих, какие регистры или непосредственные значения подлежат сложению и где должен храниться результат. Вместо этого из стека берутся два верхних значения, складываются, а их сумма помещается в стек на их место.

1.1.1. Значения TVM.
Сущности, которые могут храниться в стеке TVM, называются значениями TVM, или, для краткости, просто значениями. Они принадлежат одному из нескольких предопределенных типов значений. Каждое значение может принадлежать только одному типу. Значения всегда хранятся в стеке вместе с тегами, определяющими их уникальный тип, все встроенные операции TVM (или элементарные действия) принимают исключительно значения предопределенных типов.

Например, элементарное действие сложения целых чисел ADD принимает только значения двух целых чисел, и результатом действия является одно целое значение. Функция ADD не может оперировать двумя строками, а не двумя целыми числами. Функция не может объединить эти строки в одну или преобразовать их в десятичное целое значение; любой попытка приведет к ошибке типизации па во время выполнения.

1.1.2. Статическая типизация, динамическая типизация и типизация во время выполнения.
В некоторых отношениях TVM выполняет своего рода динамическую типизацию, а именно – типизацию во время выполнения. Однако, код TVM нельзя считать «динамически типизированным языком», как PHP или Javascript, так как все элементарные действия принимают значения и возвращают результаты предопределенных типов (значений), каждое значение принадлежит строго одному типу, значения не могут быть неявно преобразованы из одного типа в другой.

Если, с другой стороны, сравнить код TVM с обычным микропроцессорным машинным кодом, мы увидим, что механизм TVM тегирования значений предотвращает, например, использование адреса строки в качестве числа - или, что еще хуже, использование числа в качестве адреса строки. Такой подход исключает возможность появления всевозможных ошибок и уязвимости безопасности системы, в том числе связанные с недопустимым доступом к памяти и обычно приводящие к нарушению целостности данных в памяти и ошибкам сегментации. Данная характеристика важна для виртуальных машин, используемых для выполнения смарт-контрактов в блокчейне. В этом отношении, решение отмечать типы всех значения, а не превращать битовую последовательность в регистре в зависимости от потребностей операции, - это дополнительный вклад в копилку механизмов TVM для обеспечения типобезопасности во время выполнения.

Альтернативным вариантом мог бы стать анализ кода смарт-контракта на предмет правильности типизации и типобезопасности перед их выполнением в виртуальной машине или даже его загрузки в блокчейн в качестве кода смарт-контракта. Такой статический анализ кода для полной по Тьюрингу машины представляет собой трудоемкую и нетривиальную задачу (вероятно, аналогична проблеме остановки для машин Тьюринга). В контексте смарт-контракта в блокчейне нам следует избегать подобного.

Необходимо помнить о возможности внедрения компиляторов из статически типизированных высокоуровневых языков смарт-контрактов в код TVM (предположительно, для большинства смарт-контрактов для TON будут использоваться именно такие языки) по аналогии с компиляцией статически типизированных языков в обычный машинный код (например, архитектура x86). При корректной работе компилятора полученный машинный код никогда не вызовет ошибок проверки типизации во время выполнения. Все теги типов, прикрепленные к значениям, обрабатываемым TVM, всегда будут обладать ожидаемыми значениями, а при анализе полученного TVM кода могут быть проигнорированы. Однако, генерирование времени выполнения и верификация тегов типов с помощью TVM немного замедлит выполнение кода TVM.

1.1.3 Предварительный список типов значений
Ниже приводится предварительный список типов значений, которые поддерживает TVM:

• Integer (целое) –257-битные целые со знаком, представляющие целые числа в диапазоне {\displaystyle -2^{256}\ldots 2^{256}-1}{\displaystyle -2^{256}\ldots 2^{256}-1}, а также особое «нечисловое» значение NaN.

• Cell (ячейка) - ячейка TVM, состоящая из не более 1023 бит данных и не более 4 ссылок на другие ячейки. Все постоянные данные (включая код TVM) в блокчейне TON представлены в виде набора ячеек TVM (см. [1, 2.5.14]).

• Tuple (кортеж) - упорядоченный набор до 255 компонентов с произвольными типами значений, типы могут различаться. Может использоваться для представления непостоянных значений произвольных алгебраических типов данных.

• Null (пусто) – данный тип имеет только одно значение {\displaystyle \bot }{\displaystyle \bot } и применяется для представления пустых списков, пустых веток бинарных деревьев, отсутствия возвращаемого значения и так далее.

• Slice (сектор) - сектор ячейки TVM, или, для краткости, сектор представляет собой непрерывную «суб-ячейку» существующей ячейки, содержащей некоторые ее данных и ссылки. По сути, сектор - это доступное только для чтения представление под-ячейки. Сектора используются для распаковки сохраненных (или сериализованных) данных в ячейку или дерево ячеек.

• Builder (компоновщик). Компоновщик ячеек TVM, или для краткости, компоновщик - это «неполная» ячейка, предназначенная для быстрых операций добавления битовых строк и ссылок на ячейки в конце. Компоновщики используются для упаковки (или сериализации) данных из вершины стека в новые ячейки (например, перед их переносом в постоянное хранилище).

• Continuation (продолжение) - представляет собой «маркер выполнения» для TVM, который может будет вызван (реализован) позже. Таким образом, он обобщает адреса функций (т.е. указатели на функции и ссылки), адреса возврата подпрограмм, адреса счетчика команд, адреса обработчиков ошибок, замыкания, частичные применения, анонимные функции и т. д.

Данный список типов значений неполный и может быть расширен в будущих версиях TVM, на старый код TVM это влиять не будет, в основном из-за того, что все изначально определенные элементарные действия принимают значения только известных им типов и дают сбой (ошибка проверки типизации) при использовании для значений новых типов. Кроме того, существующие типы значений в будущем также могут быть расширены: например, 257-битное целое (Integer) может стать 513-битным длинным целым (LongInteger), причем изначально определенные арифметические элементарные действия не будут работать, если любой из аргументов или результат не соответствует исходному подтипу Integer. Обратная совместимость с введением новых типов значений и расширений существующих типов рассмотрена подробнее далее по тексту (см. 5.1.4).

1.2 Категории машинных команд TVM
Команды TVM, которые также называются элементарными действиями и иногда (встроенными) операциями представляют собой мельчайшие операции, атомарно выполняемые TVM. Команды TVM могут присутствовать в коде TVM. Исходя из типов значений (см. 1.1.3), с которыми они работают, команды подразделяются на несколько категорий. Ниже перечислены основные категории:

• Стековые (операционные) элементарные действия - переупорядочивают данные в стеке TVM для последующего вызова других элементарных действия и пользовательских функций с правильными аргументами. В отличие от большинства других элементарных действий, они обладают возможностью реконфигурации (полиморфны), т.е. работают со значениями произвольных типов.

• Элементарные действия кортежей (операционные) - создание, изменение и разбивание кортежей на составные части. Как и стековые элементарные действия, они полиморфны.

• Константы или литеральные элементарные действия - вставляют в стек некоторую «константу» или «литеральное» значение, внедренные в сам код TVM, обеспечивая аргументы для других элементарных действий. Данный вид чем-то похож на стековые элементарные действия, но является менее общим, так как работает со значениями определенных типов.

• Арифметические элементарные действия - выполняет обычные целочисленные арифметические операции со значениями типа Integer. Элементарные действия ячеек (операционные) - создание новых ячеек и сохранение в них данных (элементарное действие по созданию ячеек) или чтение данные из созданных ячеек (элементарное действие анализа ячеек). Поскольку память и постоянное хранилище TVM состоят из ячеек, данные элементарные действия фактически фрагментами равны «командам доступа к памяти» в иных архитектурах. Элементарные действия по созданию ячеек обычно работают со значениями типа Builder, а элементарные действия парсинга ячеек работают с Slice.

• Элементарные действия продолжения и управляющей логики - создание и изменение Продолжений, а также реализация существующих продолжений различными способами, в том числе условное и повторное исполнение.

• Пользовательские или специализированные элементарные действия - эффективное выполнение определенных высокоуровневых действий, требуемых приложением (в нашем случае – блокчейном TON), такие как вычисление хэш-функций, осуществление шифрования на основе эллиптических кривых, отправка новых сообщений в блокчейне, создание новых смарт-контрактов и так далее. Эти элементарные действия соответствуют стандартным библиотечным функциям, а не командам микропроцессора.

1.3 Регистр управления
Хотя TVM является стековой машиной, некоторые редко изменяемые значения, которые требуются практически во всех функциях, лучше передавать в определенных регистрах, а не на вершине стека. В противном случае для управления всеми этими значениями потребуется недопустимое количество операций по переупорядочению стека.

В связи с этим модель TVM включает, помимо стека, до 16 специальных регистров управления, обозначаемых от c0 до c15 или от c(0) до c (15). Первоначлаьная версия TVM использует только некоторые из этих регистров; поддержка остальных может быть добавлена позже.

1.3.1. Значения в регистрах управления
Значения, хранящиеся в регистрах управления, относятся к тем же типам, что и значения, хранящиеся в стеке. Однако некоторые регистры управления принимают значения только определенных типов, а попытки загрузить значения другого типа вызовут ошибку.

1.3.2. Список регистров управления
Первоначальная версия TVM определяет и использует следующие регистры управления:

• c0 - содержит следующее или возвратное продолжение (аналогично адресу возврата из подпрограммы в обычных архитектурах). Данное значение должно быть продолжением.

• c1 - содержит альтернативное (возвратное) продолжение; это значение должно быть продолжением. Данный регистр используется в некоторых (экспериментальных) элементарных действиях, связанных с управляющей логикой, позволяющие TVM определять и вызывать «подпрограммы с двумя точками выхода».

• c2 - содержит обработчик исключений. Это значение является продолжением и вызывается всякий раз, когда инициируется ошибка.

• c3 - содержит текущий словарь, по сути хэш-карту, содержащую коды всех функций, используемых в программе. По причинам объясненным в разделе 4.6 это значение также является продолжением, а не ячейкой, как можно было бы ожидать.

• c4 - содержит корень постоянных данных или просто данные. Это значение является ячейка. При вызове кода смарт-контракта, c4 указывает на корневую ячейку своих постоянных данных, хранящихся в блокчейне. Если смарт-контракту необходимо изменить эти данные, он изменяет c4 перед возвратом из процедуры.

• c5 - содержит выходные воздействия. Это также ячейка, инициализированная ссылкой на пустую ячейку, но ее конечное значение считается одним из выходов смарт-контракта. Например, элементарное действие SENDMSG в блокчейне TON просто вставляет сообщение в список, хранящийся в выходных воздействиях.

• c7 - содержит корневой каталог временных данных. Это кортеж, инициализированный ссылкой на пустой кортеж перед вызовом смарт-контракта и удаляемый после его аннулирования. (сноска 4)

При необходимости, в будущем в блокчейне TON или в высокоуровневых языках программирования будет созданы другие регистры управления.

1.4 Состояние TVM в целом (SCCCG)
Состояние TVM в целом состоит из следующих компонентов:

• Стек (см. 1.1) - содержит ноль или несколько значений (см. 1.1.1), каждое из которых принадлежит одному из типов значений, перечисленных в 1.1.3.

• Регистры управления c0 – c15 - содержат некоторые определенные значения, описанные в 1.3.2. (в текущей версии используются только семь регистров управления)

• Текущее продолжение cc - содержит текущее продолжение (т. е. код, который обычно выполняется завершения текущего элементарного действия). Данный компонент схож с регистром счетчика команд (ip) в других архитектурах.

• Текущая кодовая страница cp - специальное 16-разрядное целое число со знаком, которое выбирает способ декодирования следующего кода операции TVM. Например, в будущих версиях TVM могут использовать разные кодовые страницы для добавления новых кодов операций при сохранении обратной совместимости.

• Лимит газа gas - содержит четыре 64-битных целых числа со знаком: текущий лимит газа {\displaystyle g_{l}}{\displaystyle g_{l}}, максимальный лимит газа {\displaystyle g_{m}}{\displaystyle g_{m}}, оставшийся газ {\displaystyle g_{r}}{\displaystyle g_{r}} и газовый кредит {\displaystyle g_{c}}{\displaystyle g_{c}}. Всегда {\displaystyle 0\leq g_{l}\leq g_{m},g_{c}\geq 0,}{\displaystyle 0\leq g_{l}\leq g_{m},g_{c}\geq 0,} и {\displaystyle g_{r}\leq g_{l}+g_{c};g_{c}}{\displaystyle g_{r}\leq g_{l}+g_{c};g_{c}} обычно инициализируется нулем, {\displaystyle g_{r}}{\displaystyle g_{r}} инициализируется {\displaystyle g_{l}+g_{c}}{\displaystyle g_{l}+g_{c}} и постепенно уменьшается по мере функционирования TVM. Когда {\displaystyle g_{r}}{\displaystyle g_{r}} становится отрицательным или если конечное значение {\displaystyle g_{r}}{\displaystyle g_{r}} меньше {\displaystyle g_{c}}{\displaystyle g_{c}}, возникает ошибка out of gas (кончился газ).

Обратите внимание на отсутствие «стека возвратов», содержащего адреса возврата всех ранее вызванных, но незавершенных функций. Используется только регистр управления c0. Причина объясняются в разделе 4.1.9.

Также обратите внимание на отсутствие регистров общего назначения, так как TVM - это стековая машина (см. 1.1). Следовательно, приведенный выше список, который можно назвать «стек, управление, продолжение, кодовая страница и газ» (SCCCG) по аналогии с классическим SECD («стек, среда, управление, дамп») представляет собой состояние TVM в общем. (сноска 5)

1.5 Арифметика целых чисел
Все арифметические элементарные действия TVM работают с несколькими аргументами типа Integer, взятыми из вершины стека, и возвращают свои результаты, принадлежащие к тому же типу, в стек. Напомним, что Integer представляет все целочисленные значения в диапазоне {\displaystyle -2^{256}\leq x<2^{256}}{\displaystyle -2^{256}\leq x<2^{256}} и дополнительно содержит специальное значение NaN («нечисловое значение»).

Если один из результатов не попадает в поддерживаемый диапазон целых чисел - или если один из аргументов - NaN - тогда этот результат или все результаты заменяются на NaN, и (по умолчанию) возникает ошибка переполнения целочисленного значения. Однако, особые «тихие» версии арифметических операций будут просто создавать NaN и продолжать свою работу. Если эти NaN в конечном итоге используются в «не-тихой» арифметической операции или в неарифметической операции, будет выведена ошибка переполнения целочисленного значения.

1.5.1. Отсутствие автоматического преобразования целых чисел.
Обратите внимание, что в TVM целые числа - это «математические» целые числа, а не 257-битные строки, интерпретируемые в зависимости от элементарного действия, как в других архитектурах. Например, TVM имеет только одно элементарное действие умножения MUL, а не два (MUL для беззнакового умножения и IMUL для знакового умножения), как, например, в известной архитектуре x86.

1.5.2. Автоматические проверки переполнения
Обратите внимание, что все арифметические элементарные действия TVM осуществляют проверку переполнения результатов. Если результат не укладывается в тип Integer, он заменяется на NaN, и (обычно) возникает ошибка. В частности, результат не уменьшается автоматически по модулю {\displaystyle 2^{256}}{\displaystyle 2^{256}} или {\displaystyle 2^{257}}{\displaystyle 2^{257}} , как в большинстве других архитектур.

1.5.3. Пользовательские проверки переполнения
Помимо автоматических проверок переполнения, TVM включает пользовательские проверки переполнения, выполняемые элементарными действиями FITS n и UFITS n, где 1 ≤ n ≤ 256. Эти элементарные действия проверяют, является ли значение на вершине стека - это целым x в диапазоне {\displaystyle -2^{n-1}\leq x<2^{n-1}}{\displaystyle -2^{n-1}\leq x<2^{n-1}} или {\displaystyle 0\leq x<2^{n}}{\displaystyle 0\leq x<2^{n}}, соответственно, заменяет значение на NaN и (необязательно) выдает ошибку переполнения целочисленного значения. Это значительно упрощает реализацию произвольных n-битных целочисленных типов со знаком или без знака: программист или компилятор должны вставить соответствующие элементарные действия FITS или UFITS либо после каждой арифметической операции (что более логично, но требует дополнительных проверок), либо перед сохранением вычисленных значений и возвращая. Это имеет первостепенное значение для смарт-контрактов, в которых неожиданные ошибки переполнения целочисленного значения являются самым распространенным источником багов.

1.5.4. Приведение по модулю {\displaystyle 2^{n}}{\displaystyle 2^{n}}
В TVM также есть элементарное действие MODPOW2 n, уменьшающее целое число на вершине стека по модулю {\displaystyle 2^{n}}{\displaystyle 2^{n}} с результатом в диапазоне от 0 до {\displaystyle 2^{n}-1}{\displaystyle 2^{n}-1}.

1.5.5. Целое число является 257-битным, а не 256-битным.
Теперь понятно, почему в TVM целое число (со знаком) 257-битное, а не 256-битное. Причина в том, что это наименьший целочисленный тип, содержащий как 256-битные целые числа со знаком, так и беззнаковые 256-битные целые числа, не требующие автоматической переинтерпретации одной и той же 256-битной строки в зависимости от операции (см. 1.5.1).

1.5.6. Деление и округление.
Важнейшие элементарные действия деления - это DIV, MOD и DIVMOD. Все они берут из стека по два числа x и y (y берется из вершины стека, а x изначально находится под ним), затем вычисляют частное q и остаток r от деления x на y (т. е. два целые числа такие, что {\displaystyle x=yq+r}{\displaystyle x=yq+r} и {\displaystyle |r|<|y|}{\displaystyle |r|<|y|}) и возвращают либо q, r, либо оба значения. Если y равен нулю, то все ожидаемые результаты заменяются на NaN, и (обычно) возникает ошибка переполнения целочисленного значения.

Реализация деления в TVM несколько отличается от большинства другие реализаций в отношении округления. По умолчанию элементарные действия округляются до −∞, что означает, что {\displaystyle q=\lfloor x/y\rfloor }{\displaystyle q=\lfloor x/y\rfloor } и r имеют тот же знак, что и y. (В большинстве стандартных реализаций деления используется «округление до нуля», то есть r имеет тот же знак, что и x). Помимо этого «округления по наибольшему целому», есть еще два других режима округления, т.н. «округление по наименьшему целому» (где {\displaystyle q=\lceil x/y\rceil }{\displaystyle q=\lceil x/y\rceil }, а r и y имеют противоположные знаки) и «ближайшее округление» (с {\displaystyle q=\lfloor x/y+1/2\rfloor }{\displaystyle q=\lfloor x/y+1/2\rfloor } и {\displaystyle |r|\leq |y|/2}{\displaystyle |r|\leq |y|/2}). Режим округления выбирается с помощью других элементарных действий деления с добавлением букв C и R к их символике. Например, DIVMODR вычисляет частное остаток с округлением до ближайшего целого числа.

1.5.7. Комбинированные операции умножение-деление, умножение-сдвиг и сдвиг-деление.
В целях упрощения реализацию арифметических действий с фиксированной точкой, TVM поддерживает комбинированные операции умножения-деления, умножения-сдвига и сдвига-деления с промежуточным итогом удвоенной длины (т. е. 514 бит). Например, MULDIVMODR берет три целочисленных аргумента из стека, a, b и c, сначала вычисляет ab с использованием 514-битного промежуточного результата, а затем делит ab на с с округлением до ближайшего целого числа. Если c равно нулю или если частное не вписывается в Integer, результатом операции является либо два NaN, либо ошибка переполнения целочисленного значения в зависимости от того, применялась ли тихая версия операции. В противном случае и частное, и остаток помещаются в стек.

2 Стек
В этой главе содержится общее описание и сравнение регистров и стековых машин, более подробное описание которых можно найти в Приложении C. Также в данной главе описываются два основных класса элементарных действий по стековой обработке, которые применяются в TVM: базовые и совокупные элементарные действия по стековой обработку. В главе предлагается неофициальное объяснение их применимости для переупорядочения стека, необходимого для правильного вызова других элементарных действий, а также пользовательских функций. Также обсуждается вопрос эффективной реализации элементарных действий по стековой обработке TVM.

2.1 Соглашения о вызове стека
Стековая машина, такая как TVM, применяет стек - и в особенности значения в верхней части стека - для передачи аргументов вызываемым функциям и элементарным действиям, (например, встроенные арифметические операции) и получения их результатов. В разделе обсуждаются соглашения о вызовах стека TVM, затрагивается вопрос представления, а также приводится сравнение соглашения о вызове стека TVM с соглашениями некоторых иных регистровых машин.

2.1.1. Представление «стековых регистров»
Напомним, что стековая машина отличается от более традиционных регистровых машин отсутствием универсальных регистров. Однако, можно рассматривать значения в верхней части стека как своего рода «стековые регистры».

Обозначим значение наверху стека как s0 или s(0), значение непосредственно под ним - как s1 или s(1) и т. д. Общее количество значений в стеке называется его глубиной. Если глубина стека равна n, то s(0), s(1), ..., s(n - 1) строго определены, а s(n) и все последующие s(i) с i>n - нет. Любая попытка использовать s(i) с i ≥ n должна привести к ошибке исчерпания стека.

Компилятор или программист в «коде TVM» будет использовать эти «стековые регистры» для хранения всех заявленных переменных и промежуточных значений, по аналогии с регистрами общего назначения в регистровых машинах.

2.1.2. Проталкивание и извлечение значений
Когда значение x помещается в стек глубиной n, оно становится новым s0; при этом старое s0 становится новым s1, старое s1 - новым s2 и так далее. Глубина полученного стека равен n + 1.

По аналогии, когда значение x извлекается из стека глубиной n ≥ 1, это старое значение s0 (т. е. старое значение на вершине стека). После этого оно удаляется из стека, а старое s1 становится новым s0 (новое значение на вершине стека), старое s2 становится новым s1 и так далее. Глубина полученного стека равна n - 1.

Если изначально n = 0, тогда стек пуст, а значение не может быть извлечено. Если элементарное действие пытается извлечь значение из пустого стека, возникает ошибка исчерпания стека.

2.1.3. Представление гипотетических универсальных регистров
Для сравнения стековых машин с достаточно универсальными регистровыми машинами, мы обозначим универсальные регистры регистровой машины r0, r1 и т. д., или r(0), r(1), ..., r(n - 1), где n - общее количество регистров. Когда нам требуется конкретное значение n, мы будем использовать n = 16, что соответствует широко распространенной архитектуре x86-64.

2.1.4. Регистр вершины стека s0 vs аккумулятор r0
В некоторых архитектурах регистровых машин требуется, чтобы один из аргументов для большинства арифметических и логических операций располагался в специальном регистре, т.н. аккумуляторе. В нашем сравнении допустим, что аккумулятор – это универсальный регистр r0; иначе мы могли бы просто изменить нумерацию регистров. В этом отношении аккумулятор чем-то похож на «регистр» вершины стека s0 стековой машины, потому что практически все операции стековой машины используют s0 в качестве одного из аргументов и возвращают результат как s0.

2.1.5. Соглашения о вызове регистра
При компиляции для регистровой машины, языковые функции высокого уровня обычно получают аргументы в определенных регистрах в заранее определенном порядке. Если аргументов слишком много, эти функции берут остаток из стека (да, регистровая машина обычно тоже имеет стек!). Однако, некоторые соглашения о вызове регистров не передают аргументы в регистр и используют только стек (например, исходные соглашения о вызове в Pascal и C, хотя современные версии C также применяют некоторые регистры).

Для упрощения предположим, что до m ≤ n аргументов функции передаются в регистрах, а эти регистры - это r0, r1, ..., r(m − 1), именно в этом порядке (если применяются другие регистры, их можно просто перенумеровать). (сноска 6)

2.1.6. Порядок аргументов функции
Если функция или элементарное действие требует m аргументов {\displaystyle x_{1},\dots ,x_{m}}{\displaystyle x_{1},\dots ,x_{m}} , они проталкиваются вызывающей программой в стек в том же порядке, начиная с {\displaystyle x_{1}}{\displaystyle x_{1}} . Следовательно, при вызове функции или элементарного действия, первый аргумент {\displaystyle x_{1}}{\displaystyle x_{1}} расположен в пределах s(m - 1), второй аргумент - s(m - 2), и так далее. Последний аргумент {\displaystyle x_{m}}{\displaystyle x_{m}} расположен в s0 (т.е. на вершине стека). Вызываемая функция или элементарное действие отвечают за удаление своих аргументов из стека.

В этом отношении соглашения о вызове стека TVM – которым подчиняются, по крайней мере, элементарные действия TMV - совпадают с элементарными действиями Pascal и Forth и противоположны элементарным действиям C (когда аргументы помещаются в стек в обратном порядке и удаляются вызывающей программой после восстановления контроля, а не вызываемым компонентом).

Конечно, реализация языка высокого уровня для TVM может выбрать иные соглашения о вызове функций, отличных от соглашений по умолчанию. Это может оказаться полезным для определенных функций - например, если общее количество аргументов зависит от значения первого аргумента, например, в случае с «вариативными функциями», такими как scanf и printf. В таких случаях, первый или несколько аргументов желательно передавать в верхней части стека, а не в неизвестном месте глубоко в стеке.

2.1.7. Аргументы арифметических элементарных действий на регистровых машинах
На стековой машине встроенные арифметические элементарные действия (такие как ADD или DIVMOD) подчиняются тем же соглашениям о вызове, что и пользовательские функции. В этом отношении, определяемые пользователем функции (например, функция вычисления квадратного корня) могут рассматриваться в качестве «расширения» или «персонализированного обновления» стековой машины. В этом заключается одно из наиболее очевидных преимуществ стековых машин (и стековых языков программирования, например, Forth) по сравнению с регистровыми машинами.

Напротив, арифметические инструкции (встроенные операции) в регистровых машинах обычно получают параметры из универсальных регистров, закодированных в полном коде операции. Таким образом, бинарная операция, например, SUB, требует двух аргументов: r(i) и r (j), где i и j указаны в инструкции. Также необходимо указать регистр r(k) для сохранения результата. Арифметические операции могут отличаться по формату, в зависимости от того, разрешено ли i, j и k принимать произвольные значения:

• Трехадресная форма - позволяет программисту произвольно выбирать не только два исходных регистра r(i) и r (j), но и отдельный аккумулятор, регистр назначения r (k ), если он присутствует. Эта форма является общей для большинства процессоров RISC, а также для набора команд XMM и AVX SIMD в архитектуре x86-64.

• Двухадресная форма - используется один из двух регистров операндов (обычно r(i)) для хранения результата операции, так что k = i никогда не указывается явно. Внутри команды кодируются только i и j. Это наиболее распространенная форма арифметических операций на регистровых машинах и довольно популярная на микропроцессорах (включая x86).

• Одноадресная форма - всегда принимает один из аргументов аккумулятора r0, а также сохраняет результат в r0; тогда i = k = 0, а в команде указывается только j. Эта форма используется в более простых микропроцессорах (например, Intel 8080).

Обратите внимание, что эта гибкость доступна только для встроенных операций, но не для для пользовательских функций. В этом отношении регистровые машины не так легко «модернизируются», как стековые. (сноска 7)

2.1.8. Возвращаемые значения функций
В стековых машинах, таких как TVM, когда функции или элементарному действию необходимо вернуть значение результата, оно просто проталкивается в стек (из которого все аргументы функции уже удалены). Следовательно, вызывающий оператор сможет получить доступ к результату через верхний «регистр» s0.

Это полностью соответствует соглашениям о вызовах Forth, но отличается немного от соглашений о вызовах Pascal и C, где аккумулятор r0 обычно используется для возвращаемого значения.

2.1.9. Возврат нескольких значений
Некоторым функциям может потребоваться вернуть несколько значений {\displaystyle y_{1}}{\displaystyle y_{1}}, ..., {\displaystyle y_{k}}{\displaystyle y_{k}}, причем k не обязательно равно единице. В этих случаях, k возвращаемых значений помещаются в стек в их естественном порядке, начиная с у1.

Например, элементарное действие DIVMOD «деление с остатком» должно возвращать два значения, частное q и остаток r. Следовательно, DIVMOD помещает q и r в стек в указанном порядке, чтобы получить частное s1, а остаток - s0. Результирующее влияние DIVMOD заключается в делении исходного значения s1 на исходное значение s0 и возвращения частного в s1 и остатка в s0. В данном конкретном случае глубина стека и значения всех остальных «стековых регистров» остаются неизменными, потому что DIVMOD берет два аргумента и возвращает два результата. В целом, значения других «стековых регистров», находящихся в стеке под передаваемыми аргументами и возвращаемыми значениями, сдвигаются в соответствии с изменением глубины стека.

В принципе, некоторые элементарные действия и пользовательские функции могут возвращать переменное количество значений. В связи с этим, вышеупомянутые замечания о вариативных функциях (см . 2.1.6 ) применяются в том случае, если: общее количество значений результата и их типы должны определяться значениями в верхней части стека. (Например, можно протолкнуть возвращаемые значения {\displaystyle y_{1}}{\displaystyle y_{1}}, ..., {\displaystyle y_{k}}{\displaystyle y_{k}}, а затем протолкнуть их общее количество k, как целое число. Затем вызывающий оператор определит общее количество возвращаемых значений путем проверки s0.)

В этом отношении TVM снова неукоснительно соблюдает соглашения о вызовах Forth.

2.1.10. Представление стека
Когда стек глубины n содержит значения {\displaystyle z_{1}}{\displaystyle z_{1}} , ...,{\displaystyle z_{n}}{\displaystyle z_{n}} в таком порядке, где {\displaystyle z_{1}}{\displaystyle z_{1}} - самый глубокий элемент, а {\displaystyle z_{n}}{\displaystyle z_{n}} - вершина стека, содержимое стека часто представляется списком {\displaystyle z_{1}z_{2}\dots z_{n}}{\displaystyle z_{1}z_{2}\dots z_{n}}, в таком порядке. Когда элементарное действие преобразует исходное состояние стека {\displaystyle S'}{\displaystyle S'} в новое состояние {\displaystyle S''}{\displaystyle S''}, оно записывается как {\displaystyle S'--S''}{\displaystyle S'--S''}; это так называемое представление стека. Например, элементарное действие деления DIV можно описать как {\displaystyle Sxy--S\lfloor x/y\rfloor }{\displaystyle Sxy--S\lfloor x/y\rfloor }, где S - любой список значений. Обычно это сокращается до {\displaystyle xy--\lfloor x/y\rfloor }{\displaystyle xy--\lfloor x/y\rfloor }, косвенно намекая на то, что все другие значения глубже в стеке остаются в неизменном состоянии.

В качестве альтернативы можно описать DIV как элементарное действие в стеке {\displaystyle S'}{\displaystyle S'} глубины n ≥ 2, которое делит s1 на s0 и возвращает округленное частное как s0 нового стека {\displaystyle S''}{\displaystyle S''} глубиной n - 1. Новое значение s(i) равно старому значению s(i + 1) для 1 ≤ i < n - 1. Эти описания эквивалентны, но пояснение, что DIV преобразует в {\displaystyle \lfloor x/y\rfloor }{\displaystyle \lfloor x/y\rfloor } или {\displaystyle \lfloor x/y\rfloor }{\displaystyle \lfloor x/y\rfloor }, лаконичнее.

Представление стека широко используется в Приложении А, в котором перечислены текущие элементарные действия TVM.

2.1.11. Явное определение количества аргументов функции
Стековые машины обычно полностью передают текущий стек вызываемому элементарному действию или функции. Это элементарное действие или функция обращаются только к нескольким значениям в верхней части стека, которые являются его аргументами, и проталкивают на их место возвращаемое значение, по соглашению не затрагивая все более глубокие значения. Затем полученный в результате стек снова полностью возвращается вызывающему оператору.

Большинство элементарных действий TVM ведут себя подобным образом, и мы ожидаем, что большинство пользовательских функций будут реализованы в соответствии с данными соглашениями. Однако TVM предлагает механизмы, позволяющие определить, сколько аргументов подлежат передаче вызываемой функции (см . 4.1.10 ). При использовании этих механизмов указанное количество значений перемещается из вызывающего стека в (обычно изначально пустой) стек вызываемой функции, а более глубокие значения остаются в вызывающем стеке и недоступны для вызываемого стека. Вызывающий оператор также может указать, сколько возвращаемых значений ожидается от вызываемой функции.

Такие механизмы проверки аргументов могут пригодиться, например, для библиотечной функции, которая вызывает предоставленные пользователем функции, переданные в качестве аргументов.

2.2 Элементарные действия стековой обработки
В стековой машине, такой как TVM, используется множество первичных действий стековой обработки для перестановки аргументов в другие элементарные действия я и пользовательские функции, так, чтобы последние располагались ближе к вершине стека в правильном порядке. В данной главе изучается вопрос, какие элементарные действия стековой обработки необходимы и в достаточной мере подходят для достижения этой цели, а также какие из них используются TVM. Примеры кода, использующего эти элементарные действия, собраны в Приложении C.

2.2.1.
Базовые элементарные действия стековой обработки. Наиболее важные базовые элементарные действия стековой обработки TVM перечислены ниже:

• Операция обмена в верхней части стека {\displaystyle {\texttt {XCHGs0,s(i)}}}{\displaystyle {\texttt {XCHGs0,s(i)}}} или {\displaystyle {\texttt {XCHGs(i)}}}{\displaystyle {\texttt {XCHGs(i)}}} - меняет местами значения s0 и s(i). Когда i = 1, операция {\displaystyle {\texttt {XCHGs1}}}{\displaystyle {\texttt {XCHGs1}}}, традиционно обозначается SWAP. Когда i = 0, это NOP (операция не выполняет никаких действий, по крайней мере, если стек не пуст).

• Операция произвольного обмена: {\displaystyle {\texttt {XCHGs(i),s(j)}}}{\displaystyle {\texttt {XCHGs(i),s(j)}}} - заменяет значения s(i) и s(j). Обратите внимание, что эта операция не является строго необходимой, поскольку ее можно смоделировать с помощью трех обменов на вершине стека: {\displaystyle {\texttt {XCHGs(i)}};{\texttt {XCHGs(j)}};{\texttt {XCHGs(i)}}}{\displaystyle {\texttt {XCHGs(i)}};{\texttt {XCHGs(j)}};{\texttt {XCHGs(i)}}}. Однако, полезно иметь произвольный обмен в качестве элементарного действия, потому что он требуется довольно часто.

• Операция проталкивания: {\displaystyle {\texttt {PUSHs(i)}}}{\displaystyle {\texttt {PUSHs(i)}}} - проталкивает копию (старого) значения s(i) в стек. Традиционно PUSH s0 также обозначается, как DUP (оно дублирует значение наверху стека) и PUSH s1 как OVER.

• Операция извлечения: {\displaystyle {\texttt {POPs(i)}}}{\displaystyle {\texttt {POPs(i)}}} - извлекает значение из вершины стека и помещает его в (новый) s(i - 1) или старый s(i) стек. Традиционно, POP s0 также обозначается DROP (просто отбрасывает значение вершины стека), а POP s1 как NIP.

Возможны и другие «бессистемные» элементарные действия стековой обработки (например, ROT, с представлением стека abc - bca). Подобные операции определены в стековых языках программирования, таких как Forth (где также присутствуют DUP, DROP, OVER, NIP и SWAP), они не являются строго необходимыми, потому что основных перечисленных выше элементарных действий стековой обработки достаточно для перестановки стековых регистров для обеспечения корректности любых арифметических элементарных действий и пользовательских функций.

2.2.2. Применение базовых элементарных действий стековой обработки
Компилятор или программист TVM может использовать базовые элементарные действия стековой обработки следующим образом.

Предположим, что вызываемая функция или элементарное действие должны передать, скажем, три аргумента x, y и z, которые в настоящее время находятся в стековых регистрах s(i), s(j), и s(k). В этом случае компилятор (или программист) может выдать операцию PUSH s (i) (если после вызова этого элементарного действия требуется копия x) или XCHG s (i) (если впоследствии копия не требуется) для постановки первого аргумента x в верхнюю часть стека. Затем компилятор (или программист) может использовать либо {\displaystyle {\texttt {PUSHs(j')}}}{\displaystyle {\texttt {PUSHs(j')}}}, либо {\displaystyle {\texttt {XCHGs(j')}}}{\displaystyle {\texttt {XCHGs(j')}}}, где {\displaystyle j'=j}{\displaystyle j'=j} или j + 1, чтобы поместить y на новую вершину стека. (сноска 8)

Действуя таким образом, мы видим, что можем поместить исходные значения x, y и z – или, при необходимости, их копии - в s2, s1 и s0, используя последовательность операций проталкивания и обмена (см. 2.2.4 и 2.2.5 для получения более подробной информации). Для того, чтобы сгенерировать эту последовательность, компилятору нужно знать только три значения i, j и k, описывающие старые местоположения переменных или временные значения, а также некоторые метки, поясняющие, нужно ли в дальнейшем каждое значение или они необходимы только для данного элементарного действия или вызова функции. Расположение других переменных и временных значений будет затронуто, но компилятор (или программист) может легко отследить их новые местоположения.

Точно так же, если результаты, возвращенные функцией, требуется отбросить или переместить в другие стековые регистры, можно применить операции обмена и проталкивания в определенной последовательности. В типичном случае одного возвращаемого значения в s0, можно применить либо {\displaystyle {\texttt {XCHGs(i)}}}{\displaystyle {\texttt {XCHGs(i)}}}, либо {\displaystyle {\texttt {POPs(i)}}}{\displaystyle {\texttt {POPs(i)}}} (в большинстве случаев, DROP). (сноска 9)

Изменение порядка значений перед их возвратом представляет, по сути, ту же проблему, что и организация аргументов для вызова функции, и решается аналогично.

2.2.3. Составные элементарные действия стековой обработки
В целях увеличения плотности кода TVM и упрощение разработки компиляторов, возможно применение составных элементарных действий стековой обработки, каждое из которых объединяет до четыре базовых действий по проталкиваю, извлечению или обмену. Ниже приводятся примеры таких составных элементарных действий: • XCHG2 s(i), s(j) - аналог XCHG s1, s(i); XCHG s(j).

• PUSH2 s(i), s(j) - аналог PUSH s(i); PUSH s(j + 1).

• XCPU s(i), s(j) - аналог XCHG s(i); PUSH s(j).

• PUXC s(i), s(j) - аналог PUSH s(i); SWAP; XCHG s(j + 1), если {\displaystyle j\neq i}{\displaystyle j\neq i} и {\displaystyle j\neq 0}{\displaystyle j\neq 0}, это также эквивалентно XCHG s(j); PUSH s(i); SWAP.

• XCHG3 s(i), s(j), s(k) - аналог XCHG s2, s(i); XCHG s1, s(j); XCHG s(k).

• PUSH3 s (i), s(j), s(k) - аналог PUSH s(i); PUSH s(j + 1); PUSH s(k + 2).

Конечно, такие операции имеют смысл только в том случае, если подразумевается более компактное кодирование, чем эквивалентная последовательность базовых операций. Например, если все обмены на вершине стека, обмены XCHG s1, s(i) и операции вталкивания и извлечения допускают однобайтовую кодировку, единственные составные действия, предложенные выше, которые могут быть включены в список элементарных действий стековой обработки - PUXC, XCHG3 и PUSH3.

Данные составные операции существенно дополняют другие элементарные действия (команды) в коде с «истинным» расположением их операндов, аналогично тому, что происходит с машинным кодом двухадресного или трехадресного регистра. Однако вместо того, чтобы закодировать их местоположения внутри операционного кода арифметической или другой команды, как это делается в регистровых машинах, мы указываем эти местоположения в предыдущей составной операции. Согласно пункту 2.1.7 , преимущество этого подхода заключается в том, что он может положительно отразиться на пользовательских функциях (или редко используемых конкретных элементарных действиям, которые могут быть добавлены в будущую версию TVM) (см. раздел).

2.2.4. Символика составных элементарных действий стековой обработки
Символика составных элементарных действий стековой обработки, некоторые примеры которых были предоставлены в 2.2.3, формируется следующим образом.

{\displaystyle \gamma \geq 2}{\displaystyle \gamma \geq 2} формальных аргументов {\displaystyle {s(i_{1})},\dots ,{s(i_{\gamma })}}{\displaystyle {s(i_{1})},\dots ,{s(i_{\gamma })}} для операции O представляют значения в исходном стеке, которые окажутся в {\displaystyle {s(\gamma -1)},\dots ,{s0}}{\displaystyle {s(\gamma -1)},\dots ,{s0}} после выполнения данной составной операции, по крайней мере, если все {\displaystyle \$i_{\nu },1\leq \nu \leq \gamma }{\displaystyle \$i_{\nu },1\leq \nu \leq \gamma }, различны и не меньше γ. Сама символика операции O - это последовательность γ двухбуквенных строк PU и XC, где PU означает, что соответствующий аргумент должен быть протолкнут (т. е. должна быть создана копия), а XC означает, что значение должно быть заменено (т. е. иной копии исходного значения не требуется). Последовательности нескольких строк PU или XC могут сокращаться до одного PU или XC, за которым следует количество копий. (Например, PUXC2PU вместо PUXCXCPU.)

В качестве исключения, если символика будет состоять только из строк PU или только строк XC, а составная операция эквивалентна последовательности из m PUSH или eXCHanGe операций, обозначение PUSHm или XCHGm используется вместо PUm или XCm.

2.2.5. Семантика составных элементарных действий стековой обработки
Каждая составная γ-операция O {\displaystyle {s(i_{1})},\dots ,{s(i_{\gamma })}}{\displaystyle {s(i_{1})},\dots ,{s(i_{\gamma })}} переводится в эквивалентную последовательность элементарных действий стековой обработки по индукции γ следующим образом:

• В качестве основы индукции, если γ = 0, единственная составная стековая операция с нулевым значением, которая соответствует пустой последовательности базовых стековых операций.

• По аналогии, мы можем начать индукцию с γ = 1. Тогда PU s(i) соответствует последовательности, состоящей из одной базовой операции PUSH s(i), а XC s(i) соответствует одноэлементной последовательности, состоящей из XCHG s (i).

• Для γ ≥ 1 (или для γ ≥ 2, если используем γ = 1 в качестве основы индукции), существуют два подслучая:

1. {\displaystyle O{\texttt {s}}(i_{1}),\ldots ,{\texttt {s}}(i_{\gamma })}{\displaystyle O{\texttt {s}}(i_{1}),\ldots ,{\texttt {s}}(i_{\gamma })} c {\displaystyle O={\texttt {XC}}O'}{\displaystyle O={\texttt {XC}}O'}, где {\displaystyle O'}{\displaystyle O'} - составная операция арности γ − 1 (т.е. символика {\displaystyle O'}{\displaystyle O'} состоит из γ − 1 строк ХС и PU). Пусть α - общее количество PU в O, а β - XC, так что α + β = γ. Тогда исходная операция переводится в {\displaystyle {XCHGs(\beta -1),s(i_{1})}}{\displaystyle {XCHGs(\beta -1),s(i_{1})}}, за чем следует перевод из {\displaystyle \$O'{\texttt {s}}(i_{2}),\ldots ,{\texttt {s}}(i_{\gamma })}{\displaystyle \$O'{\texttt {s}}(i_{2}),\ldots ,{\texttt {s}}(i_{\gamma })}, определенный согласно индукционной гипотезе.

2. {\displaystyle O{\texttt {s}}(i_{1}),\ldots ,{\texttt {s}}(i_{\gamma })}{\displaystyle O{\texttt {s}}(i_{1}),\ldots ,{\texttt {s}}(i_{\gamma })} с {\displaystyle O={\texttt {PU}}O'}{\displaystyle O={\texttt {PU}}O'} - составная операция арности γ - 1. Тогда исходная операция преобразовывается в {\displaystyle {PUSHs(i_{1})};{XCHGs(\beta )}}{\displaystyle {PUSHs(i_{1})};{XCHGs(\beta )}}, за чем следует перевод в {\displaystyle \$O'{\texttt {s}}(i_{2}+1),\ldots ,{\texttt {s}}(i_{\gamma }+1)}{\displaystyle \$O'{\texttt {s}}(i_{2}+1),\ldots ,{\texttt {s}}(i_{\gamma }+1)}, определенный согласно индукционной гипотезе. (сноска 10)

2.2.6. Команды по стековой обработке полиморфны
Обратите внимание на то, что команды по стековой обработке - почти единственные "полиморфные" элементарные действия в TVM, т. е. работают со значениями произвольных типов (включая типы значений, которые появятся только в будущих версиях TVM). Например, SWAP всегда меняет местами два верхних значения стека, даже если одно из них - целое, а другой - ячейка. Почти все остальные команды, в особенности команды по обработке данных (включая арифметические команды), требуют, чтобы каждый из их аргументов был определенного типа (типы аргументов могу различаться).

2.3 Эффективность элементарных действий стековой обработки
Элементарные действия стековой обработки, используемые стековыми машинами, например, TVM, должны быть реализованы максимально эффективно, так как они составляют более чем половину всех команд, используемых в стандартной программе. Фактически, TVM выполняет все эти команды за (малое) постоянное время, независимо от значений (даже если они представляют собой очень большие целые числа или очень большие двевовидные схемы).

2.3.1. Реализация элементарных действий стековой обработки:
использование ссылки вместо объектов-значений. Эффективность реализации элементарных действий стековой обработки в TVM достигается благодаря тому, что типичная реализация TVM хранит в стеке не объекты-значения, а только ссылки (указатели) на них. Поэтому SWAP-команда просто меняет местами ссылки на s0 и s1, а не реальные объекты-значения, к которым они относятся.

2.3.2. Эффективная реализация команд DUP и PUSH с использованием COW (копирование при записи).
Кроме того, команда DUP (в более общем смысле PUSH s(i)), которая, кажется, создает копию потенциально большого объекта за малое постоянное время, использует технику копирования при записи с задержкой копирования: копируется только ссылка вместо самого объекта, но «счетчик ссылок» внутри объекта разрастается, таким образом, разделяя объект между двумя ссылками. Если делается попытка изменить объект с помощью счетчика ссылок больше единицы, то сначала создается отдельная копия объекта (что влечет «штраф за неоднозначность» или «штраф за копирование» за команду по обработке данных, которая инициировала создание новой копии).

2.3.3. Сборка мусора и подсчет ссылок.
Когда счетчик ссылок объекта TVM принимает нулевое значение (например, если последняя ссылка на такой объект использована операцией DROP или арифметической командой), он немедленно освобождается. Поскольку циклические ссылки в структурах данных TVM невозможны, данный метод подсчета ссылок обеспечивает быстрый и удобный способ освобождения неиспользуемых объектов, заменив собой медленные и непредсказуемые сборщики мусора.

2.3.4. Прозрачность реализации: значения стека – это «значения», а не «ссылки».
Независимо от азов реализации, перечисленных выше, все значения стека на самом деле являются «значениями», а не «ссылками», с точки зрения программиста TVM, по аналогии со значениями всех типов в функциональных языках программирования. Любая попытка изменить существующий объект, на который ссылаются любые другие объекты или места стека, приведет к прозрачной замене этого объекта его точной копией до того, как будут осуществлены необходимые изменения.

Другими словами, программист всегда должен руководствоваться такими принципами, как если бы объекты напрямую управлялись с помощью стековых, арифметических и иных элементарных действий. Пояснение выше следует рассматривать только в рамках объяснения высокой эффективности элементарных действий стековой обработки.

2.3.5. Отсутствие циклических ссылок.
Можно попытаться создать циклическую ссылку между двумя ячейками, A и B, следующим образом: сначала создайте A и запишите в нее данные; затем создайте B и запишите в нее некоторые данные вместе со ссылкой на ранее созданную ячейку A; наконец, добавьте ссылку на ячейку B в ячейку A. Хотя может показаться, что после этой последовательности операций мы получим ячейку A, которая ссылается на ячейку B, которая, в свою очередь, ссылается на ячейку A, это не так. Фактически, мы получаем новую ячейку A’, которая содержит копию исходных данных, записанных в ячейку A, а также ссылку на ячейку B, которая содержит ссылку на (исходную) ячейку A.

Таким образом, прозрачный механизм копирования при записи и парадигма «все является значением» позволяют создавать новые ячейки, используя только ранее созданные ячейки, тем самым делая невозможным появление циклических ссылок. Это правило также применяется ко всем другим структурам данных: например, отсутствие циклических ссылок позволяет TVM использовать подсчет ссылок для немедленного освобождения неиспользуемой памяти вместо того, чтобы полагаться на сборщики мусора. Эта особенность имеет решающее значение для хранения данных в блокчейне TON.

3 Ячейки, память и база данных
В этой главе кратко описаны ячейки TVM, которые используются для представления всех структур данных в памяти TVM и ее базе данных, а также основные операции по созданию ячеек, записи (или сериализации) в них данных и чтения (или десериализации) данные.

3.1 Общие сведения о ячейках
В этом разделе представлена классификация и общие описания типов ячеек.

3.1.1. Память TVM и база данных состоят из ячеек.
Вспомним, что память TVM и база данных состоят из ячеек (TVM). Каждая ячейка содержит до 1023 бит данных и до четырех ссылок на другие ячейки. (сноска 11) Циркулярные ссылки запрещены и не могут быть созданы с помощью TVM. (см 2.3.5 ). Таким образом, все ячейки, которые хранятся в памяти TVM и в базе данных, представляют собой направленный ациклический граф (НАГ).

3.1.2. Обыкновенные и особые ячейки.
Помимо данных и ссылок, ячейка обладает типом ячейки, закодированным целым числом -1 ... 255. Ячейка типа −1 называется обыкновенной; такие ячейки не требуют специальной обработки. Ячейки других типы называются особыми и могут быть загружены - автоматически заменены на другие ячейки при попытке десериализации (т. е. преобразование в срез командой CTOS). Они также могут демонстрировать нестандартное поведение при вычислении их хэшей.

Чаще всего особые ячейки используются для представления некоторых других ячеек, например, ячеек во внешней библиотеке или удаленных из исходного древа ячеек при создании доказательства Меркла.

Тип особой ячейки хранится в первых восьми битах ее данных. Если особая ячейка имеет менее восьми бит данных, она считается неработоспособной.

3.1.3. Уровень ячейки
Каждая ячейка c обладает атрибутом Lvl (c), определяющей ее уровень (де Брейна), который в настоящее время принимает целые значения в диапазоне 0.. . 3.

Уровень обыкновенной ячейки всегда равен максимальному уровню его дочерних элементов {\displaystyle c_{i}}{\displaystyle c_{i}}:

Lvl(c) = max  Lvl(


    {\displaystyle c_{i}}

{\displaystyle c_{i}})
        1≤i≤r
для обычной ячейки c, содержащей r ссылок на ячейки c {\displaystyle c_{1},\dots ,c_{r}}{\displaystyle c_{1},\dots ,c_{r}}. Если r = 0, Lvl(c) = 0. У особых ячеек могут быть различные правила определения уровня.

Уровень ячейки влияет на количество старших хэшей. Точнее, ячейка уровня l обладает l старших хэшей {\displaystyle Hash_{1}(c),\dots ,Hash_{l}(c)}{\displaystyle Hash_{1}(c),\dots ,Hash_{l}(c)} в дополнение к своему репрезентативному хешу {\displaystyle Hash(c)}{\displaystyle Hash(c)} ={\displaystyle Hash_{\infty }(c)}{\displaystyle Hash_{\infty }(c)}. Появляются ячейки ненулевого уровня внутри доказательств Меркла и обновлений Меркла, после того, как некоторые ветви древа ячеек, представляющие значение абстрактного типа данных, удаляются.

3.1.4. Стандартное представление ячейки
Когда ячейку необходимо передать по сетевому протоколу или сохранить в файле на диске, она подлежит сериализации. В стандартном представлении ячейки c как последовательности октетов (байтов) строится следующим образом:

1. Сперва сериализуются два байта дескриптора {\displaystyle d_{1}}{\displaystyle d_{1}} и {\displaystyle d_{2}}{\displaystyle d_{2}}. Байт {\displaystyle d_{1}}{\displaystyle d_{1}} равен {\displaystyle r+8s+32l}{\displaystyle r+8s+32l}, где {\displaystyle 0\leq r\leq 4}{\displaystyle 0\leq r\leq 4} - количество содержащихся ссылок на ячейки в ячейке, 0 ≤ {\displaystyle l}{\displaystyle l} ≤ 3 - уровень ячейки, а 0 ≤ s ≤ 1 - 1 для особых ячейки и 0 для обыкновенных ячеек. Байт {\displaystyle d_{2}}{\displaystyle d_{2}} равен {\displaystyle \lfloor b/8\rfloor +\lceil b/8\rceil }{\displaystyle \lfloor b/8\rfloor +\lceil b/8\rceil }, где 0 ≤ b ≤ 1023 - количество битов данных в c.

2. Затем биты данных сериализуются как 8-битные октеты (байты) {\displaystyle \lceil b/8\rceil }{\displaystyle \lceil b/8\rceil }. Если b не кратно восьми, двоичная 1 и до шести двоичных нулей добавляются к биту данных. После этого данные разбиваются на восьмибитные группы {\displaystyle \lceil b/8\rceil }{\displaystyle \lceil b/8\rceil }, а каждая группа интерпретируется как целое число без знака с обратным порядком байтов 0 ... 255 и сохраняется в октете.

3. Наконец, каждая из r ссылок на ячейки представлена 32 байтами, содержащими 256-битный хеш Hash{\displaystyle (c_{i})}{\displaystyle (c_{i})}, описанного ниже в п. 3.1.5, ячейки {\displaystyle c_{i}}{\displaystyle c_{i}}, на которую есть ссылка.

Таким образом получаем {\displaystyle 2+\lceil b/8\rceil +32r}{\displaystyle 2+\lceil b/8\rceil +32r} байт ячейки {\displaystyle CellRepr(c)}{\displaystyle CellRepr(c)}.

3.1.5. Репрезентативный хеш ячейки
256-битный репрезентативный хеш или просто hash {\displaystyle Hash(c)}{\displaystyle Hash(c)} ячейки c рекурсивно определяется как SHA256 стандартного представления ячейки c:

{\displaystyle Hash(c):=sha256(CellRepr(c))}{\displaystyle Hash(c):=sha256(CellRepr(c))} (2)

Обратите внимание, что циклические ссылки на ячейки недопустимы и не могут быть созданы с помощью TVM (см. 2.3.5), так что данная рекурсия всегда конечна, а репрезентативный хеш любой ячейки четко определен.

3.1.6. Старшие хэши ячейки
Напомним, что ячейка уровня l обладает l старших хешей {\displaystyle Hash_{i}(c),1\leq i\leq l}{\displaystyle Hash_{i}(c),1\leq i\leq l}. У особых ячеек свои правила вычисления старших хешей. Старшие хеши {\displaystyle Hash_{i}(c)}{\displaystyle Hash_{i}(c)} обыкновенной ячейки c вычисляются аналогично ее репрезентативному хешу, но с использованием старшего хеша {\displaystyle Hash_{i}(c_{j})}{\displaystyle Hash_{i}(c_{j})} его дочерних модулей {\displaystyle c_{j}}{\displaystyle c_{j}} вместо репрезентативных хешей {\displaystyle Hash(c_{j})}{\displaystyle Hash(c_{j})}. Условно, мы полагаем, что {\displaystyle Hash_{\infty }(c):=Hash(c)}{\displaystyle Hash_{\infty }(c):=Hash(c)} и {\displaystyle Hash_{i}(c):=Hash_{\infty }(c)=Hash(c)}{\displaystyle Hash_{i}(c):=Hash_{\infty }(c)=Hash(c)} для всех {\displaystyle i>l}{\displaystyle i>l}. (сноска 12)

3.1.7. Виды особых ячеек
TVM в настоящее время поддерживает следующие типы ячеек:

Тип -1: Обыкновенная ячейка - содержит до 1023 бит данных и до 4х ссылок на ячейки.

Тип 1: Отсеченная ячейка ветви c - может иметь любой уровень 1 ≤ {\displaystyle l}{\displaystyle l} ≤ 3. Она содержит ровно 8 + 256 бит данных: сначала 8-битное целое число, равное 1 (представляющий тип ячейки), потом l старших хешей {\displaystyle Hash_{1}(c),\dots ,Hash_{l}(c)}{\displaystyle Hash_{1}(c),\dots ,Hash_{l}(c)} Уровень l отсеченной ячейки можно назвать ее индексом де Брейна, так как он определяет внешнее доказательство Меркла или обновление Меркла, при создании которого ветка была отсечена. Попытка загрузить отсеченную ячейку обычно приводит к ошибке.

Тип 2: ячейка с библиотечной ссылкой - всегда имеет уровень 0 и содержит 8 + 256 бит данных, включая 8-битное целое число 2 и репрезентативный хэш {\displaystyle Hash(c')}{\displaystyle Hash(c')} . При загрузке ячейка с библиотечной ссылкой в библиотечном контексте может быть прозрачно заменена ячейкой, на которую она ссылается.

Тип 3: ячейка доказательства Меркла c - имеет ровно одну ссылку c 1 и уровень 0 ≤ {\displaystyle l}{\displaystyle l} ≤ 3, что должно быть на единицу меньше уровня его единственного дочернего элемента c1:

{\displaystyle Lvl(c)=max(Lvl(c_{1})-1;0)}{\displaystyle Lvl(c)=max(Lvl(c_{1})-1;0)} (3)

8 + 256 битов данных ячейки доказательства Меркла содержат 8-битное целое 3, за которым следует {\displaystyle Hash_{1}(c_{1})}{\displaystyle Hash_{1}(c_{1})} (предполагается, что он равен {\displaystyle Hash(c_{1})}{\displaystyle Hash(c_{1})}, если {\displaystyle Lvl(c_{1})=0}{\displaystyle Lvl(c_{1})=0}). Старшие хеши {\displaystyle Hash_{i}(c)}{\displaystyle Hash_{i}(c)} c вычисляются аналогично старшим хешами обыкновенной ячейки, но с использованием {\displaystyle Hash_{i+1}(c_{1})}{\displaystyle Hash_{i+1}(c_{1})} вместо {\displaystyle Hash_{i}(c_{1})}{\displaystyle Hash_{i}(c_{1})}. При загрузке ячейка доказательства Меркла заменяется на {\displaystyle c_{1}}{\displaystyle c_{1}}.

Тип 4: ячейка обновления Меркла c - имеет два дочерних элемента {\displaystyle c_{1}}{\displaystyle c_{1}} и {\displaystyle c_{2}}{\displaystyle c_{2}}. Ее уровень 0 ≤ l ≤ 3 определяется как

{\displaystyle max(Lvl(c_{1})-1,Lvl(c_{2})-1,0)}{\displaystyle max(Lvl(c_{1})-1,Lvl(c_{2})-1,0)} (4)

Обновление Меркла ведет себя как доказательство Меркла как для {\displaystyle c_{1}}{\displaystyle c_{1}} , так и для {\displaystyle c_{2}}{\displaystyle c_{2}} и содержит 8 + 256 + 256 бит данных с {\displaystyle Hash_{1}(c_{1})}{\displaystyle Hash_{1}(c_{1})} и {\displaystyle Hash_{1}(c_{2})}{\displaystyle Hash_{1}(c_{2})}. Однако, дополнительное требование заключается в том, чтобы все отсеченные ячейки ветви c, которые являются наследниками {\displaystyle c_{2}}{\displaystyle c_{2}} и связаны с ячейкой c, также должны быть наследниками {\displaystyle c_{1}}{\displaystyle c_{1}}. (сноска 13)

При загрузке ячейка обновления Меркла заменяется на {\displaystyle c_{2}}{\displaystyle c_{2}}.

3.1.8. Все значения алгебраических типов данных являются древами ячеек
Произвольные значения произвольных алгебраических типов данных (например, все типы, используемые в функциональных языках программирования) могут быть сериализованы в древа ячеек (уровня 0), такие значения в TVM представлены именно так. Механизм копирования при записи (см. 2.3.2) позволяет TVM идентифицировать ячейки, содержащие те же данные и ссылки, и хранить только одну копию таких ячеек. Таким образом, древо ячеек преобразуется фактически в направленный ациклический граф (дополнительное свойство которого заключается в том, что все его общие точки доступны из отмеченной общей точки, т.н. «корня»). Однако, это скорее оптимизация хранилища, чем существенное отличие TVM. С точки зрения программиста TVM, структуры данных TVM следует рассматривать как древа ячеек.

3.1.9. Код TVM - это древо ячеек
Сам код TVM также представлен древом ячеек. Действительно, код TVM - это просто значение некоторого сложного алгебраического типа данных, поэтому он может быть сериализован в древо ячеек.

Точный способ, с помощью которого код TVM (например, ассемблерный код TVM) преобразовывается в древо ячеек, описан ниже (см. 4.1.4 и 5.2), в разделах, описывающих команды управляющей логики, продолжения и кодировку команд TVM.

3.1.10. Парадигма «Все – неупорядоченная совокупность ячеек»
Согласно описанию в [1, 2.5.14], все данные, используемые в блочейне TON, включая сами блоки и состояние блокчейна, могут быть представлены - и представлены – как совокупности, или «неупорядоченные совокупности» ячеек. Мы видим, что структура данных TVM (см. 3.1.8 ) и код (см. 3.1.9) прекрасно вписываются в парадигму «все – неупорядоченная совокупность ячеек». Таким образом, TVM, естественно, можно использовать для выполнения смарт-контрактов в блокчейне TON, а блокчейн TON может использоваться для хранения кода и базы данных этих смарт-контрактов между инициированием работы TVM. (Конечно, и TVM, и блокчейн TON специально разработаны таким образом, чтобы это стало бы возможным.)

3.2 Команды обработки данных и ячейки
Следующая большая группа команд TVM охватывает команды обработки данных, также известные как просто команды ячеек. Они соответствуют командам доступа к памяти в других архитектурах.

3.2.1. Классы команд обработки данных
Команды обработки данных TVM естественно подразделяются на два основных класса:

• Команды по созданию ячеек, или команды сериализации, которые используются для создания новых ячеек из значений, ранее хранившихся в стеке, и ранее созданных ячеек.

• Команды по парсингу анализу, или команды десериализации, которые используются для извлечения ранее сохраненных данных с помощью команд по созданию ячейки.

Кроме того, существуют особые команды, которые используются для создания и проверки особых ячеек (см . 3.1.2), которые, в частности, используются для обозначения отсеченных ветвей доказательств Меркла и самого доказательства Меркла.

3.2.2. Значения Builder(компоновщик) и Slice(срез)
Команды по созданию ячейки обычно работают со значениями Builder, которые могут храниться только в стеке (см. 1.1.3 ). Такие значения представляют собой частично созданные ячейки, для которых можно определить быстрые операции дополнения битовых строк, целых чисел, других ячеек и ссылок на другие ячейки. Точно так же команды парсинга (синтаксического анализа) ячеек активно используют значения Slice, которые представляют собой либо остаток частично проанализированной ячейки, либо значение (подъячейка), находящуюся внутри такой ячейки и извлеченной из нее в ходе парсинга.

3.2.3. Значения Builder и Slice существуют только как значения стека
Обратите внимание на то, что объекты Builder и Slice отображаются только как значения в стеке TVM. Они не могут храниться в «памяти» (т. е. в древах ячеек) или «постоянном хранилище» (которое также представляет собой неупорядоченнуюю совокупность ячеек). В этом смысле в среде TVM объектов Cell (ячейка) гораздо больше, чем Builder. или Slice, но, как бы это было ни парадоксально, программа TVM видит объекты Builder и Slice в своем стеке чаще, чем объекты Cells. Более того, программа TVM не так и полезна для значений Cell, потому что они неизменны и нечетки; все элементарные действия обработки ячеек требуют, чтобы значение Cell до проверки или внесения изменений сначала преобразовывалось в Builder или Slice.

3.2.4. В TVM нет отдельного типа значения Bitstring
Обратите внимание, что TVM не предлагает отдельного типа значения Bitstring (битовой строки). Вместо этого битовые строки представлены срезами (Slice), которые вообще не имеют ссылок, но могут содержать до 1023 битов данных.

3.2.5. Ячейки и элементарные действия ячеек ориентированы на биты, а не на байты
Важным моментом является то, что TVM рассматривает данные, хранящиеся в ячейках, как последовательности (строки, потоки) (до 1023) бит, а не байтов. Другими словами, TVM является бит-ориентированной, а не байт-ориентированной машиной. При необходимости в приложении могут использоваться, скажем, 21-битные целочисленные поля в записях, сериализованных в ячейки TVM, что позволяет использовать меньшее количество байтов постоянного хранилища для представления одних и тех же данных.

3.2.6. Таксономия элементарных действий создания (сериализации) ячеек.
Элементарные действия по созданию ячеек обычно принимают аргумент Builder и аргумент, представляющий значение, подлежащее сериализации. Дополнительные аргументы, управляющие некоторыми аспектами процесса сериализации (например, сколько битов следует использовать для сериализации) также могут содержаться либо в стеке, либо как непосредственное значение в команде. Результатом элементарного действия по созданию ячейки обычно является другой Builder, представляющий конкатенацию исходного Builder и сериализацию предоставленного значения.

Таким образом, классификацию элементарных действий по сериализации ячеек можно провести на основании ответов на следующие вопросы:

• Каков тип сериализуемых значений?

• Сколько битов используется для сериализации? Если это переменное число, оно из стека или из самой команды?

• Что произойдет, если значение не укладывается в заданное количество битов? Генерируется ошибка или в верхнюю часть стека молча возвращается метка удачного завершения, равная нулю?

• Что произойдет, если в Builder недостаточно места? Генерируется ошибка или возвращается метка удачного завершения, равная нулю, вместе с неизмененных исходным Builder?

Символика элементарных действий по сериализации ячеек обычно начинается с ST. Последующие буквы описывают следующие атрибуты:

• Тип сериализуемых значений и формат сериализации (например, I для целых чисел со знаком, U для целых чисел без знака).

• Источник ширины поля в битах (например, X для команды по сериализации целого означает, что в стеке разрядность n; в противном случае оно должен быть встроено в команду в качестве непосредственного значения).

• Действие, которое необходимо выполнить, если операция не может быть завершена (по умолчанию генерируется ошибка; «Тихие» версии команд сериализации помечены буквой Q в их символике). Данная классификационная схема используется для создания более полной таксономии ячеек и элементарных действий сериализации, которые можно найти в A.7.1.

3.2.7. Элементарные действия целочисленной сериализации
Элементарные действия целочисленной сериализации также могут быть классифицированы в соответствии с приведенной выше таксономией. Например:

• Существуют знаковые и беззнаковые (обратный порядок байтов) целочисленные команды сериализации.

• Размер n используемого битового поля (1 ≤ n ≤ 257 для целых чисел со знаком, 0 ≤ n ≤ 256 для целых чисел без знака) может браться либо сверху стека или быть встроенным в саму команду.

• Если сериализуемое целое число x не находится в диапазоне {\displaystyle -2^{n-1}\leq x<2^{n-1}}{\displaystyle -2^{n-1}\leq x<2^{n-1}}(для сериализации целого числа со знаком) или {\displaystyle 0\leq x<2^{n}}{\displaystyle 0\leq x<2^{n}} (для сериализации целого числа без знака) обычно генерируется ошибка при проверке допустимых значений, и если n-количество бит не может быть сохранено в предоставленном Builder, генерируется ошибка переполнения ячейки

• Тихие версии команд сериализации не генерируют ошибки; вместо этого они проталкивают -1 поверх получившегося Builder в случае успеха, или возвращают исходный Builder с 0, указывая на некий сбой.

Команды по целочисленной сериализации обладают символикой, например, STU 20 («сохранить беззнаковое 20-битное целочисленное значение») или STIXQ («тихое сохранение целочисленного значения переменной длины, представленной в стеке»). Полный список команд — включая их символику, описания и коды операций - приведен в A.7.1.

3.2.8. По умолчанию, целые числа в ячейках имеют обратный порядок битов
Обратите внимание на то, что по умолчанию порядок битов в Integer, сериализованных в Cell, является обратным, а не прямым. (сноска 14) В этом отношении TVM является машиной с обратным порядком битов. Однако, это влияет только на сериализацию целых чисел внутри ячеек. Внутреннее представление значения типа Integer зависит от реализации и не имеет отношения к работе TVM. Кроме того, существуют особые элементарные действия, например, STULE для (де)сериализации целых чисел с прямым порядком битов, которые подлежат сохранению в целом количестве байтов (другими словами, "прямой порядок" не имеет смысла, если только не изменить порядок битов внутри октетов). Такие элементарные действия полезны для взаимодействия с миром прямого порядка - например, для парсинга сообщений нестандартного формата, поступающих в смарт-контракт в блокчейне TON Blockchain из внешнего мира.

3.2.9. Прочие элементарные действия сериализации
Другие прочие элементарные действия создания ячеек осуществляют сериализацию битовых строк (т.е. срезов ячеек без ссылок), взятых из стека или представленных в качестве литеральных аргументов; срезы ячеек (которые связаны с конструктором клеток очевидным образом); другие Builder (которые также соединены); и ссылки на ячейки (STREF).

3.2.10. Прочие элементарные действия по созданию ячеек
В дополнение к элементарным действиям по созданию ячеек для определенных встроенных типов значений, описанных выше, существуют и простые элементарные действия, которые создают новый пустой Builder и помещают его в стек (NEWC) или преобразовывают Builder в ячейку (ENDC), таким образом завершая процесс создания ячейки. ENDC можно объединить с STREF в единую команду ENDCST, которая завершает создание ячейки и сразу сохраняет ссылка на ее во «внешнем» Builder. Существуют элементарные действия, которые получают количество битов данных или ссылок, сохраненных в Builder, и проверяют, сколько битов данных или ссылок можно еще сохранить.

3.2.11. Таксономия элементарных действий по десериализации ячейки
Элементарные действия по парсингу, или десериализации ячеек, могут быть классифицированы согласно описанию в 3.2.6:

• работают со срезами – Slice (представляющими оставшуюся часть ячейки).

• разобран), а не с Builders.

• возвращают десериализованные значения, а не принимают их в качестве аргументов.

• могут быть двух видов, в зависимости от того, удаляют ли они десериализованную часть среза («операции выборки») или оставляют ее без изменений («операции предварительной выборки»).

• символика обычно начинается с LD (или PLD в операциях предварительной выборки), а не ST.

Например, 20-разрядное целое без знака с обратным порядком битов, ранее сериализованное в ячейку с помощью команды STU 20, вероятно, будет десериализовано позже соответствующей командой LDU 20.

Более подробная информация об этих командах содержится в A.7.2.

3.2.12. Прочие элементарные действия среза ячейки
Помимо описанных выше элементарных действий по десериализации ячеек, TVM предоставляет некоторые очевидные элементарные действия для инициализации и завершения процесса десериализации ячейки. Например, можно преобразовать Cell в Slice (CTOS) для запуска десериализации; или проверить, пуст ли Slice, и сгенерировать ошибку, если это не так (ENDS); или десериализовать ссылку на ячейку и немедленно преобразовать ее в Slice (LDREFTOS, аналог двух команд LDREF и CTOS).

3.2.13. Изменение сериализованного значения в ячейке
Читатель может задаться вопросом, как изменить сериализованные в ячейке значения. Предположим, что ячейка содержит три сериализованных 29-битных целых (x, y, z), представляющих координаты точки в пространстве, а мы хотим заменить y на {\displaystyle y'=y+1}{\displaystyle y'=y+1}, оставляя другие координаты без изменений. Как это сделать?

TVM не предлагает никаких способов внесения изменений в существующие значения (см. 2.3.4 и 2.3.5 ), поэтому в нашем примере необходимого результата можно добиться только с помощью следующего порядка действий:

1. Десериализуйте исходную ячейку в три Integer x, y, z в стеке (например, с помощью CTOS; LDI 29; LDI 29; LDI 29; ENDS).

2. Увеличьте y на единицу (например, с помощью SWAP; INC; SWAP).

3. Наконец, сериализуйте полученные Integer в новую ячейку (например, с помощью XCHG s2; NEWC; STI 29; STI 29; STI 29; ENDS).

3.2.14. Изменение постоянного хранилища смарт-контракта
Если код TVM хочет изменить свое постоянное хранилище, представленное древом ячейки с корнем c4, необходимо перезаписать регистр управления c4 на корень древа ячеек, содержащий новое значение своего постоянного хранилища. (Если необходимо изменить только часть постоянного хранилища, см. 3.2.13.)

3.3 Хеш-таблицы или словари
Хэш-таблицы или словари - это определенная структура данных, представленная древом ячеек. По сути, хеш-таблица представляет собой карту из ключей, которые представляют собой битовые строки фиксированной или переменной длины, в значения произвольного типа X, таким образом, чтобы обеспечить возможность быстрого поиска и модификации. Хотя любая подобная структура может быть проверена или изменена с помощью стандартных элементарных действий по сериализации и десериализации ячейки, TVM вводит специальные элементарные действия для облегчения работы с этими хеш-таблицами.

3.3.1. Основные типы хеш-таблиц
Два основных типа хеш-таблиц в TVM – это HashmapE n X, или HashmapE (n, X), который представляет частично определенную карту из n-битных строк (т.н. ключей) для некоторого фиксированного 0 ≤n ≤ 1023 в значения типа X, и Hashmap (n,X), аналогичного HashmapE (n,X), но данный тип не может быть пустым (т. е. он должен содержать хотя бы одну пару "ключ-значение").

Также существуют другие типы хеш-таблиц, например, с ключами произвольной длины до некоторого предопределенного максимума (до 1023 бит).

3.3.2. Хеш-таблицы в виде деревьев Патриции.
Абстрактное представление хеш-таблицы в TVM - это дерево Патриции, или компактное двоичное дерево. Это двоичное древо с ребрами, помеченными битовыми строками так, что конкатенация всех помеченных ребер на пути от корня к листу, равны ключу хеш-таблицы. Соответствующее значение сохраняется в этом листе (для хеш-таблиц с ключами фиксированной длины), или в промежуточных вершинах (для хеш-таблиц с ключами переменной длины), но это необязательно. Кроме того, любая промежуточная вершина должна иметь два дочерних элемента, а метка левого дочернего элемента должна начинаться с двоичного нуля, в то время как метка правого - с двоичной единицы. Таким образом, мы можем явно не хранить первый бит краевых меток.

Легко заметить, что любая совокупность пар ключ-значение (с разными ключами) представлена уникальным древом Патриции.

3.3.3. Сериализация хеш-таблиц
Сериализация хеш-таблицы в древо ячеек (или, в более общем смысле, в Slice) определяется следующей TL-B схемой (сноска 15):

bit#_ _:(## 1) = Bit;

hm_edge#_ {n:#} {X:Type} {l:#} {m:#} label:(HmLabel ~l n)

{n = (~m) + l} node:(HashmapNode m X) = Hashmap n X;

hmn_leaf#_ {X:Type} value:X = HashmapNode 0 X;

hmn_fork#_ {n:#} {X:Type} left:^(Hashmap n X)

right:^(Hashmap n X) = HashmapNode (n + 1) X;

hml_short$0 {m:#} {n:#} len:(Unary ~n)

s:(n * Bit) = HmLabel ~n m;

hml_long$10 {m:#} n:(#<= m) s:(n * Bit) = HmLabel ~n m;

hml_same$11 {m:#} v:Bit n:(#<= m) = HmLabel ~n m;

unary_zero$0 = Unary ~0;

unary_succ$1 {n:#} x:(Unary ~n) = Unary ~(n + 1);

hme_empty$0 {n:#} {X:Type} = HashmapE n X;

hme_root$1 {n:#} {X:Type} root:^(Hashmap n X) = HashmapE n X;

true#_ = True;

_ {n:#} _:(Hashmap n True) = BitstringSet n;

3.3.4. Краткое описание TL-B схем
TL-B схема, как представлена выше, включает следующие компоненты:

Правая часть каждого «уравнения» - это type, простой (например, Bit или True) или параметрический (например, Hashmap n X). Параметрами типа являются натуральные числа (т. е. неотрицательные целые числа, которые на практике должны поместиться в 32 бита), например, n в Hashmap n X, или другие типы, например, X в Hashmap n X.

Левая часть каждого уравнения описывает способ определения или даже сериализации значения типа, указанного в правой части. Такое описание начинается с наименования конструктора, например hm_edge или hml_long, сразу за которым следует необязательный тег конструктора, например #_ или $ 10, который описывает цепочку битов, используемую для кодирования (сериализации) рассматриваемого конструктора. Такие теги могут быть представлены в двоичном (после знака доллара) или шестнадцатеричном виде (после знака решетки), используя соглашения, описанные в 1.0. Если тег не указан явно, TL-B вычисляет 32-разрядный тег конструктора по умолчанию путем хеширования текста «уравнения», определяющего этот конструктор. Следовательно, пустые теги должны явно указываться с помощью #_ или $ _. Все имена конструкторов должны быть разными, а теги конструкторов для одного и того же типадолжен составлять префиксный код (иначе десериализация не будет уникальной).

За конструктором и его необязательным тегом следуют определения полей. Каждое определение поля имеет вид ident: type-expr, где ident – идентификатор с названием поля (сноска 16) (заменено подчеркиванием для анонимных полей), а type-expr - это тип поля. Представленный здесь тип является выражением типа, которые могут включать простые типы или параметризованные типы с подходящими параметрами. Переменные, т. e. (Идентификаторы) ранее определенных полей типов. # (натуральные числа) или Type (тип типа) - могут использоваться в качестве параметров параметризованных типов. Процесс сериализации рекурсивно сериализует каждое поле в соответствии с его типом, а в итоге сериализация значения состоит из конкатенации битовых строк, представляющих конструктор (т. е. тег конструктора) и значения поля.

Некоторые поля могут быть неявными. Их определения обведены фигурными скобками, указывающими на то, что поле фактически не принимает участие в сериализации, но его значение должно быть выведено из других данных (обычно параметров сериализуемого типа).

В некоторых случаях перед «переменной» (т. е. уже определенным полем) стоит префикс - тильда. Это указывает на то, что в данном случае применение переменной противоположно применению по умолчанию: в левой части уравнения - означает, что переменная будет выведена (вычислена) на база данного случая, вместо подстановки ранее вычисленного значения; в правой части, наоборот, - означает, что переменная не будет выведена из сериализуемого типа, а будет вычислена во время процесса десериализации. Другими словами, тильда преобразует «входной аргумент» в «выходной аргумент», и наоборот. (сноска 17)

Наконец, в фигурные скобки можно заключить некоторые равенства. Этим особым «уравнениями» должны удовлетворять «переменные», в них входящие. Если перед одной из переменных стоит тильда, ее значение будет уникально определяться значениями всех других переменных, участвующих в уравнении (которые должно быть известны на данном этапе), когда определение обрабатывается слева направо.

Каретка (ˆ) перед типом X означает, что вместо сериализации значения типа X в виде битовой строки внутри текущей ячейки мы помещаем это значение в отдельную ячейку и добавляем в текущую ячейку ссылку на нее. Следовательно, ˆX означает «тип ссылок на ячейки, содержащие значения типа X».

Параметризованный тип #<= p с p: # (эта запись означает «p типа #», т.е. натуральное число) обозначает подтип типа натуральных чисел #, состоящий из целых чисел 0 ... p; он сериализуется в бит в качестве целого число без знака с обратным порядком битов. Тип # сам по себе сериализуется как беззнаковое 32-битное целое. Параметризованный тип ## b с b: # <= 31 эквивалентен {\displaystyle {\#<=2^{b}-1}}{\displaystyle {\#<=2^{b}-1}} (т. е. Это b-битное целое без знака).

3.3.5. Применение сериализации хеш-таблиц.
Поясним результат применения общих правил, описанных в 3.3. 4 к схеме TL-B, представленной в 3.3.3.

Предположим, нам необходимо сериализовать значение типа HashmapE n X для некоторого целого 0 ≤ n ≤ 1023 и некоторого типа X (например, словарь с n-битными ключами и значениями типа X, допускающие абстрактное представление в виде дерева Патриции).

Прежде всего, если наш словарь пуст, он сериализуется в один двоичный 0, который является тегом нулевого конструктора hme_empty. В противном случае, его сериализация состоит из двоичной единицы (тег hme_root) вместе со ссылкой на ячейку, содержащую сериализацию значения типа Hashmap n X (т. е. словарь не может быть пустым).

Единственный способ сериализовать значение типа Hashmap n X – это hm_edge, который говорит нам сперва сериализовать метку label ребра, ведущего к корню рассматриваемого поддрева (т.е. общий префикс всех ключей в нашем (под) списке команд). Это метка типа HmLabel {\displaystyle l^{\perp }}{\displaystyle l^{\perp }} n, что означает, что данная битная строка длиной не более n сериализована так, что истинная длина l метки, 0 ≤ l ≤ n, становится известной из сериализации метки. (Данный специальный метод сериализации описан в 3.3.6.)

За меткой должна следовать сериализация узла (node) типа Hashmap- Node m X, где m = n - l. Это соответствует вершине дерева Патриции, представляющему непустой подсловарь исходного списка с m-битными ключи, полученными путем удаления общего префикса длины l из всех ключей исходного подсловаря.

Если m = 0, значение типа HashmapNode 0 X задается конструктором hmn_leaf , который описывает лист дерева Патрисии или, что то же самое, подсловарь с 0-битными ключами. Лист состоит из соответствующих значений типа X и сериализуется соответствующим образом.

С другой стороны, если m> 0, значение типа HashmapNode m X соответствует разветвлению (то есть промежуточному узлу) в дереве Патриции и является конструктором hmn_fork. Его сериализация состоит из left и right, двух ссылок на ячейки, содержащие значения типа Hashmap m - 1 X, соответствующие левому и правому дочернему элементу соответствующего промежуточного узла - или, что то же самое, к двум подспискам исходного списка, состоящего из пар ключ-значение, ключи которого начинаются с двоичного 0 или двоичной 1, соответственно. Поскольку первый бит всех ключей в каждом из этих подсловарь известен и не может быть изменен, он подлежит удалению, а полученные (необязательно непустые) подсписки рекурсивно сериализуются как значения типа Hashmap m - 1 X.

3.3.6. Сериализация меток
Существует несколько способов сериализации меток, длиной не более n, если ее точная длина l ≤ n (напомним, что точная длина выводится из сериализации самой метки, а максимальное значение n известно до того, как метка подлежит сериализации иил десериализации). Эти способы описываются тремя конструкторами hml_short, hml_long и hml_same типа HmLabel {\displaystyle l^{\perp }}{\displaystyle l^{\perp }} n:

hml_short – описывает, как провести сериализацию «коротких» меток небольшой длины l ≤ n. Такая сериализация состоит из двоичного 0 (тег конструктора hml_short), за которым следуют l двоичных единиц и один двоичный 0 (унарное представление длины l), за которым следуют l битов, составляющих саму метку.

hml_long – описывает, как провести сериализацию «длинных» меток произвольной длины l ≤ n. Такая сериализация состоит из двоичного числа 10 (тег конструктора hml_long), за которым следует двоичное представление длины 0 ≤ l ≤ n в битов с обратным порядком битов, за которыми следуют l битов, составляющих саму метку.

hml_same – описывает, как провести сериализацию «длинных» меток, состоящих из l повторений одного и того же бита v. Такая сериализация состоит из 11 (тег конструктора hml_same), за которым следует бит v, за которым следует длина l в бит.

Каждую метку всегда сериализовать минимум двумя разными способами, используя hml_short или hml_long конструкторы. Обычно самая короткая сериализация (и в случае ничьей - лексикографически наименьшая среди самых коротких) предпочтительнее и генерируется элементарными действиями хеш-таблицы TVM, в то время как другие варианты по-прежнему считаются работоспособными.

Данная схема кодирования меток разработана таким образом, чтобы быть максимально эффективной для списков со «случайными» ключами (например, хеши некоторых данных), а также для словаря с «обычными» ключами (например, представления целых чисел с обратным порядком битов).

3.3.7. Пример сериализации словаря.
Рассмотрим словарь с тремя 16-битными ключами 13, 17 и 239 (считаются целыми числами с обратным порядком битов) и соответствующие 16-битные значения 169, 289 и 57121.

В двоичном виде:

{\displaystyle 0000000000001101=>0000000010101001}{\displaystyle 0000000000001101=>0000000010101001}

{\displaystyle 0000000000010001=>0000000100100001}{\displaystyle 0000000000010001=>0000000100100001}

{\displaystyle 0000000011101111=>1101111100100001}{\displaystyle 0000000011101111=>1101111100100001}

Соответствующее дерево Патриции состоит из корня A, двух промежуточных узлов B и C и трех листовых узлов D, E и F, равных 13, 17, и 239, соответственно. У корня A только один дочерний элемент, B; метка на ребре AB равна {\displaystyle 00000000=0^{8}}{\displaystyle 00000000=0^{8}}. Узел B имеет два дочерних элемента: левый дочерний элемент промежуточный узел C с ребром BC, помеченный (0) 00, и правый дочерний элемент - это лист F с ребром BF, помеченным (1) 1101111. Наконец, C имеет два дочерних листа D и E, с ребром CD, помеченным (0) 1101, и ребром CE - (1) 0001.

Соответствующее значение типа HashmapE 16 (## 16) может быть записано в удобочитаемой форме как:

(hme_root$1

root:^(hm_edge label:(hml_same$11 v:0 n:8) node:(hm_fork

left:^(hm_edge label:(hml_short$0 len:$110 s:$00)

node:(hm_fork

left:^(hm_edge label:(hml_long$10 n:4 s:$1101)

node:(hm_leaf value:169))

right:^(hm_edge label:(hml_long$10 n:4 s:$0001 ) node:(hm_leaf value:289))))

right:^(hm_edge label:(hml_long$10 n:7 s:$1101111)

node:(hm_leaf value:57121)))))


Сериализация данной структуры данных в древо ячеек состоит из шести ячеек, в которых содержатся следующие двоичные данные:

A := 1

A.0 := 11 0 01000

A.0.0 := 0 110 00

A.0.0.0 := 10 100 1101 0000000010101001

A.0.0.1 := 10 100 0001 0000000100100001

A.0.1 := 10 111 1101111 1101111100100001


Где A - корневая ячейка, A.0 - это ячейка по первой ссылке A, A.1 – это ячейка по второй ссылке A и так далее. Данное древо ячеек может быть представлено более компактно с использованием шестнадцатеричной системы, описанной в 1.0, с помощью отступов для отражения структуры древа ячеек:

C_

C8

62_

A68054C_

A08090C_

BEFDF21


Для сериализации использовано 93 бита данных и 5 ссылок в 6 ячейках. Обратите внимание, что для прямого представления трех 16-битных ключей и соответствующих им 16-битных значений уже потребуется 96 бит (даже без ссылок), поэтому конкретная сериализация оказывается вполне эффективной.

3.3.8. Способы описания сериализации типа X
Обратите внимание, что встроенные элементарные действия TVM для обработки списка должны иметь какую-либо информацию о сериализации типа X; иначе корректная работа с Hashmap n X не была бы возможна, ведь значения типа X напрямую содержатся в ячейках листьев древа Патриции. Существует несколько несколько вариантов описания сериализации типа X:

• Простейший пример - когда X = ˆY для некоторого другого типа Y. В этом случае сама сериализация X всегда состоит из одной ссылки на ячейку, которая должна содержать значение типа Y, что не является актуальным для элементарных действий обработки списка.

• Еще простейший пример - сериализация любого значения типа X всегда состоит из 0 ≤ b ≤ 1023 битов данных и 0 ≤ r ≤ 4 ссылок. Целые b и r могут быть переданы элементарному действию обработки списка в качестве простого описания X. (Обратите внимание, что в предыдущем примере b = 0, r = 1.)

• Более сложный пример можно описать четырьмя целыми числами {\displaystyle 1\leq b_{0},b_{1}\leq 1023,0\leq r_{0},r_{1}\leq 4}{\displaystyle 1\leq b_{0},b_{1}\leq 1023,0\leq r_{0},r_{1}\leq 4}, где {\displaystyle b_{i}}{\displaystyle b_{i}} и {\displaystyle r_{i}}{\displaystyle r_{i}} используются, когда первый бит сериализации равен i. Когда {\displaystyle b_{0}=b_{1}}{\displaystyle b_{0}=b_{1}} и {\displaystyle r_{0}=r_{1}}{\displaystyle r_{0}=r_{1}}, данный пример сводится к предыдущему.

• Наконец, самое общее описание сериализации типа X задается разделяющей функцией split X для X, которая принимает один Slice параметра s и возвращает два Среза, {\displaystyle s'}{\displaystyle s'} и {\displaystyle s''}{\displaystyle s''}, где {\displaystyle s'}{\displaystyle s'} – единственный префикс s, который является сериализацией значения типа X, а {\displaystyle s''}{\displaystyle s''} является остатком s. Если такого префикса не существует, разделяющая функция должна сгенерировать ошибку. Обратите внимание, что компилятор языка высокого уровня, который поддерживает некоторые или все алгебраические типы TL-B, вероятно, автоматически будет генерировать разделяющие функции для всех типов, определенных в программе.

3.3.9. Упрощающее допущение о сериализации X
Можно заметить, что значения типа X всегда занимают оставшуюся часть ячейки hm_edge / hme_leaf в сериализации HashmapE n X. Следовательно, если мы не будем настаивать на строгой проверке всех используемых списков, можно предположить, что все в ячейке hm_edge / hme_leaf af, что не было подвергнуто парсингу после десериализация метки, - это значения типа X. Это значительно упрощает создание элементарных действий обработки списков, так как в большинстве случаев оказывается, что информация о X вообще не требуется.

3.3.10. Основные операции со словарем
Приведем классификацию базовых операций со словарями (т.е. значения D типа HashmapE n X):

• Get (D, k) - для заданного D: HashmapE (n, X) и ключа k: n · бит возвращает соответствующее значение {\displaystyle D[k]:X^{?}}{\displaystyle D[k]:X^{?}} хранится в D.

• Set (D, k, x) – для заданного D: HashmapE (n, X) и ключа k: n · бит и значения x: X, устанавливает {\displaystyle D'[k]}{\displaystyle D'[k]} равным x в копии {\displaystyle D'}{\displaystyle D'} D и возвращает полученный словарь D (см. 2.3.4).

• Add (D, k, x) - аналогично Set, но добавляет пару "ключ-значение" (k, x) к D, если ключ k отсутствует в D.

• Replace (D, k, x) - аналогично Set, но меняет {\displaystyle D'[k]}{\displaystyle D'[k]} на x, только если ключ k уже присутствует в D.

• GetSet, GetAdd, GetReplace - аналогично Set, Add и Replace, соответственно, но также возвращает старое значение D [k].

• Delete (D, k) - удаляет ключ k из словаря D и возвращает получившийся словарь D.

• GetMin (D), GetMax (D) - получает минимальный или максимальный ключ k из словаря D вместе со связанным значением x: X.

• RemoveMin (D), RemoveMax (D) - аналогично GetMin и GetMax, но удаляет соответствующий ключ из словаря D и возвращает измененный словарь D. Может использоваться для перебора всех элементов D, эффективно используя (копию) самого D в качестве итератора.

• GetNext (D, k) - вычисляет минимальный ключ {\displaystyle k'>k}{\displaystyle k'>k} (или {\displaystyle k'\geq k}{\displaystyle k'\geq k}) и возвращает его вместе с соответствующим значением x': X. Может использоваться для перебора всех элементов D.

• GetPrev (D, k) - вычисляет максимальный ключ {\displaystyle k'<k}{\displaystyle k'<k} (или {\displaystyle k'\leq k}{\displaystyle k'\leq k}) и возвращает его вместе с соответствующим значением x': X.

• Empty (n) - создает пустой словарь D: HashmapE (n, X).

• IsEmpty (D) - проверяет, пуст ли словарь.

• Create {\displaystyle (n,\{(k_{i},x_{i})\})}{\displaystyle (n,\{(k_{i},x_{i})\})} - для заданного n, создает словарь из списка {\displaystyle \${(k_{i},x_{i})}}{\displaystyle \${(k_{i},x_{i})}} пар ключ-значение, переданных в стек.

• GetSubdict {\displaystyle (D,l,k_{0})}{\displaystyle (D,l,k_{0})} – при заданном D: HashmapE (n, X) и l-битной строке {\displaystyle k_{0}:l\cdot {bit}}{\displaystyle k_{0}:l\cdot {bit}} для 0 ≤ l ≤ n, возвращает подсловарь {\displaystyle D'=D/k_{0}}{\displaystyle D'=D/k_{0}} из D, состоящий из ключей, начинающихся с {\displaystyle k_{0}}{\displaystyle k_{0}} . Результат {\displaystyle D'}{\displaystyle D'} может быть либо типа HashmapE (n, X), либо HashmapE (n - l, X).

• ReplaceSubdict {\displaystyle (D,l,k_{0},D')}{\displaystyle (D,l,k_{0},D')} – при заданном D: {\displaystyle HashmapE(n,X),0\leq l\leq n,k_{0}:l\cdot {bit}}{\displaystyle HashmapE(n,X),0\leq l\leq n,k_{0}:l\cdot {bit}} и {\displaystyle D':HashmapE(n-l,X)}{\displaystyle D':HashmapE(n-l,X)} заменяется на {\displaystyle D'}{\displaystyle D'} подсловарь {\displaystyle D/k_{0}}{\displaystyle D/k_{0}} от D, состоящий из ключей, начинающихся с {\displaystyle k_{0}}{\displaystyle k_{0}}, и возвращает получившийся словарь {\displaystyle D'':HashmapE(n,X)}{\displaystyle D'':HashmapE(n,X)}. Некоторые варианты ReplaceSubdict также могут возвращать старое значение подсловаря {\displaystyle D/k_{0}}{\displaystyle D/k_{0}}.

• DeleteSubdict {\displaystyle (D,l,k_{0})}{\displaystyle (D,l,k_{0})} - аналог ReplaceSubdict, если {\displaystyle D'}{\displaystyle D'} - пустой словарь.

• Split (D) – при заданном D: HashmapE (n, X), возвращает {\displaystyle D_{0}:=D/0}{\displaystyle D_{0}:=D/0} и {\displaystyle D_{1}:=D/1:HashmapE(n-1,X)}{\displaystyle D_{1}:=D/1:HashmapE(n-1,X)}, два подсловаря D, состоящие из ключей, начинающихся с 0 и 1, соответственно.

• Merge {\displaystyle (D_{0},D_{1})}{\displaystyle (D_{0},D_{1})} - для заданных {\displaystyle D_{0}}{\displaystyle D_{0}} и {\displaystyle D_{1}:HashmapE(n-1,X)}{\displaystyle D_{1}:HashmapE(n-1,X)} вычисляет {\displaystyle D:HashmapE(n,X)}{\displaystyle D:HashmapE(n,X)} так, {\displaystyle D/0=D_{0}}{\displaystyle D/0=D_{0}} и {\displaystyle D/1=D_{1}}{\displaystyle D/1=D_{1}}.

• Foreach (D, f) - выполняет функцию f с двумя аргументами k и x, где (k, x) проверяются все пары ключ-значение словаря D в лексикографическом порядке. (сноска 18)

• ForeachRev (D, f) - аналогично Foreach, но обрабатывает все ключевые пары значений в обратном порядке.

• TreeReduce (D, o, f, g) – при заданном {\displaystyle D:HashmapE(n,X)}{\displaystyle D:HashmapE(n,X)}, значение o: X, и две функции f: X → Y и g: Y × Y → Y, выполняют «редукцию древа» D, сначала применив f ко всем листьям, а затем применив g для вычисления значения, соответствующего разветвлению, начиная со значений, закрепленных за дочерними элементами. (сноска 19)

3.3.11. Таксономия элементарных действий со словарем
Элементарные действия со словарем, подробно описанные в А.10, могут быть классифицированы следующим образом:

• Какие словарные операции (см. 3.3.10 ) они выполняют?

• Специализированы ли они для X = ˆY? Если да, то представляют ли они значения типа Y по ячейкам или по срезам? (Универсальные версии всегда представляют значения типа X как Срезы.)

• Сами словари передаются и возвращаются как ячейки или как срезы? (Большинство элементарных действий представляют словари в качестве срезов.)

• Фиксируется ли длина ключа n в элементарном действии или передается в стек?

• Представлены ли ключи срезами, целыми числами со знаком или без знака?

Кроме того, TVM включает особые элементарные действия сериализации/десериализации, такие как STDICT, LDDICT и PLDDICT, которые могут использоваться для извлечения словаря из сериализации обобщенного объекта или для вставки словаря в такую сериализацию.

3.4 Хеш-таблицы с ключами переменной длины
TVM обеспечивает поддержку словарей или хеш-таблиц с ключами переменной длины, помимо поддержки словарей с ключами фиксированной длины (см. 3.3 выше).

3.4.1. Сериализация словарей с ключами переменной длины
Сериализация VarHashmap в древо ячеек (или, в более общем смысле, в срез) определяется схемой TL-B, описанной в 3.3.3:

vhm_edge#_ {n:#} {X:Type} {l:#} {m:#} label:(HmLabel ~l n)

{n = (~m) + l} node:(VarHashmapNode m X)

= VarHashmap n X;

vhmn_leaf$00 {n:#} {X:Type} value:X = VarHashmapNode n X;

vhmn_fork$01 {n:#} {X:Type} left:^(VarHashmap n X)

right:^(VarHashmap n X) value:(Maybe X)

= VarHashmapNode (n + 1) X;

vhmn_cont$1 {n:#} {X:Type} branch:bit child:^(VarHashmap n X)

nothing$0 {X:Type} = Maybe X;

just$1 {X:Type} value:X = Maybe X;

vhme_empty$0 {n:#} {X:Type} = VarHashmapE n X;

vhme_root$1 {n:#} {X:Type} root:^(VarHashmap n X)

= VarHashmapE n X;

3.4.2. Сериализация префиксных кодов
Один частный случай словаря с ключами переменной длины - это префиксный код, в котором ключи не могут быть префиксами друг друга. Значения в таких словарях могут встречаться только в листьях древа Патриции.

Сериализация префиксного кода определяется следующей схемой TL-B:

phm_edge#_ {n:#} {X:Type} {l:#} {m:#} label:(HmLabel ~l n)

{n = (~m) + l} node:(PfxHashmapNode m X)

= PfxHashmap n X;

phmn_leaf$0 {n:#} {X:Type} value:X = PfxHashmapNode n X;

phmn_fork$1 {n:#} {X:Type} left:^(PfxHashmap n X)

right:^(PfxHashmap n X) = PfxHashmapNode (n + 1) X;

phme_empty$0 {n:#} {X:Type} = PfxHashmapE n X;

phme_root$1 {n:#} {X:Type} root:^(PfxHashmap n X)

= PfxHashmapE n X;

4. Управляющая логика, продолжения и ошибки
В данной главе описаны продолжения, которые могут представлять токены выполнения и обработчики ошибок в TVM. Продолжения глубоко связаны с управляющей логикой программы TVM; в частности, вызовы подпрограмм и условное и итерационное выполнение реализовано в TVM с помощью специальных элементарных действий, которые принимают в качестве аргументов одно или несколько продолжений. Завершим эту главу обсуждением проблемы рекурсии и семейств взаимно рекурсивных функций, усугубляемых тем, что в структурах данных TVM (включая код TVM) циклические ссылки не допускаются.

4.1 Продолжение и подпрограммы
Напомним (см. 1.1.3 ), что значения Continuation представляют собой «токены выполнения», которые могут быть выполнены позже - например, EXECUTE = CALLX («выполнить» или «косвенно вызвать») или JMPX (« косвенный переход») элементарное действие. Таким образом, продолжения отвечают за выполнение программы и активно используются элементарными действиями управляющей логики, реализацией вызовов подпрограмм, условных выражений, циклов и так далее.

4.1.1. Обычные продолжения.
Самый распространенный вид продолжений - обычные продолжения, содержащие следующие данные: • Код среза (см. 1.1.3 и 3.2.2), содержащий (оставшуюся часть) выполняемого кода TVM. • Стек Stack (возможно, пустой), содержащий исходное содержимое стека кода, который подлежит исполнению. • Save список (возможно, пустой) пар {\displaystyle {c}(i),v_{i})}{\displaystyle {c}(i),v_{i})} (т.н. «savelist»), содержащиq значения регистров управления, которые должны быть восстановлены до исполнения кода. • 16-битное целое cp, выбирающее кодовую страницу TVM, используемую для интерпретации кода TVM из кода. • Необязательное неотрицательное целое nargs, указывающее количество аргументов, которые ожидается получить после продолжения.

4.1.2. Простые обычные продолжения.
В большинстве случаев обычные продолжения - самые простые, с пустыми stack и save. Они состоят, по сути, из кода ссылки (оставшейся части) на код, подлежащий исполнению, и кодовой страницы cp, которая будет использоваться при декодировании команд из этого кода.

4.1.3. Текущее продолжение cc.
«Текущее продолжение» сс – наиважнейшая часть общего состояния TVM, представляющая исполняемый в данный момент код (см. 1.1 ). В частности, то, что мы называем «текущий стек» (или просто «стек»), говоря о других элементарных действиях, на самом деле – стек текущего продолжения. Все остальные составляющие общего состояния TVM могут также считаться частью текущего продолжения cc; однако они могут быть извлечены из текущего продолжения и храниться отдельно, как часть общего состояния, из соображений производительности. Вот почему в 1.4мы описываем стек, регистры управления и кодовую страницу, как отдельные части состояния TVM.

4.1.4. Нормальная работа TVM, или основного цикла.
TVM обычно выполняет следующие операции: Если текущее продолжение cc является обычным, оно декодирует первую команду из кода Slice, по аналогии с десериализацией ячеек с помощью TVM LD* (см. 3.2 и 3.2.11): оно декодирует код операции, а затем параметры команды (например, 4-битные поля, определяющие «Регистры стека», которые используются в элементарных действиях обработки стека, или константные значения для «констант проталкивания» или «литеральных» элементарных действий). Остаток среза затем помещается в код нового cc, а декодированная операция выполняется в текущем стеке. Весь этот процесс повторяется до тех пор, пока в cc.code не останется операций. Если код пуст (т. е. не содержит битов данных и ссылок), или если встречается (крайне редкая) четкая команда возврата подпрограммы (RET), текущее продолжение отбрасывается, а «возвратное продолжение» из регистра управления c0 загружается вместо него в cc (данный процесс обсуждается с пункта 4.1.6). (сноска 20) Затем происходит парсинг операций из нового текущего продолжения.

4.1.5. Особые продолжения.
Помимо обычного продолжения, которое мы рассматривали (см . 4.1 .1), TVM включает несколько особых продолжений, представляющие менее распространенные состояния. Приводим несколько примеров особых продолжений: Продолжение ec_quit с нулевым параметром, обозначающее окончание работы TVM. Это продолжение – исходное значение c0, когда TVM начинает выполнение кода смарт-контракта. Продолжение ec_until, которое содержит ссылки на два других продолжения (как обычных, так и особых), представляющие собой тело выполняемого цикла и код, который будет исполнен после цикла. Выполнение особых продолжений TVM зависит от его класса и отличается от операций обычных продолжений, описанных в 4.1.4. (сноска 21)

4.1.6. Переход к другому продолжению:
JMP и RET. Процесс перехода к другому продолжению может осуществляться командами JMPX (берет c из стека) или RET (использует c0 в качестве c). Данный процесс немного сложнее, чем просто заменить значение cc на c: перед началом операции либо все значения, либо первые n значений в текущем стеке перемещаются в стек продолжения c, только после этого остаток текущего стека не учитывается. Если все значения следует переместить (самый частый случай), и если продолжение c имеет пустой стек (также наиболее частый случай; обратите внимание, что изначально предполагается, что особые продолжения имеют пустой стек), то новый стек c равен стеку текущего продолжения, следовательно, мы можем просто полностью перенести текущий стек в стек c. (Если сохраним текущий стек в качестве отдельной части общего состояния TVM, дальнейших действий не предполагается.)

4.1.7. Определение количества n аргументов, переданных следующему продолжению c.
По умолчанию, n равно глубине текущего стека. Однако, если c имеет четкое значение nargs (количество аргументов, которые должны быть предоставлены), тогда n вычисляется как {\displaystyle n'}{\displaystyle n'}, равное c.nargs за вычетом текущей глубины стека с.

Кроме того, особые формы JMPX и RET обеспечивают четкое значение {\displaystyle n''}{\displaystyle n''}, сколько параметров из текущего стека перейдут в продолжение c. Если {\displaystyle n''}{\displaystyle n''} дано, оно должно быть меньше или равно глубине текущего стека, иначе возникнет ошибка исчерпания стека. Если указаны как {\displaystyle n'}{\displaystyle n'}, так и {\displaystyle n''}{\displaystyle n''}, то {\displaystyle n'\leq n''}{\displaystyle n'\leq n''}, этом случае применяется {\displaystyle n=n'}{\displaystyle n=n'}. Если указан {\displaystyle n''}{\displaystyle n''}, а {\displaystyle n'}{\displaystyle n'} - нет, то используется {\displaystyle n=n''}{\displaystyle n=n''}.

Можно представить, что по умолчанию значение {\displaystyle n''}{\displaystyle n''} равно глубине исходного стека, и что {\displaystyle n''}{\displaystyle n''} значений всегда удаляются из вершины исходного стека, даже если только {\displaystyle n'}{\displaystyle n'} из них фактически перемещены в стек следующего продолжения c. Даже если остаток текущего стека впоследствии не принимается во внимание, это описание пригодится позднее.

4.1.8. Восстановление регистров управления из нового продолжения c.
После вычисления нового стека значения регистров управления в c.save восстанавливаются соответственно, а текущая кодовая страница cp также устанавливается на c.cp. Только после этого TVM устанавливает cc равным новому c и начинает свою работу. (сноска 22)

4.1.9. Вызов подпрограмм: элементарные действия CALLX или EXECUTE.
Реализация продолжений в качестве подпрограмм немного сложнее, чем переход к продолжениям.

Рассмотрим элементарные действия CALLX или EXECUTE, которые берет продолжение c из (текущего) стека и исполняет его как подпрограмму. Помимо стековой обработки, описанной в пунктах 4.1.6 и 4.1.7, и установки новых регистров управления и кодовой страницы, описанных в пунктах 4.1.8, данные элементарные действия осуществляют несколько дополнительных шагов:

1. После удаления первых {\displaystyle n''}{\displaystyle n''} значений из текущего стека (см. 4.1.7) (обычно пустой) остаток не отбрасывается, а сохраняется в (старом) текущем продолжении cc.

2. Старое значение особорого регистра c0 сохраняется в (ранее пустом) savelist cc.save.

3. Измененное таким образом продолжение cc не отбрасывается, а становится новым c0, выполняя роль «следующего продолжения» или «возврата продолжения» для вызываемой подпрограммы.

4. Затем, продолжается переход на c. В частности, некоторые регистры управления восстанавливаются из c.save, возможно перезаписывая значение c0, установленное на предыдущем этапе. (Следовательно, правильно было бы удостовериться, что c0 присутствует в c.save с самого начала, и пропустить три предыдущих этапа, как бесполезные.)

Таким образом, вызываемая подпрограмма может вернуть управление вызывающему оператору путем переключения текущего продолжения на продолжение возврата, сохраненного в c0. Вложенные вызовы подпрограмм работают корректно, так как предыдущее значение c0 сохраняется в новый регистр управления c0 savelist c0.save, из которого позже восстанавливается.

4.1.10. Определение количества переданных аргументов и/или возвращаемых значений, принятых от подпрограммы.
По аналогии с JMPX и RET, CALLX также имеет особые (редко используемые) формы, позволяющие явно указывать количество {\displaystyle n''}{\displaystyle n''} аргументов, переданных из текущего стека в вызываемую подпрограмму (по умолчанию {\displaystyle n''}{\displaystyle n''} равно глубине текущего стека в его целостности). Кроме того, можно указать второе число {\displaystyle n'''}{\displaystyle n'''} для установки nargs измененного продолжения cc перед его сохранением в новый c0; новый nargs равен глубине старого стека минус {\displaystyle n''}{\displaystyle n''} плюс {\displaystyle n'''}{\displaystyle n'''}. Это означает, что вызывающий оператор хочет передать ровно {\displaystyle n''}{\displaystyle n''} аргументов подпрограмме и готов принять ровно {\displaystyle n'''}{\displaystyle n'''} результатов.

Такие формы CALLX и RET в основном предназначены для библиотечных функций, принимающих функциональные аргументы. Это необходимо для их безопасного вызова. Еще одно применение связано с «поддержкой виртуализации» TVM, что позволяет одному коду TVM запускать другой код TVM внутри «виртуальной машины TVM». Такие методы виртуализации могут оказаться полезными для реализации сложных платежных каналов в блокчейне TON (см. [1 , 5]).

4.1.11. CALLCC: вызов с текущим продолжением.
Обратите внимание, что TVM поддерживает форму элементарного действия «вызов с текущим продолжением». Элементарное действие CALLCC похоже на CALLX или JMPX: оно принимает продолжение c от стека и переходит на него; однако CALLCC не отбрасывает предыдущее текущее продолжение {\displaystyle c'}{\displaystyle c'} (как JMPX) и не записывает в c0 (как CALLX), а скорее проталкивает {\displaystyle c'}{\displaystyle c'} в (новый) стек в качестве дополнительного аргумента c. Элементарное действие JMPXDATA делает то же самое, но проталкивает только (остаток кода) предыдущего текущего продолжения как Срез.

4.2 Элементарные действия управляющей логики: условное и итерационное исполнение
4.2.1. Условное исполнение:
IF, IFNOT, IFELSE. Условные формы EXECUTE (или CALLXявляются их важной модификацией. Например, IF принимает целое число x и продолжение c и исполняет c ( как EXECUTE), но если x не равно нулю; в противном случае, оба значения просто выбрасываются из стека. Так, IFNOT принимает x и c, но исполняет c, только если x = 0. IFELSE принимает x, c и {\displaystyle c'}{\displaystyle c'}, удаляет их значения из стека и выполняет c, если {\displaystyle x\neq 0}{\displaystyle x\neq 0}, или {\displaystyle c'}{\displaystyle c'}, если {\displaystyle x=0}{\displaystyle x=0}.

4.2.2. Итерационное исполнение и циклы.
Более сложные модификации EXECUTE включают:

• REPEAT - принимает целое число n и продолжение c и исполняет c n раз. (сноска 23)

• WHILE - принимает {\displaystyle c'}{\displaystyle c'} и {\displaystyle c''}{\displaystyle c''}, исполняет {\displaystyle c'}{\displaystyle c'}, а затем берет верхнее значение x из стека. Если x не равен нулю, исполняется , а затем с выполнения {\displaystyle c''}{\displaystyle c''} начинается новый цикл; если x равен нулю, исполнение прекращается.

• UNTIL - берет c, исполняет его, а затем берет верхнее целое число x из стека. Если x равен нулю, начинается новая итерация; если x отличен от нуля, возобновляется ранее выполненный код.

4.2.3. Константные, или литеральные, продолжения.
Мы понимаем, что можем создавать произвольно сложные условные выражения и циклы в коде TVM, при условии, что обладаем средствами размещения константных продолжений в стеке. Фактически, TVM включает особые версии «литеральных» или «константных» элементарных действий, которые отрезают следующие n байтов или битов от оставшейся части текущего кода cc.code в срезе ячейки, а затем проталкивают его в стек не как срез (как PUSHSLICE), а как простое обычное продолжение (которое имеет только code и cp).

Простейшим из этих элементарных действий является PUSHCONT, обладающий текущим аргументом n, описывающим количество последующих байтов (в байтовой версии TVM) или бит, которые подлежат преобразованию в простое продолжение. Другое элементарное действие - PUSHREFCONT, которое удаляет первую ссылку на ячейку из текущего кода продолжения, преобразовывает указанную ячейку в срез, а затем преобразовывает срез в простое продолжение.

4.2.4. Константные продолжения в сочетании с условными или итерационными элементарными действиями исполнения.
Так как константные продолжения зачастую используются в качестве аргументов для элементарных действий условного или итерационного исполнения, объединенные версии этих элементарных действий (например, IFCONT или UNTILREFCONT), возможно, будут определены в будущей версии TVM. Так, PUSHCONT или PUSHREFCONT могут быть объединены с другими элементарными действиями. Если посмотреть на получившийся код, IFCONT очень похож на привычную команду «условного перехода вперед».

4.3 Операции с продолжениями
4.3.1. Продолжения непрозрачны.
Обратите внимание, что все продолжения непрозрачны, по крайней мере, в текущей версии TVM, а это означает, что изменить продолжение или проверить его внутренние данные не представляется возможным. Практически единственное использование продолжения заключается в его передаче элементарному действию управляющей логики. Хотя существуют и аргументы в пользу включения поддержки прозрачных продолжений в TVM (наряду с непрозрачными, которые необходимы для виртуализации), текущая версия не предлагает такой поддержки.

4.3.2. Допустимые операции с продолжениями.
Однако, некоторые операции с непрозрачными продолжениями все еще возможны, в основном потому, что эквивалентны операциям типа «создать новое продолжение, которое сделает что-нибудь особенное, а затем вызовет исходное продолжение». Допустимые операции с продолжениями включают:

• Протолкнуть одно или несколько значений в стек продолжения c (таким образом, создавая частичное применение функции или замыкания).

• Установить сохраненное значение регистра управления c(i) в сейвлисте c.save продолжения c. Если для контрольного регистра уже имеется значение, данная операция пуста.

4.3.3. Пример: операции с регистрами управления.
В TVM есть элементарные действия для установки и проверки значений регистров управления. Самый важный из них является PUSH c(i) (помещает текущее значение c(i) в стек) и POP c(i) (устанавливает значение c(i) из стека, если предоставленное значение правильного типа). Однако сущестует и модифицированная версия последней команды - POPSAVE c(i), которая перед установкой нового значения сохраняет старое значение c(i) (для i > 0) в продолжение в c0, согласно описанию в 4.3.2.

4.3.4. Пример: настройка количества аргументов функции в коде.
Элементарное действие LEAVEARGS n – еще одно применение продолжений в операции: оно оставляет только верхние n значений текущего стека, а остаток перемещает в стек продолжения в c0. Это элементарное действие позволяет вызываемой функции «возвращать» ненужные аргументы в стек вызывающего оператора, что может иногда пригодиться (например, в Обработке ошибок).

4.3.5. Булевы схемы.
Продолжение c можно рассматривать в качестве части кода с двумя дополнительными точками выхода, хранящимися в сейвлисте c: основной точкой выхода, заданной c.c0: = c.save (c0), и дополнительной точкой выхода, заданной c.c1: = c.save (c1). Если условие выполнено, продолжение исполняет любое действие, для выполнения которого оно было создано, а затем (обычно) передает управление основной точке выхода или, в некоторых случаях, дополнительной точке выхода. Можно сказать, что продолжение c с двумя определенными точками выхода c.c0 и c.c1 является булевой схемой, особенно если выбор точки выхода зависит от некоторого внутреннего условия.

4.3.6. Формирование продолжений.
Можно сформировать два продолжения c и {\displaystyle c'}{\displaystyle c'}, установив c.c0 или c.c1 на c. Это новое продолжение обозначается {\displaystyle c\circ _{0}c'}{\displaystyle c\circ _{0}c'} или {\displaystyle c\circ _{1}c'}{\displaystyle c\circ _{1}c'}, которое отличается от c своим сейвелистом. (Напомним, что если в сейвлисте c уже есть запись, соответствующая данному контрольному регистру, такая операция является пустой и «тихо», см. 4.3.2).

Формирование продолжений позволяет создавать цепи или другие графы, возможно, циклические, представляющие логику управления. Фактически, такой граф напоминает блок-схему с булевыми схемами, соответствующими «условным узлам (нодам)» (в них содержится код, передающий управление либо c0, либо c1 в зависимости от некоторого условия), и одновыходные продолжения, соответствующие к «узлам операции».

4.3.7. Базовые элементарные действия формирования продолжений.
Два основных базовых действия для формирования продолжений - это COMPOS (также известный как SETCONT c0 и BOOLAND) и COMPOSALT (также известный как SETCONT c1 и BOOLOR), которые берут {\displaystyle c}{\displaystyle c} и {\displaystyle c'}{\displaystyle c'} из стека, устанавливают c.c0 или c.c1 на {\displaystyle c'}{\displaystyle c'} и возвращают продолжение {\displaystyle c''=c\circ _{0}c'}{\displaystyle c''=c\circ _{0}c'} или {\displaystyle c\circ _{1}c'}{\displaystyle c\circ _{1}c'}. Все остальные базовые элементарные действия по формированию продолжений могут быть выражены в терминах этих двух примитивов.

4.3.8. Продвинутые элементарные действия формирования продолжений.
Однако, в TVM возможно формирование продолжений, не только взятых из стека, но и взятых из c0 или c1, или из текущего продолжения cc; по аналогии, результат может быть помещен в стек, сохранен в c0 или c1 или может использоваться в качестве нового текущего продолжения (т. е. ему может быть передано управление). Кроме того, TVM может определять элементарные действия условного формирования, выполняющие некоторые из вышеперечисленных действий, только если целочисленное значение, взятое из стека, не равно нулю.

Например, EXECUTE можно описать как {\displaystyle {cc}\leftarrow c\circ _{0}{cc}}{\displaystyle {cc}\leftarrow c\circ _{0}{cc}} с продолжением c из исходного стека. Аналогично, JMPX - это cc ← c, а RET (также известное как RETTRUE в контексте булевой схемы) - это cc ← c0. Прочие интересные элементарные действия включают THENRET ({\displaystyle c'\leftarrow c\circ _{0}{c0}}{\displaystyle c'\leftarrow c\circ _{0}{c0}}) и ATEXIT ({\displaystyle {c0}\leftarrow c\circ _{0}{c0}}{\displaystyle {c0}\leftarrow c\circ _{0}{c0}}).

Наконец, некоторые «экспериментальные» элементарные действия также включают с1 и {\displaystyle \circ _{1}}{\displaystyle \circ _{1}}. Например:

• RETALT или RETFALSE выполняет cc ← c1.

• Также могут пригодиться условные версии RET и RETALT: RETBOOL берет целое число x из стека и выполняет RETTRUE, если {\displaystyle x\neq 0}{\displaystyle x\neq 0}, иначе выполняется RETFALSE.

• INVERT выполняет c0 ↔ c1; если два продолжения в c0 и c1 представляют две ветви, которые мы должны выбрать в зависимости от некоторого булева выражения, INVERT инвертирует данное выражение на внешнем уровне.

• INVERTCONT выполняет c.c0 ↔ c.c1 для продолжения c, взятого из стека.

• Варианты ATEXIT: ATEXITALT ({\displaystyle {c1}\leftarrow c\circ _{1}{c1}}{\displaystyle {c1}\leftarrow c\circ _{1}{c1}}) и SETEXITALT ({\displaystyle {c1}\leftarrow (c\circ _{0}{c0})\circ _{1}{c1}}{\displaystyle {c1}\leftarrow (c\circ _{0}{c0})\circ _{1}{c1}}).

• BOOLEVAL берет продолжение c из стека и {\displaystyle {cc}\leftarrow {\bigl (}(c\circ _{0}({PUSH-1}))\circ _{1}({PUSH0}){\bigr )}\circ _{0}{cc}}{\displaystyle {cc}\leftarrow {\bigl (}(c\circ _{0}({PUSH-1}))\circ _{1}({PUSH0}){\bigr )}\circ _{0}{cc}}. Если c – это булева схема, результирующее влияние заключается в том, чтобы оценить его и, прежде чем продолжить, поместить в стек либо −1, либо 0.

4.4 Продолжения как объекты
4.4.1. Представление объектов с помощью продолжений.
Объектно-ориентированное программирование в стиле Smalltalk (или Objective C) может быть реализовано с помощью продолжений. В этих целях объект представляется в продолжения о. При наличии, поля данных можно сохранить в стеке o, так, о становится частичным применением (т. е. продолжением с непустым стеком).

Если возникает необходимость вызвать метод m из o с аргументами {\displaystyle x_{1},x_{2},\dots ,x_{n}}{\displaystyle x_{1},x_{2},\dots ,x_{n}}, аргументы помещаются в стек, а затем в стек помещается магическое число, соответствующее методу m, а затем выполняется о с помощью передачи n + 1 аргументов (см. 4.1.10 ). Затем o использует целое m из вершины стека, чтобы выбрать ветвь с требуемым методом, и выполняет его. Если o требуется изменить свое состояние, оно просто вычисляет новое продолжение {\displaystyle o'}{\displaystyle o'} того же типа (возможно, с тем же кодом, но с другим исходным стеком). Новое продолжение {\displaystyle o'}{\displaystyle o'} возвращается вызывающему оператору вместе с любыми другими возвращаемыми значениями.

4.4.2. Сериализуемые объекты.
Другой способ представления объектов в стиле Smalltalk в качестве продолжений, или даже как древ ячеек, заключается в применении элементарного действия JMPREFDATA (вариант JMPXDATA, см. 4.1.11), принимающего ссылку на первую ячейку из кода текущего продолжения, преобразующего данную ячейку в простое продолжение и передающего ей управление, сперва проталкивая остаток текущего продолжения как Срез в стек. Таким образом, объект может быть представлен ячейкой {\displaystyle {\tilde {o}}}{\displaystyle {\tilde {o}}}, содержащей JMPREFDATA в начале своих данных и фактический код объекта в первой ссылке (можно сказать, что первая ссылка ячейки {\displaystyle {\tilde {o}}}{\displaystyle {\tilde {o}}} – это класс объекта {\displaystyle {\tilde {o}}}{\displaystyle {\tilde {o}}}). Остальные данные и ссылки этой ячейки будут использоваться для хранения полей объекта.

Такие объекты являются древами ячеек, а не просто продолжениями, что означает, что они могут сохраниться в постоянном хранилище смарт-контракт TON. В этом заключается их преимущество.

4.4.3. Уникальные продолжения и возможности.
Возможно, (в будущих версиях TVM) логично выделить некоторые продолжения как уникальные, которые невозможно скопировать даже отложенно. Это достигается путем увеличения их счетчика ссылок на значение, превышающее единицу. Если непрозрачное продолжение уникально, он по сути становится возможностью, которую может использовать ее владелец ровно один раз или передать другому лицу.

Например, представьте продолжение, которое представляет выходной поток для принтера (это пример продолжения, используемого в качестве объект, см. 4.4.1). При вызове с одним целочисленным аргументом n данное продолжение выводит символ с кодом n на принтер и возвращает новое такое же продолжение, отражающее новое состояние потока. Очевидно, копирование такого продолжения и параллельное использование двух копий привело бы к некоторым побочным эффектам; но если отметить данное продолжение как уникальное, то подобных неблагоприятных применений можно было бы избежать.

4.5 Обработка ошибок
Обработка ошибок в TVM довольно проста и заключается в передаче управления к продолжению, хранящемуся в регистре управления c2.

4.5.1. Два аргумента обработчика ошибок: параметр ошибки и номер ошибки.
Каждая ошибка характеризуется двумя аргументами: номер ошибки (целое число) и параметр ошибки (любое значение, чаще всего нулевое целое). Номера ошибок 0–31 зарезервированы для TVM, а остальные номера доступны для определяемых пользователем ошибок.

4.5.2. Элементарные действия генерации ошибок.
Существует несколько особых элементарных действий, используемых для генерации ошибок. Самое общее их них - THROWANY берет из стека два аргумента, v и {\displaystyle 0\leq n<2^{16}}{\displaystyle 0\leq n<2^{16}}, и выдает ошибку с номером n и значением v. В других вариантах данного элементарного действия предполагается, что v является нулевым целым, n сохранятся как литеральное значение, и/или являются условными от целочисленного значения, взятого из стека. Определяемые пользователем ошибки могут, при необходимости, применять произвольные значения в качестве v (например, древа ячеек).

4.5.3. Ошибки, генерируемые TVM.
Конечно, некоторые ошибки генерируются обычными элементарными действиями. Например, ошибка арифметического переполнения генерируется всякий раз, когда результат арифметической операции не помещается в 257-битное целое со знаком. В таких случаях аргументы ошибки, v и n, определяются TVM.

4.5.4. Обработка ошибок.
Обработка ошибок заключается в передаче управления обработчику ошибок - то есть продолжению, указанному в регистре управления c2, где v и n указаны в качестве двух аргументов данного продолжение, как если бы JMP для c2 был запрашивался с n" = 2 аргументами (см. 4.1.7 и 4.1.6). Как следствие, v и n оказываются в верхней части стека обработчика ошибок. Остаток старого стека отбрасывается.

Обратите внимание, что, если продолжение в c2 имеет ценность для c2 в своем сейвлисте, оно будет использоваться для установки нового значения c2 перед выполнением обработчика ошибок. В частности, если обработчик ошибок вызывает THROWANY, он повторно сгенерирует исходную ошибку с восстановленным значением c2. Так, обработчик ошибок обрабатывает только некоторые ошибки, передавая остальные внешнему обработчику ошибок.

4.5.5. Обработчик ошибок по умолчанию.
При создании варианты TVM, c2 содержит ссылку на «продолжение обработчика ошибок по умолчанию», которое является особым продолжением ec_fatal (см. 4.1.5). Его исполнение приводит к прекращению исполнения TVM, а аргументы v и n возвращаются внешнему вызывающему оператору. В контексте блокчейна TON n будет храниться как часть результата транзакции.

4.5.6. Элементарное действие TRY.
Элементарное действие TRY может использоваться для реализации обработки исключений по аналогии C ++. Данное элементарное действие допускает два продолжения, c и {\displaystyle c'}{\displaystyle c'}. Оно сохраняет старое значение c2 в сейвлисте , устанавливает c2 в {\displaystyle c'}{\displaystyle c'}, а затем исполняет c по аналогии с EXECUTE, но сохраняя старое значение c2 в сейвлисте нового c0. Обычно используется версия элементарного действия TRY с явным количеством аргументов {\displaystyle n''}{\displaystyle n''}, переданных в продолжение c.

Итоговый результат примерно соответствует оператору try { c } catch(...){ c' } на языке C++.

4.5.7. Список предопределенных ошибок.
Предопределенные ошибки TVM соответствуют номерам ошибок n в диапазоне 0–3 и включают:

• Нормальное завершение (n = 0) - не должно никогда генерироваться, но порой бывает полезно.

• Альтернативное завершение (n = 1) – снова, не должно никогда генерироваться.

• Исчерпание стека (n = 2) - недостаточно аргументов в стеке для выполнения элементарного действия.

• Переполнение стека (n = 3) - в стеке сохранено больше значений, чем разрешено этой версией TVM.

• Переполнение целочисленного значения (n = 4) - целое число не укладывается в {\displaystyle -2^{256}\leq x<2^{256}}{\displaystyle -2^{256}\leq x<2^{256}}, или произошло деление на ноль.

• Ошибка проверки диапазона (n = 5) - целое находится вне предполагаемого диапазона.

• Недействительный код операции (n = 6) – невозможно декодировать команду или ее аргументы.

• Ошибка проверки типа (n = 7) – неверный тип значения аргумента элементарного действия.

• Переполнение ячейки (n = 8) - ошибка в одном из элементарных действий сериализации.

• Исчерпание ячейки (n = 9) - ошибка десериализации.

• Ошибка словаря (n = 10) - Ошибка при десериализации словарного объекта.

• Неизвестная ошибка (n = 11) - неизвестная ошибка может генерироваться пользовательскими программами.

• Неустранимая ошибка (n = 12) - выдается TVM в ситуациях, считающихся невозможными.

• Out of gas (n = 13) - генерируется TVM, когда остаток газа ({\displaystyle g_{r}}{\displaystyle g_{r}}) становится отрицательным. Обычно это трудноуловимая ошибка и приводит к немедленному завершению ТВМ.

У большинства этих ошибок нет параметров (Вместо них используется нулевое целое число). Порядок обработки данных ошибок указан ниже в 4.5.8.

4.5.8. Порядок обработки ошибок исчерпания стека, проверки типа и проверки диапазона.
Все элементарные действия TVM сначала проверяют, содержит ли стек необходимое количество аргументов, генерируя ошибку исчерпания стека, необходимого количества аргументов не обнаружено. Только после этого осуществляется проверка тегов типов аргументов и их диапазонов (например, если элементарное действие предполагает, что аргумент будет не только целым, но и в диапазоне от 0 до 256), начиная со значения на вершине стека (последний аргумент) и продвигаясь глубже в стек. Если неверен тип аргумента, генерируется ошибка проверки типа; если тип правильный, но значение не попадает в необходимый диапазон, диапазон генерируется ошибка проверки диапазона.

Некоторые элементарные действия принимают переменное количество аргументов в зависимости от значения некоторого небольшого фиксированного подмножества аргументов, расположенных в верхней части стека. В этом случае в вышеуказанном порядке сперва проверяются аргументы этого небольшого подмножества, а уже затем остальные аргументы после определения их количества и типов на основании обработанных аргументов.

4.6 Функции, рекурсия и словари
4.6.1. Проблема рекурсии.
Условные и итерационные элементарные действия, описанные в 4.2, а также элементарные действия безусловного перехода, вызова и возврата, описанные в 4.1, позволяют реализовать более или менее произвольный код с вложенными циклами и условными выражениями, с одним важным исключением: возможно создать только новые постоянные продолжения из частей текущего продолжения. (В частности, нельзя вызвать подпрограмму от самой себя.) Следовательно, выполняемый код - т. е. текущее продолжение - постепенно становится все меньше и меньше.

4.6.2. Решение Y -комбинатор: передать продолжение как собственный аргумент.
Один из способов решения проблемы рекурсии – передать копию продолжения, представляющего тело (body) рекурсивной функции как собственный дополнительный аргумент. Рассмотрим, например, следующий код для факториальной функции:

71 PUSHINT 1

9C PUSHCONT {

22 PUSH s2

72 PUSHINT 2

B9 LESS

DC IFRET

59 ROTREV

21 PUSH s1

A8 MUL

01 SWAP

A5 DEC

02 XCHG s2

20 DUP

D9 JMPX

}

20 DUP

D8 EXECUTE

30 DROP

31 NIP

Что грубо соответствует определению вспомогательной функции body тремя аргументами n, x и f, так, что body (n, x, f) равно x, если n < 2, иначе - f (n -1, nx, f), затем осуществляется вызов body (n, 1, body) для вычисления факториала n. Затем осуществляется рекурсия с помощью конструкции DUP; EXECUTE, или DUP; JMPX в случае хвостовой рекурсии. Это аналогично применению У комбинатора к телу функции.

4.6.3. Вариант решения Y -комбинатор.
Другой способ рекурсивного вычисления факториала, более точно следуя классическому рекурсивному определению

425x65


приведен ниже:

9D PUSHCONT {

21 OVER

C102 LESSINT 2

92 PUSHCONT {

5B 2DROP

71 PUSHINT 1

}

E0 IFJMP

21 OVER

A5 DEC 01 SWAP

20 DUP

D8 EXECUTE

A8 MUL

}

20 DUP

D9 JMPX

Данное определение факториальной функции на два байта короче предыдущего, но используется общая, а не хвостовая, поэтому трансформировать его в цикл не так просто.

4.6.4. Сравнение: нерекурсивное определение факториальной функции.
Как оказалось, также возможно нерекурсивное определение факториала с помощью цикл REPEAT. Данный метод намного короче двух предыдущих.

71 PUSHINT 1

01 SWAP

20 DUP

94 PUSHCONT {

66 TUCK

A8 MUL

01 SWAP

A5 DEC

}

E4 REPEAT

30 DROP

4.6.5. Некоторые взаимно рекурсивные функции.
Если у нас дана подборка {\displaystyle f_{1},\dots ,f_{n}}{\displaystyle f_{1},\dots ,f_{n}} взаимно рекурсивных функций, можно использовать тот же метод передачи всей подборки продолжений {\displaystyle \{f_{i}\}}{\displaystyle \{f_{i}\}} в стек в качестве дополнительного n аргумента каждой из этих функций. Однако, по мере роста n, это сделать все сложнее, так как нужно переупорядочивать эти дополнительные аргументы в стеке для работы с «истинными» аргументами, а затем протолкнуть их копии в верхнюю часть стека перед любым рекурсивным вызовом.

4.6.6. Объединение нескольких функций в один кортеж.
Можно объединить подборку продолжений, представляющих функции {\displaystyle f_{1},\dots ,f_{n}}{\displaystyle f_{1},\dots ,f_{n}} в «кортеж» {\displaystyle {\mathbf {f} }:=(f_{1},\ldots ,f_{n})}{\displaystyle {\mathbf {f} }:=(f_{1},\ldots ,f_{n})} и передать этот кортеж как один элемент стека f. Например, когда n ≤ 4, каждая функция может быть представлена ячейкой {\displaystyle {\tilde {f}}_{i}}{\displaystyle {\tilde {f}}_{i}} (а также древом ячеек этой ячейки), а кортеж может быть представлен как ячейка {\displaystyle {\tilde {\mathbf {f} }}}{\displaystyle {\tilde {\mathbf {f} }}} со ссылками на составляющие ячейки . Однако, это привести к необходимости «распаковывать» нужный компонент из этого кортежа перед каждым рекурсивным вызовом.

4.6.7. Объединение нескольких функций в функцию-селектор.
Иной подход заключается в объединении нескольких функций {\displaystyle f_{1},\dots ,f_{n}}{\displaystyle f_{1},\dots ,f_{n}} в одну «функцию-селектор», которая берет дополнительный аргумент i, 1 ≤ i ≤ n, с вершины стека и вызывает соответствующую функцию {\displaystyle f_{i}}{\displaystyle f_{i}}. Такой метод отлично подходит для стековых машин, включая TVM, так как функции {\displaystyle f_{i}}{\displaystyle f_{i}} не должны иметь одинаковое количество и типы аргументов. В рамках этого подхода необходимо передать только один дополнительный аргумент, f, каждой из этих функций, и протолкнуть в стек дополнительный аргумент i перед каждым рекурсивным вызовом f для выбора правильной функции вызова.

4.6.8. Использование специального регистра для сохранения функции-селектора.
Однако, даже если мы используем один из двух предыдущих подходов для объединения всех функций в один дополнительный аргумент, передача этого аргумента всем взаимно рекурсивным функциям по-прежнему довольно сложно и требует большого количества дополнительных действий по обработке стека. Поскольку данный аргумент меняется крайне редко, возможно использование специального регистра для его хранения и прозрачной передачи всем функциям. В TVM по умолчанию используется данный подход.

4.6.9. Специальный регистр c3 для функции-селектора.
Фактически TVM использует выделенный регистр c3 для сохранения продолжения, представляющего текущую или глобальную «функцию-селектор», которая может использоваться для вызова любой функции из семейства взаимно рекурсивных функций. Особые элементарные действия CALL nn или CALLDICT nn (см. A.8.7 ) эквивалентны PUSHINT nn; PUSH c3; EXECUTE, а JMP nn или JMPDICT nn эквивалентны PUSHINT nn; PUSH c3; JMPX. Таким образом программа TVM, которая в конечном итоге представляет собой большой набор взаимно рекурсивных функций, может инициализировать c3 с помощью правильной функции-селектора, представляющую семейство всех функций в программе, а затем с помощью CALL nn осуществляется вызов любой из этих функций по ее индексу (т.н. селектор функции).

4.6.10. Инициализация c3.
Программа TVM может инициализировать c3 с помощью команды POP c3. Однако, поскольку это обычно это самое первое действие программы (например, смарт-контракта), TVM предусматривает автоматическую инициализацию c3. А именно, c3 инициализируется кодом (исходное значение cc) самой программы, а в стек программы перед запуском добавляется дополнительный ноль (иногда иное предопределенное число s). Можно провести аналогию с JMPDICT 0 (или JMPDICT s) в самом начале программы, т.е. функция с нулевым индексом фактически является функцией main () программы. (сноска 24)

4.6.11. Создание функций-селекторов и операторов переключения.
TVM обеспечивает простую и лаконичную реализацию функций-селекторов (которые обычно составляют верхний уровень программы TVM), в более широком смысле, произвольные операторы switch или case (которые также применимы в TVM программах). Для этих целей используются следующие элементарные действия: IFBITJMP, IFNBITJMP, IFBITJMPREF и IFNBITJMPREF (см. A.8.2 ). Oни эффективно позволяют комбинировать подпрограммы, хранящиеся либо в отдельных ячейках, либо в виде Срезов определенных ячеек в двоичном дереве решений с принятыми решениями в соответствии с указанными битами целого числа, переданного в верхнюю часть стека. Еще одна полезная для реализации типов сумм-произведений, это PLDUZ (см. A.7.2). Данная команда предварительно загружает несколько первых битов среза в целое, которое позже может быть проверено командой IFBITJMP и другими подобными командами.

4.6.12. Альтернатива: использование хеш-таблицы для выбора правильной функции.
Существует и альтернативный метод - использовать хеш-таблицы (см. 3.3 ) для хранения «подборки» или «словаря» кодов всех функций программы и использовать элементарные действия поиска хеш-таблицы (см. А.10) для выбора кода требуемой функции, которая с помощью команды BLESS становится продолжением (см. А.8.5 ) и подлежит исполнению. Существуют особые комбинированные команды «найти, «благословить» и выполнить», например, DICTIGETJMP и DICTIGETEXEC (см . A.10.11 ). Этот метод, возможно, более эффективен для объемных программ и операторов переключения.

5 Кодовые страницы и кодировка команд
В этой главе описывается механизм кодовых страниц, благодаря котором TVM становится гибкой и растяжимой, сохраняя при этом обратную совместимость с ранее созданным кодом.

Мы также затронем некоторые общие соображения по поводу кодировки команд, (относительно произвольного машинного кода, а не только кода TVM), а также объясним важность этих соображений для TVM. Мы расскажем о выборе, который нам пришлось сделать при проектировании нулевой(экспериментальной) кодовой страницы TVM. А кодировка команд представлены ниже в Приложении А.

5.1 Кодовые страницы и взаимодействие различных версий TVM
Кодовые страницы являются важным механизмом обратной совместимости и будущих расширений TVM. Они обеспечивают прозрачное исполнение кода, написанного для разных версий TVM, а также прозрачное взаимодействие между примерами такого кода. Однако, механизм кодовых страниц является общим и достаточно мощным для обеспечения некоторых применений, которые изначально не планировались.

5.1.1. Кодовые страницы в продолжениях.
Каждое обычное продолжение содержит 16-битное поле кодовой страницы cp (см. 4.1.1 ), определяющую кодовую страницу, которая будет использоваться для выполнения своего кода. Если продолжение создается PUSHCONT (см. 4.2.3 ) или аналогичным элементарным действием, оно обычно наследует текущую кодовую страницу (т.е. кодовую страницу cc). (сноска 25)

5.1.2. Текущая кодовая страница. Текущая кодовая страница cp (см. 1.4) - это кодовая страница текущего продолжения cc. Она определяет, как именно следующая команда будет декодироваться из cc.code, оставшейся части текущей кода текущего продолжения. После того, как команда декодирована и выполнена, она определяет следующее значение текущей кодовой страницы. В большинстве случаев код текущей кодовой страницы не меняется.

С другой стороны, все элементарные действия, переключающих текущее продолжение, загружают новое значение cp из нового текущего продолжения. Таким образом, весь код в продолжениях всегда интерпретируется точно так, как и предполагалось.

5.1.3. В разных версиях TVM могут использоваться разные кодовые страницы.
В разных версиях TVM могут использоваться разные кодовые страницы для своего кода. Например, исходная версия TVM может использовать нулевую кодовую страницу. Более новая версия может использовать первую кодовую страницу, которая содержит все ранее определенные коды операций, наряду с некоторыми недавно определенными, которые используют ранее неиспользуемое пространство кода операции. В следующей версии может использоваться еще одна кодовая страница, и так далее. Однако более новая версия TVM будет выполнять старый код для нулевой кодовой страницы точно так же, как и раньше. Если старый код содержал код операции, используемый для новых операции, которые не были определены в исходной версии TVM, все равно будет генерироваться ошибка недопустимого кода операции, так как новые операции отсутствуют в нулевой кодовой странице.

5.1.4. Изменение поведения старых операций.
Новые кодовые страницы могут также изменить действие некоторых операций, присутствующих в старых кодовых страницах, сохраняя их коды операций и символику. Например, представьте себе будущее 513-битное обновление TVM (которое заменит текущее 257-битное). В его рамках возможно применение 513-битного типа с прежними арифметическими элементарными действиями. Однако, хотя коды операций и команды в новой кодовой странице будут выглядеть точно так же, как старые, они будут работать иначе, принимая 513-битные целые аргументы и результаты. С другой стороны, во время исполнения того же кода с нулевой кодовой страницей будет генерироваться ошибка всякий раз, когда целые числа, используемые в арифметических и прочих элементарных действиях, не умещаются в 257 бит. (сноска 26) Таким образом, обновление не изменяет поведение старого кода.

5.1.5. Улучшение кодировки команд.
Еще одно применение кодовых страниц заключается в изменении кодировки команд, отражая усовершенствованное знание относительно фактической частоты таких команд в базе кода. В таком случае, новая кодовая страница будет иметь те же команды, что и старая, но с разными кодировками, потенциально разной длины. Например, можно создать экспериментальную версию первой версии TVM, используя (префиксный) битовый код вместо исходного байт-кода для достижения более высокой плотности кода.

5.1.6. Зависимая от контекста кодировка команд.
Другой способ использования кодовых страниц для повышения плотности кода - это использование нескольких кодовых страниц с различными подмножествами всего набора команд, определенных в каждом из них, или со всем набором определенных команд, но с разными кодировками длины для одних и тех же команд в разных кодовых страницах.

Представьте, например, кодовую страницу «стековой обработки», в которой элементарные действия стековой обработки имеют короткие кодировки за счет всех других операций, и кодовая страница «обработки данных», в которой все операции короче за счет операций стековой обработки. Если операции стековой обработки, как правило, следуют одна за другой, мы можем автоматически переключиться на кодовую страницу «стековой обработки» после выполнения любой такой команды. При появлении команды по обработке данных мы снова переключаемся на кодовую страницу «обработки данных». Если условные вероятности класса следующей команды в зависимости от класса предыдущей команды значительно отличаются от соответствующих безусловных вероятностей, этот метод – автоматически переключиться в режим стековой обработки для переупорядочивания стека с применением более коротких команд, а затем переключиться обратно - может значительно увеличить плотность кода.

5.1.7. Использование кодовых страниц для флажков состояния и управления.
Еще одно возможное применение нескольких кодовых страниц в одной и той же версии TVM состоит в переключение между несколькими кодовыми страницами в зависимости от результата выполнения некоторых команд.

Например, представьте версию TVM, в которой используются две новые кодовые страницы, 2 и 3. Большинство операций не вносят изменений в текущую кодовую страницу. Однако, операции целочисленного сравнения переключатся на кодовую страницу 2, если условие ложно, и на кодовую страницу 3, если условие верно. Кроме того, новая операция ?EXECUTE, аналогичная EXECUTE, действительно будет эквивалентна EXECUTE на кодовой странице 3, но на кодовой странице 3 станет DROP. В рамках такого подхода эффективно используется бит 0 из текущей кодовой странице в качестве флажка состояния.

Альтернативный подход заключается в создании пары кодовых страниц, скажем, 4 и 5 - которые отличаются только элементарными действиями десериализации ячеек. Например, на кодовой странице 4 они могут работать, как прежде, а на кодовой странице 5 – могут сериализовать данные не с начала Среза, а с его конца. Две новых команды - скажем, CLD и STD - могут использоваться для переключения на кодовую страницу 4 или кодовую страницу 5. Мы только что описали флажок состояния, определенным образом влияющий на выполнение некоторых команд.

5.1.8. Установка кодовой страницы в самом коде.
Для удобства мы резервируем некоторый код операции на всех кодовых страницах, скажем, FF n, для команды SETCP n, где n от 0 до 255 (см. A.13). Затем, разместив такую команду в самом начале (основной функции) программы (например, Смарт-контракт блокчейна TON) или библиотечной функции, мы можем гарантировать, что код всегда будет выполняться в необходимой кодовой странице.

5.2 Кодировка команд
В этом разделе обсуждаются общие принципы кодировки команд, применимые ко всем кодовым страницам и версиям TVM. Позже, в разделе 5.3 мы поговорим о выборе, который сделали в рамках реализации экспериментальной «нулевой кодовой страницы».

5.2.1. Кодировка команд осуществляется двоичным префиксным кодом.
Все полные команды TVM (т.е. команды вместе со всеми параметрами, например, названиями стековых регистров s(i) или другими встроенными константами) кодируются двоичным префиксным кодом. Это означает, что (конечная) двоичная строка (т.е. битная строка) соответствует каждой полной команде так, что битные строки, соответствующие различным полным командам, не совпадают, а никакая двоичная строка среди выбранного подмножества не является префиксом другой двоичной строки этого подмножества.

5.2.2. Определение первой команды кодового потока.
Вследствие данного метода кодировки любая двоичная строка допускает не более одного префикса, представляющего собой кодировку некоторой полной инструкции. В частности, код cc.code текущего продолжения (который является срезом и, следовательно, битной строкой вместе с некоторыми ссылками на ячейки) допускает не более одного такого префикса, что соответствует (однозначно определенной) команде, которую TVM исполнит первой. После исполнения префикс удаляется из кода текущего продолжения. Теперь может быть декодирована следующая инструкция.

5.2.3. Неверный код операции.
Если префикс cc.code не кодирует верную команду в текущей кодовой странице, генерируется ошибка недопустимого кода операции (см. 4.5.7). Однако, случай пустого cc.code рассматривается отдельно и подробно описан в 4.1.4 (точное поведение может зависеть от текущей кодовой страницы).

5.2.4. Особый случай: заполнение конца кода.
В качестве исключения из вышеизложенного правила, некоторые кодовые страницы могут принимать значения cc.code, которые слишком короткие для того, чтобы считаться верными кодировка команд, в качестве дополнительных вариантов NOP. Таким образом, эффективно применяется тот же подход, что и для пустого cc.code. Такие битные строки могут использоваться для заполнения кода в конце.

Например, если двоичная строка 00000000 (т.е. x00, см. 1.0.3) используется в кодовой странице для кодирования NOP, ее собственные префиксы не могут кодировать никакие команды. Таким образом, эта кодовая страница может принимать 0, 00, 000, ..., 0000000 в качестве вариантов NOP, если это все, что осталось в cc.code, вместо генерирования ошибки недопустимого кода операции.

Такое заполнение может быть полезно, например, если элементарное действие PUSHCONT (см. 4.2.3 ) создает только продолжения с кодом, состоящим из целого количества байтов, но не все команды кодируются целым числом.

5.2.5. Код TVM - это битный код, а не байт-код.
Напомним, что TVM – это побитно-ориентированная машина в том смысле, что ее ячейки (и срезы) естественным образом рассматриваются как последовательности битов, а не только октетов (байтов), см . 3.2.5. Так как код TVM также хранится в ячейках (см. 3.1.9 и 4.1.4), нет причин использовать только битные строки длины, кратной восьми, для кодировки полной команды. Другими словами, код TVM - это битовый код, не байт-код.

Тем не менее, некоторые кодовые страницы (например, нулевая экспериментальная кодовая страница) могут прибегнуть к использованию байт-кода (т. е. использовать только кодировки, состоящие из целого количества байтов) - либо для простоты, либо для облегчения устранения воспроизводимых ошибок и изучения дампов памяти (т.е. ячеек). (сноска 27)

5.2.6. Объем кода операции, используемый полной командой.
Напомним, что в теории программирования длины битных строк {\displaystyle l_{i}}{\displaystyle l_{i}}, использованных в двоичном коде префикса, удовлетворяют неравенство Крафта – Макмиллана {\displaystyle \sum _{i}2^{-l_{i}}\leq 1}{\displaystyle \sum _{i}2^{-l_{i}}\leq 1}. Это применимо, в частности, к (полной) кодировке команд, используемой кодовой страницей TVM. Мы утверждаем, что конкретная полная команды (или, точнее, кодировка полной команды) использует {\displaystyle 2^{-l}}{\displaystyle 2^{-l}} кода операции, если она закодирована l-битной строкой. Очевидно, что все полные команды используют максимум 1 (т.е. «не более всего объема кода операции»).

5.2.7. Объем кода операции, используемый командой, или классом команд.
Приведенная выше терминология распространяется на команды (рассматриваемые со всеми допустимыми значениями их параметров) или даже классы команд (например, все арифметические команды). Мы говорим, что (неполная) команды, или класс команд, занимает часть α объема кода операции, если α – сумма всех частей объема кода операции, занятых всеми полными командами этого класса.

5.2.8. Объем кода операции для байт-кодов.
Максимально приближенное объяснение гласит: Рассмотрите все 256 возможных значения первого байта кодировки команды. Предположим, что k этих значений соответствуют конкретной команде или классу команд, которые мы рассматриваем. Тогда эта команда или класс команд занимает примерно k/256 всего объема кодов операции.

Так, мы видим, почему все команды вместе взятые не могут занимать больше, чем часть 256/256 = 1 объема кода операции, по крайней мере, не ставя под угрозу уникальность декодирования команд.

5.2.9. Практически оптимальные кодировки.
Согласно теории, оптимально плотная кодировка, часть объема кода операции, используемая полной командой ({\displaystyle 2^{-l}}{\displaystyle 2^{-l}}, если полная команда закодирована l битами) должна быть приблизительно равна вероятности или частоте его появления в реальной программе. (сноска 28) То же самое должно относиться к (неполным) командам или базовым элементарным действиям (т. е. общие команды без заданных значений параметров), и к классам команд.

5.2.10. Пример: элементарные действия обработки стека.
Например, если команды стековой обработки составляют примерно половину всех команд в стандартной программе TVM, следует выделить примерно половину объема кода операции кодировки команд стековой обработки. Можно зарезервировать первые байты («коды операций») 0x00–0x7f для таких команд. Если четверть из них команды XCHG, имеет смысл зарезервировать 0x00–0x1f для XCHG. Точно так же, если половина всех XCHG связана с вершиной стека s0, логично использовать 0x00–0x0f для кодировки XCHG s0, s(i).

5.2.11. Простая кодировка команд.
В большинстве случаев используется простое кодирование полных команд. Простые кодировки начинаются с фиксированной битной строки, т.н. кода операции команды, за которой следуют, скажем, 4-битные поля, содержащие индексы i регистров стека s(i), указанных в команде, а затем следуют все остальные (литеральные, непосредственные) параметры, включенные в полную команду. Хотя простые кодировки могут быть не совсем оптимальными, они допускают короткие описания, а реализация их расшифровки и кодировки довольна проста.

Если (универсальная) команда использует простую кодировку с l-битным кодом операции, то команда будет использовать {\displaystyle 2^{-l}}{\displaystyle 2^{-l}} объема кода операции. Это может быть эффективно из соображений в 5.2.9 и 5.2.10.

5.2.12. Дальнейшая оптимизация плотности кода: коды Хаффмана.
Можно создать оптимально плотный двоичный код для всех полных команд, при условии, что известны их вероятности или частоты появления в реальном коде. Это известный код Хаффмана (для заданного распределения вероятностей). Тем не менее, такой код был бы весьма бессистемным и трудным для декодирования.

5.2.13. Кодировка команд на практике.
На практике кодировка команд в TVM и других виртуальных машинах представляет собой компромисс между плотностью кода и простотой кодирования и декодирования. Такой компромисс достигается путем выбора простых кодировок (см. 5 .2.11) для всех команд (возможно, с отдельными простыми кодировками для некоторых часто используемых вариантов, например, XCHG s0, s(i) среди всех XCHG s(i), s(j)), и выделения объема кода операции с применением эвристических алгоритмов, описанных в 5.2.9 и 5.2.10; в TVM сейчас применяется именно этот подход.

5.3 Кодировка команд на нулевой кодовой странице
В этом разделе содержится подробная информация об экспериментальной кодировке команд для нулевой кодовой страницы согласно описанию, предоставленному в данном документе (см. Приложение A). Данные правила используются предварительной тестовой версии TVM.

5.3.1. Возможность модернизации.
Во-первых, даже если эта предварительная версия попадет в производственную версию блокчейна TON, механизм кодовых страниц (см. 5.1) позволяет нам позже совершенствовать систему не в ущерб обратной совместимости. (сноска 29) Итак, пока мы можем поэкспериментировать.

5.3.2. Выбор команды.
Мы решили включить большое количество «экспериментальных» и не совсем нужных команд в нулевую кодовую страницу, чтобы посмотреть, как они могут использоваться в реальном коде. Например, есть как базовые (см. 2.2.1 ), так и составные (см. 2.2.3) элементарные действия стековой обработки, а также некоторые «бессистемные», например, ROT (в основном заимствованы из Forth). Если такие элементарные действия используются редко, они просто впустую занимают часть объема кода операции, а кодировка других команд становится немного менее эффективной. Но мы можем это допустить на данном этапе развития TVM.

5.3.3. Применение экспериментальных команд.
Некоторые из этих экспериментальных команд получили слишком длинные коды операций, просто чтобы они поместились в код операции. Не стоит бояться применять их только из-за их длины; если эти команды окажутся полезными, в будущих версиях им будут присвоены более короткие коды операций. Нулевая кодовая страница не должна быть в этом отношении идеальной.

5.3.4. Выбор байт-кода.
Мы решили использовать байт-код (т.е. кодировка полных команд имеет кратную восьми). Хотя, может, мы и не смогли обеспечить оптимальную плотность кода, так как такое ограничение длины усложняет сопоставление части объема кода операции для кодировки команды с примерными частотами этих команд в коде TVM (см. 5.2.11 и 5.2.9), такой подход имеет свои преимущества: требуется упрощенный декодер команд, а устранение воспроизводимых ошибок также упрощается (см. 5.2.5).

В конце концов, в данный момент у нас недостаточно данных об относительных частотах команд. На данном этапе важнее простота устранения воспроизводимых ошибок, возможность экспериментировать и простота реализации.

5.3.5. Проста кодировка всех команд.
По аналогичным причинам мы решили использовать простые кодировки для всех команд (см. 5.2.11 и 5.2.13), с отдельными простыми кодировками для некоторых очень часто используемых подслучаев, см 5.2.13 . Тем не менее, мы попытались распределить объем кода операции с использованием эвристических алгоритмов, описанных в 5.2.9 и 5.2.10.

5.3.6. Отсутствие контекстно-зависимых кодировок.
Данная версия TVM также не использует контекстно-зависимые кодировки (см . 5.1.6 ). Они могут быть добавлены на более позднем этапе, если потребуется. 5.3.7. Список всех команд. Список всех команд доступных в нулевой кодовой странице, а также их кодировки и (в некоторых случаях) краткое описание, можно найти в Приложении А.

Список используемой литературы: [1] Н. Дуров, Открытая сеть Telegram, 2017

A Команды и коды операций
В данном приложении перечислены все команды, доступные в (экспериментальной) нулевой кодовой странице TVM, описанной в 5.3.

Команды перечислены в лексикографическом порядке кодов операции. Однако, объем кода операции распределен таким образом, чтобы все команды в каждой категории (например, арифметические) имели смежные коды операций. Итак, сначала перечислены элементарные операции стековой обработки, затем константные, арифметические, элементарные действия сравнения, элементарные действия с ячейками, продолжениями, словарные элементарные действия и, наконец, элементарные действия для конкретных применений.

Применяется шестнадцатеричное представление (см. 1.0) битных строк. В регистрах стека s(i) обычно 0 ≤ i ≤ 15, а i кодируется в 4-битном поле (или, в некоторых редких случаях случаев в 8-битном поле). Другие непосредственные параметры обычно 4-битные, 8-битные или переменной длины.

В данном Приложении широко используются понятия, описанные в параграфе по представлению стека, см. 2.1.10.

А.1. Цена газа
Цена газа для большинства элементарных действий равна базовой цене газа, рассчитываемой как {\displaystyle P_{b}:=10+b+5r}{\displaystyle P_{b}:=10+b+5r}, где b - длина команды в битах, а r - количество ссылок на ячейки, включенные в команду. Когда цена газа команды отличается от этой базовой цены, она указывается в скобках после ее символики, либо как (x), что означает, что общая цена газа равна x, или как (+ x), что означает {\displaystyle P_{b}+x}{\displaystyle P_{b}+x}. Помимо целочисленных констант, могут встретиться следующие выражения:

• {\displaystyle C_{r}}{\displaystyle C_{r}} - общая стоимость «чтения» ячеек (т.е. преобразования ссылок на ячейку в срезы ячеек). В настоящее время равно 100 или 25 единицам газа за ячейку в зависимости от того, впервые ли ячейка с этим хешем «читается» во время текущего запуска ВМ, или нет.

• L - Полная стоимость ячеек загрузки. Зависит от действия загрузки.

• {\displaystyle B_{w}}{\displaystyle B_{w}} - Общая стоимость создания новых Builder (компоновщиков). В настоящее время равно 0 единиц газа за Builder.

• {\displaystyle C_{w}}{\displaystyle C_{w}} - Общая стоимость создания новых Ячеек из Builder. В настоящее время равно 500 единиц газа за ячейку.

По умолчанию цена газа для команды равна {\displaystyle P:=P_{b}+C_{r}+L+B_{w}+C_{w}}{\displaystyle P:=P_{b}+C_{r}+L+B_{w}+C_{w}}.

A.2 Элементарные действия стековой обработки
Данный раздел включает как основные (см . 2.2. 1), так и составные (см. 2.2.3) элементарные действия стековой обработки, а также некоторые «бессистемные» команды. Некоторые составные команды, например, XCPU или XCHG2, могут иметь ту же длину, что и эквивалентная последовательность более простых операций. Эти элементарные действия все равно включен, а в дальнейшем им можно присвоить более короткие коды операций - или навсегда удалить. Некоторые элементарные действия стековой обработки имеют две символики: одна в стиле Forth (например, -ROT), другая – согласно стандартным правилам для идентификаторов (например, ROTREV). Каждый раз, когда элементарное действие стековой обработки (например, PICK) принимает целочисленный параметр n из стека, он должен находиться в диапазоне 0 ... 255; в противном случае сгенерируется ошибка проверки диапазона перед дальнейшими проверками.

А.2.1. Базовые элементарные действия стековой обработки.
• 00 - NOP, пустой.

• 01 - XCHG s1, или SWAP.

• 0i - XCHG s(i) или XCHG s0, s(i), заменяет вершину стека на s(i), 1 ≤ i ≤ 15.

• 10ij - XCHG s(i), s(j), 1 ≤ i <j ≤ 15, заменяет s(i) на s(j).

• 11ii - XCHG s0, s (ii), где 0 ≤ ii ≤ 255.

• 1i - XCHG s1, s(i), 2 ≤ i ≤ 15.

• 2i - PUSH s(i), 0 ≤ i ≤ 15, проталкивает в стек копию старого s(i)

• 20 - PUSH s0, или DUP.

• 21 - PUSH s1, или OVER.

• 3i - POP s(i), 0 ≤ i ≤ 15, извлекает старое значение вершины стека в старое s(i).

• 30 - POP s0, или DROP, отбрасывает значение вершины стека.

• 31 - POP s1, или NIP.

А.2.2. Составные элементарные действия стековой обработки.
Параметры i, j, и k следующих элементарных действий являются 4-битными целыми в диапазоне 0 ... 15.

• 4ijk - XCHG3 s(i), s(j), s(k), аналог XCHG s2, s(i); XCHG s1, s(j); XCHG s0, s(k), где 0 ≤ i, j, k ≤ 15.

• 50ij - XCHG2 s(i), s(j), аналог XCHG s1, s(i); XCHG s(j).

• 51ij - XCPU s(i), s(j), аналог XCHG s(i); PUSH s(j).

• 52ij - PUXC s(i), s (j - 1), аналог PUSH s(i); SWAP; XCHG s(j).

• 53ij - PUSH2 s(i), s(j), аналог PUSH s(i); PUSH s (j + 1).

• 540ijk - XCHG3 s(i), s(j), s(k) (полная форма).

• 541ijk - XC2PU s(i), s(j), s(k), аналог XCHG2 s(i), s(j); PUSH s(k).

• 542ijk - XCPUXC s(i), s(j), s(k − 1), аналог XCHG s1, s(i); PUXC s(j), s(k - 1).

• 543ijk - XCPU2 s(i), s(j), s(k), аналог XCHG s(i); PUSH2 s(j), s(k).

• 544ijk - PUXC2 s(i), s(j −1), s(k −1), аналог PUSH s(i); XCHG s2; XCHG2 s(j), s(k).

• 545ijk - PUXCPU s(i), s(j − 1), s(k − 1), аналог PUXC s(i), s(j−1); PUSH s(k).

• 546ijk - PU2XC s(i), s(j − 1), s(k − 2), аналог PUSH s(i); SWAP; PUXC s(j), s(k - 1).

• 547ijk - PUSH3 s(i), s(j), s(k), аналог PUSH s(i); PUSH2 s (j +1), s(k + 1).

• 54C_ - не используется.

А.2.3. Особые элементарные действия стековой обработки.
• 55ij - BLKSWAP i + 1, j + 1, меняет местами два блока s(j + i + 1) ... s(j + 1) и s(j) ... s0, для 0 ≤ i, j ≤ 15; аналог REVERSE i + 1, j + 1; REVERSE j + 1,0; REVERSE i + j + 2,0.

• 5513 - ROT2 или 2ROT (abcdef - cdefab), вращает три самые верхние пары записей стека.

• 550i - ROLL i + 1, вращает верхние элементы стека i + 1. Аналог BLKSWAP 1, i + 1.

• 55i0 - ROLLREV i + 1 или -ROLL i + 1, вращает верхние записи стека i + 1 в другом направлении. Аналог BLKSWAP i + 1,1.

• 56ii - PUSH s(ii) для 0 ≤ ii ≤ 255.

• 57ii - POP s(ii) для 0 ≤ ii ≤ 255.

• 58 - ROT (abc - bca), аналог BLKSWAP 1,2 или XCHG2 s2, s1.

• 59 - ROTREV или -ROT (abc - cab), аналог BLKSWAP 2,1 или XCHG2 s2, s2.

• 5A - SWAP2 или 2SWAP (abcd - cdab), аналог BLKSWAP 2,2 или XCHG2 s3, s2.

• 5B - DROP2 или 2DROP (ab -), аналог DROP; DROP.

• 5C - DUP2 или 2DUP (ab - abab), аналог PUSH2 s1, s0.

• 5D - OVER2 или 2OVER (abcd - abcdab), аналог PUSH2 s3, s2.

• 5Eij - REVERSE i + 2, j, меняет порядок s(j + i + 1) ... s(j) для 0 ≤ i, j ≤ 15; аналог последовательности ⌊i / 2⌋ + 1 XCHG.

• 5F0i - BLKDROP i, аналог исполнения DROP i раз.

• 5Fij - BLKPUSH i, j, аналог PUSH s(j), выполненному i раз, 1 ≤ i ≤ 15, 0 ≤ j ≤ 15.

• 60 - PICK или PUSHX, извлекает целое число i из стека, затем исполняет PUSH s(i).

• 61 - ROLLX, извлекает целое число i из стека, затем исполняет BLKSWAP 1, i.

• 62 - -ROLLX или ROLLREVX, извлекает целое число i из стека, затем исполняет BLKSWAP i, 1.

• 63 - BLKSWX, извлекает целые числа i, j из стека, затем исполняет BLKSWAP I,j.

• 64 - REVX, извлекает целые числа i, j из стека, затем выполняет REVERSE I,j.

• 65 - DROPX, извлекает целое число i из стека, затем выполняет BLKDROP i.

• 66 - TUCK (ab - bab), аналог SWAP; OVER или XCPU s1, s1.

• 67 - XCHGX, извлекает целое число i из стека, затем выполняет XCHG s(i).

• 68 - DEPTH, проталкивает текущую глубину стека.

• 69 - CHKDEPTH, извлекает целое число i из стека, затем проверяет, существует ли не менее i элементов, иначе генерирует ошибку исчерпания стека.

• 6A - ONLYTOPX, извлекает целое число i из стека, затем удаляет все, кроме верхних i элементов.

• 6B - ONLYX, извлекает целое число i из стека, затем оставляет только нижние I элементы. Практический аналог DEPTH; ЗАМЕНА; SUB; DROPX.

• 6C00–6C0F - зарезервировано для стековых операций.

• 6Cij - BLKDROP2 i, j, отбрасывает i элементов стека под верхними j элементами, где 1 ≤ i ≤ 15 и 0 ≤ j ≤ 15. Аналог REVERSE i + j, 0; BLKDROP i; REVERSE j, 0.

A.3 Элементарные действия кортежа, списка и нуля
Кортежи - это упорядоченные подробки, состоящие не более чем из 255 значений стека TVM произвольных типов (не обязательно одинаковых). Элементарные действия кортежей создают, изменяют и распаковывают кортежи (Tuples); они обрабатывают значения произвольных типов аналогично стековым элементарным действиям. Мы не рекомендуем использовать кортежи, состоящие более, чем из 15 элементов.

Когда кортеж t содержит элементы {\displaystyle x_{1},\ldots ,x_{n}}{\displaystyle x_{1},\ldots ,x_{n}} (в этом порядке), записываем {\displaystyle t=(x_{1},\ldots ,x_{n})}{\displaystyle t=(x_{1},\ldots ,x_{n})}; число n ≥ 0 - длина кортежа t. Дополнительное обозначение - |t|. Кортежи длины 2 называют парами, а кортежи длины 3 - тройками.

Списки в стиле Lisp представляются с помощью пар, то есть кортежей, состоящих из ровно 2 элементов. Пустой список представлен значением Null, а непустой список представлен парой (h, t), где h - первый элемент списка, а t - его хвост.

А.3.1. Нулевые элементарные действия.
Следующие элементарные действия работают с (единственным) значением ⊥ типа Null и используются для представления пустых списков, пустых ветвей бинарных деревьев и при отсутствии значений в типах Maybe X. Пустой кортеж, созданный NIL, также может использоваться в этих целях; но Null эффективнее и дешевле в плане газа.

• 6D - NULL или PUSHNULL (- ⊥), проталкивает единственное значение типа Null.

• 6E - ISNULL (x -?), проверяет, является ли x нулевым (NULL), и возвращает -1 или 0, соответственно.

А.3.2. Элементарные действия кортежей.
• 6F0n - TUPLE n ({\displaystyle x_{1}\dots x_{n}-t}{\displaystyle x_{1}\dots x_{n}-t}), создает новый кортеж t = {\displaystyle (x_{1},\ldots ,x_{n})}{\displaystyle (x_{1},\ldots ,x_{n})}, содержащий n значений {\displaystyle x_{1},\dots ,x_{n}}{\displaystyle x_{1},\dots ,x_{n}} , где 0 ≤ n ≤ 15.

• 6F00 - NIL (- t), проталкивает единственный Tuple t = () нулевой длины.

• 6F01 - SINGLE (x - t), создает одноэлементное множество t: = (x), т.е. Кортеж длиной 1.

• 6F02 - PAIR или CONS (x y - t), создает пару t: = (x, y).

• 6F03 - TRIPLE (x y z - t), создает тройку t: = (x, y, z).

• 6F1k - ИНДЕКС k (t - x), возвращает k-й элемент кортежа t, где 0 ≤ k ≤ 15. Другими словами, возвращает {\displaystyle x_{k+1}}{\displaystyle x_{k+1}}, если {\displaystyle t=(x_{1},\ldots ,x_{n})}{\displaystyle t=(x_{1},\ldots ,x_{n})}. Если k ≥ n, выдает ошибку проверки диапазона.

• 6F10 - FIRST или CAR (t - x), возвращает первый элемент кортежа.

• 6F11 - SECOND или CDR (t - y), возвращает второй элемент кортежа.

• 6F12 - THIRD (t - z), возвращает третий элемент кортежа.

• 6F2n - UNTUPLE n (t - {\displaystyle x_{1}\dots x_{n}}{\displaystyle x_{1}\dots x_{n}}), распаковывает кортеж t = ({\displaystyle (x_{1},\ldots ,x_{n})}{\displaystyle (x_{1},\ldots ,x_{n})}) из длины 0 ≤ n ≤ 15. Если t не является кортежем, {\displaystyle |t|\neq n}{\displaystyle |t|\neq n}, генерируется ошибка проверки типа.

• 6F21 - UNSINGLE (t - x), распаковывает одноэлементное множество t = (x).

• 6F22 - UNPAIR или UNCONS (t – x y), распаковывает пару t = (x, y).

• 6F23 - UNTRIPLE (t – x y z), распаковывает тройку t = (x, y, z).

• 6F3k - UNPACKFIRST k (t - {\displaystyle x_{1}\$\dots \$x_{k}}{\displaystyle x_{1}\$\dots \$x_{k}}), сначала распаковываются 0 ≤ k ≤ 15 элементы кортежа t. Если |t| < k, генерируется ошибка проверки типа.

• 6F30 - CHKTUPLE (t -), проверяет, является ли t кортежем.

• 6F4n - EXPLODE n (t - {\displaystyle x_{1}\dots x_{m}m}{\displaystyle x_{1}\dots x_{m}m}), распаковывает кортеж t = ({\displaystyle (x_{1},\ldots ,x_{m})}{\displaystyle (x_{1},\ldots ,x_{m})}) и возвращает его длину m, но только если m ≤ n ≤ 15. В противном случае генерирует ошибку проверки типа.

• 6F5k - SETINDEX k (t x - ), вычисляет кортеж , который отличается от t только в позиции , которая принимается равной x. Другими словами, |t| = |t|, = и для данного 0 ≤ k ≤ 15. Если k ≥ |t|, генерирует ошибку проверки диапазона.

• 6F50 - SETFIRST (t x - {\displaystyle t'}{\displaystyle t'}), определяет первый компонент кортежа t равным x и возвращает полученный кортеж t'.

• 6F51 - SETSECOND (t x - {\displaystyle t'}{\displaystyle t'}), определяет второй компонент кортежа t равным x и возвращает полученный кортеж t'.

• 6F52 - SETTHIRD (t x - {\displaystyle t'}{\displaystyle t'}), устанавливает третий компонент кортежа t равным x и возвращает полученный кортеж t'.

• 6F6k - INDEXQ k (t - x), возвращает k-й элемент кортежа t, где 0 ≤ k ≤ 15. Другими словами, возвращает {\displaystyle x_{k+1}}{\displaystyle x_{k+1}}, если t = ({\displaystyle (x_{1},\ldots ,x_{n})}{\displaystyle (x_{1},\ldots ,x_{n})}. Если k ≥ n, или, если t равно нулю, возвращает ноль вместо x.

• 6F7k - SETINDEXQ k (t x - {\displaystyle t'}{\displaystyle t'}), устанавливает k-й компонент кортежа t равным x, где 0 ≤ k <16, и возвращает кортеж {\displaystyle t'}{\displaystyle t'}. Если |t| ≤ k, сначала расширяет исходный кортеж до длины k + 1, определяя все новые компоненты, как NULL. Если исходное значение t равно нулю, рассматривает его как пустой кортеж. Если t не равно нулю или кортежу, выдает ошибку. Если x равен NULL, и если либо |t| ≤ k, либо t равно NULL, тогда всегда возвращает {\displaystyle t'=t}{\displaystyle t'=t} (и не использует газ для создания кортежа).

• 6F80 - TUPLEVAR ({\displaystyle x_{1}\dots x_{n}n-t}{\displaystyle x_{1}\dots x_{n}n-t}), создает новый кортеж t длины n по аналогии с TUPLE, но 0 ≤ n ≤ 255 берется из стека.

• 6F81 - INDEXVAR (t k - x), аналогично INDEX k, но с 0 ≤ k ≤ 254 взят из стека.

• 6F82 - UNTUPLEVAR ({\displaystyle tn-x_{1}\dots x_{n}}{\displaystyle tn-x_{1}\dots x_{n}}), аналог UNTUPLE n, но 0 ≤ n ≤ 255 взяты из стека.

• 6F83 - UNPACKFIRSTVAR ({\displaystyle tn-x_{1}\dots x_{n}}{\displaystyle tn-x_{1}\dots x_{n}}), аналог UNPACKFIRST n, но 0 ≤ n ≤ 255 взят из стека.

• 6F84 - EXPLODEVAR ({\displaystyle tn-x_{1}\dots x_{m}m}{\displaystyle tn-x_{1}\dots x_{m}m}), аналог EXPLODE n, но 0 ≤ n ≤ 255 взят из стека.

• 6F85 - SETINDEXVAR ({\displaystyle txk-t'}{\displaystyle txk-t'}), аналог SETINDEX k, но 0 ≤ k ≤ 254 взят из стека.

• 6F86 - INDEXVARQ (t k - x), аналог INDEXQ n, но 0 ≤ k ≤ 254 взят из стека.

• 6F87 - SETINDEXVARQ ({\displaystyle txk-t'}{\displaystyle txk-t'}), аналог SETINDEXQ k, но 0 ≤ k ≤ 254 взят из стека.

• 6F88 - TLEN (t - n), возвращает длину кортежа.

• 6F89 - QTLEN (t - n или −1), аналог TLEN, но возвращает −1, если t не Кортеж.

• 6F8A - ISTUPLE (t -?), возвращает -1 или 0 в зависимости от того, является ли t кортежем.

• 6F8B - LAST (t - x), возвращает последний элемент {\displaystyle t_{|t|}}{\displaystyle t_{|t|}} непустого кортежа t.

• 6F8C - TPUSH или COMMA ({\displaystyle tx-t'}{\displaystyle tx-t'}), добавляет значение x к кортежу {\displaystyle t=(x_{1},\ldots ,x_{n})}{\displaystyle t=(x_{1},\ldots ,x_{n})}, но только если получившийся в результате кортеж {\displaystyle t'=(x_{1},\ldots ,x_{n},x)}{\displaystyle t'=(x_{1},\ldots ,x_{n},x)} длиной не более 255. В противном случае выдается ошибка проверки типа.

• 6F8D - TPOP ({\displaystyle t-t'x}{\displaystyle t-t'x}), отделяет последний элемент {\displaystyle x=x_{n}}{\displaystyle x=x_{n}} непустого кортежа {\displaystyle t=(x_{1},\ldots ,x_{n})}{\displaystyle t=(x_{1},\ldots ,x_{n})} и возвращает оба кортежа {\displaystyle t'=(x_{1},\ldots ,x_{n-1})}{\displaystyle t'=(x_{1},\ldots ,x_{n-1})} и исходный последний элемент x.

• 6FA0 - NULLSWAPIF (x - x или ⊥ x), проталкивает ноль под верхнее Целое x, но только если {\displaystyle x\neq 0}{\displaystyle x\neq 0}.

• 6FA1 - NULLSWAPIFNOT (x - x или ⊥ x), проталкивает ноль под верхнее целое x, но только если x = 0. Может использоваться для выравнивания стека после тихих элементарных действий, например, PLDUXQ.

• 6FA2 - NULLROTRIF (x y – x y или ⊥ x y), проталкивает ноль под второй сверху элемент стека, но только если самое верхнее целое число y равно не равно нулю.

• 6FA3 - NULLROTRIFNOT (x y – x y или ⊥ x y), проталкивает ноль под второй сверху элемент стека, но только если верхнее целое число y равно нулю. Может использоваться для выравнивания стека после тихих элементарных действий, как LDUXQ.

• 6FA4 - NULLSWAPIF2 (x - x или ⊥ ⊥ x), проталкивает два нуля под верхнее целое число x, но только если {\displaystyle x\neq 0}{\displaystyle x\neq 0}. Аналог NULLSWAPIF; NULLSWAPIF.

• 6FA5 - NULLSWAPIFNOT2 (x - x или ⊥ ⊥ x), проталкивает два нуля под верхнее целое число x, но только если x = 0. Аналог NULLSWAPIFNOT; NULLSWAPIFNOT.

• 6FA6 - NULLROTRIF2 (x y – x y или ⊥ ⊥ x y), проталкивает два нуля под второй сверху элемент стека, но только если верхнее целое число y не равно нулю. Аналог NULLROTRIF; NULLROTRIFNOT

• 6FA7 - NULLROTRIF2 (x y – x y или ⊥ ⊥ x y), проталкивает два нуля под второй сверху элемент стека, но только если верхнее целое число y равно нулю. Аналог NULLROTRIF; NULLROTRIFNOT

• 6FBij - INDEX2 i, j (t - x), возвращает {\displaystyle x=(t_{i+1})_{j+1}}{\displaystyle x=(t_{i+1})_{j+1}} для 0 ≤ i, j ≤ 3. Аналог INDEX i; INDEX j.

• 6FB4 - CADR (t - x), возвращает {\displaystyle x=(t_{2})_{1}}{\displaystyle x=(t_{2})_{1}}.

• 6FB5 - CDDR (t - x), возвращает {\displaystyle x=(t_{2})_{2}}{\displaystyle x=(t_{2})_{2}}.

• 6FE_ijk - INDEX3 i, j, k (t - x), возвращает {\displaystyle x={\bigl (}(t_{i+1})_{j+1}{\bigr )}_{k+1}}{\displaystyle x={\bigl (}(t_{i+1})_{j+1}{\bigr )}_{k+1}} для 0 ≤ i, j, k ≤ 3. Аналог INDEX2 i, j; INDEX k.

• 6FD4 - CADDR (t - x), возвращает {\displaystyle x={\bigl (}(t_{2})_{2}{\bigr )}_{1}}{\displaystyle x={\bigl (}(t_{2})_{2}{\bigr )}_{1}}.

• 6FD5 - CDDDR (t - x), возвращает {\displaystyle x={\bigl (}(t_{2})_{2}{\bigr )}_{2}}{\displaystyle x={\bigl (}(t_{2})_{2}{\bigr )}_{2}}.

A.4 Константы или литеральные элементарные действия
Следующие элементарные действия проталкивают в стек одну литеральную константу (или безымянную константу) некоторого типа и диапазона, сохраненную в качестве части (непосредственного аргумента) команды. Поэтому, если непосредственный аргумент отсутствует или слишком короткий, генерируется ошибка «недопустимый или слишком короткий код операции» (код 6).

А.4.1. Целочисленные и булевы константы.
• 7i - PUSHINT x, где −5 ≤ x ≤ 10, проталкивает целое число x в стек; i равно четырем младшим битам x (т. е. i = x mod 16).

• 70 - ZERO, FALSE или PUSHINT 0, проталкивает ноль.

• 71 - ONE или PUSHINT 1.

• 72 - TWO или PUSHINT 2.

• 7A - TEN или PUSHINT 10.

• 7F - TRUE или OUSHINT -1.

• 80xx - PUSHINT xx, где −128 ≤ xx ≤ 127.

• 81xxxx - PUSHINT xxxx, где –{\displaystyle -2^{15}\leq xxxx<2^{15}}{\displaystyle -2^{15}\leq xxxx<2^{15}} 16-битное целое число со знаком с обратным порядком байтов.

• 81FC18 - PUSHINT −1000.

• 82lxxx - PUSHINT xxx, где 5-битный 0 ≤ l ≤ 30 определяет длину n = 8l + 19 целого числа со знаком xxx с обратным порядком байтов. Общая длина этой команды l + 4 байта или n + 13 = 8l + 32 бита.

• 821005F5E100 - PUSH {\displaystyle 10^{8}}{\displaystyle 10^{8}}.

• 83xx - PUSHPOW2 xx + 1, (в тихом режиме) проталкивает {\displaystyle 2^{xx+1}}{\displaystyle 2^{xx+1}} для {\displaystyle 0\leq xx\leq 255}{\displaystyle 0\leq xx\leq 255}.

• 83FF - PUSHNAN, проталкивает NaN.

• 84xx - PUSHPOW2DEC xx + 1, проталкивает {\displaystyle 2^{xx+1}-1}{\displaystyle 2^{xx+1}-1} для 0 ≤ xx ≤ 255.

• 85xx - PUSHNEGPOW2 xx + 1, проталкивает {\displaystyle -2^{xx+1}}{\displaystyle -2^{xx+1}} для 0 ≤ xx ≤ 255.

• 86, 87 - зарезервированы для целочисленных констант.

А.4.2. Постоянные срезы, продолжения, ячейки и ссылки.
Большинство перечисленных ниже команд проталкивают литеральные срезы, продолжения, ячейки и ссылки на ячейки, хранящиеся в качестве непосредственных аргументов команды. Следовательно, если непосредственный аргумент отсутствует или слишком короткий, генерируется ошибка «недействительный или слишком короткий код операции»(код 6).

• 88 - PUSHREF, проталкивает в стек первую ссылку cc.code в качестве Ячейки (и удаляет эту ссылку из текущего продолжения).

• 89 - PUSHREFSLICE, аналог PUSHREF, но преобразует ячейку в срез.

• 8A - PUSHREFCONT, аналог PUSHREFSLICE, но превращает ссылку в простое Продолжение.

• 8Bxsss - PUSHSLICE sss, подталкивает (префиксный) срез cc.code, состоящий первых 8x + 4 бит и не имеющий ссылок (т. е. по существу битную строку), где 0 ≤ x ≤ 15. Предполагается тег завершения, означающий, что все завершающие нули и последняя двоичная единица (при наличии) удаляются из данной битной строка. Если исходная битная строка состоит только из нулей, будет протолкнут в стек пустой срез.

• 8B08 - PUSHSLICE x8_, проталкивает пустой срез (цепочка битов »).

• 8B04 - PUSHSLICE x4_, проталкивает битную строку '0'.

• 8B0C - PUSHSLICE xC_, проталкивает битную строку ‘1'.

• 8Crxxssss - PUSHSLICE ssss, проталкивает (префиксный) срез cc.code, состоящий из первых 1 ≤ r + 1 ≤ 4 ссылок и до первых 8xx + 1 бит данных, где 0 ≤ xx ≤ 31. Предполагается тег завершения.

• 8C01 аналог PUSHREFSLICE.

• 8Drxxsssss - PUSHSLICE sssss, проталкивает срез cc.code, состоязий из 0 ≤ r ≤ 4 ссылок и до 8xx + 6 бит данных, где 0 ≤ xx ≤ 127. Предполагается тег завершения.

• 8DE_ - не используется (зарезервировано).

• 8F_rxxcccc - PUSHCONT cccc, где cccc – простое продолжение, созданное из первых 0 ≤ r ≤ 3 ссылок и первых 0 ≤ xx ≤ 127 байтов cc.code.

• 9xccc - PUSHCONT ccc, проталкивает x-байтовое продолжение 0 ≤ x ≤ 15.

А.5 Арифметические элементарные действия
А.5.1. Сложение, вычитание, умножение.
• A0 - ADD (x y - x + y), складывает два целых числа.

• A1 - SUB (x y - x - y).

• A2 - SUBR (xy - y - x), аналог SWAP; SUB.

• A3 - ОТРИЦАТЕЛЬНЫЙ (x - −x), аналог MULCONST −1 или ZERO; SUBR. Обратите внимание, если {\displaystyle x=-2^{256}}{\displaystyle x=-2^{256}}, генерируется ошибка целочисленного переполнения.

• A4 - INC (x - x + 1), аналог ADDCONST 1.

• A5 - DEC (x - x - 1), аналог ADDCONST −1.

• A6cc - ADDCONST cc (x - x + cc), −128 ≤ cc ≤ 127.

• A7cc - MULCONST cc (x - x · cc), −128 ≤ cc ≤ 127.

• A8 - MUL (xy - xy).

А.5.2. Деление.
Общая кодировка команд DIV, DIVMOD или MOD - A9mscdf, с необязательным умножением в обратном порядке и необязательной заменой деления или умножение на сдвиг. Переменные одно- или двухбитные поля m, s, c, d и f:

• 0 ≤ m ≤ 1 - указывает, есть ли умножение в обратном порядке (команда MULDIV и ее варианты) с возможностью замены сдвигом влево.

• 0 ≤ s ≤ 2 - указывает, умножение или деление подлежало замене на сдвиг: s = 0 - без замены, s = 1 – деление заменялось сдвигом вправо, s = 2 - умножение заменялось сдвигом влево (возможно только при m = 1).

• 0 ≤ c ≤ 1 - указывает, существует ли постоянный однобайтовый аргумент. tt для оператора сдвига (если {\displaystyle s\neq 0}{\displaystyle s\neq 0}). Для s = 0, c = 0. Если c = 1, 0 ≤ tt ≤ 255, а сдвиг выполняется на tt + 1 бит. Если {\displaystyle s\neq 0}{\displaystyle s\neq 0} и c = 0, то величина сдвига передается в команду целым числом на вершине стека в диапазоне 0 ... 256.

• 1 ≤ d ≤ 3 - указывает, какие требуются результаты деления: 1 – только частное, 2 - только остаток, 3 - оба.

• 0 ≤ f ≤ 2 - режим округления: 0 – округление до ближайшего целого в меньшую сторону (пол), 1 - ближайшее целое число, 2 - округление до ближайшего целого в большую сторону (потолок). (см. 1.5.6) .

Примеры:

• A904 - DIV (xy - q: = ⌊x / y⌋).

• A905 - DIVR (xy - {\displaystyle q'}{\displaystyle q'}: = ⌊x/y + 1/2⌋).

• A906 - DIVC (xy - {\displaystyle q''}{\displaystyle q''}: = ⌈x / y⌉).

• A908 - MOD (xy - r), где q: = ⌊x / y⌋, r: = x mod y: = x - yq.

• A90C - DIVMOD (xy – q r), где q: = ⌊x/y⌋, r = x – yq.

• A90D - DIVMODR (xy – q' r'), где q': = ⌊x/y + 1/2⌋, r': = x – yq'.

• A90E - DIVMODC (xy – q r), где q: = ⌈x/y⌉, r: = x – yq.

• A924 - то же, что RSHIFT: ({\displaystyle xy-\lfloor x\cdot 2^{-y}\rfloor }{\displaystyle xy-\lfloor x\cdot 2^{-y}\rfloor }) для 0 ≤ y ≤ 256.

• A934tt - то же, что RSHIFT tt + 1: (x - {\displaystyle \lfloor x\cdot 2^{-tt-1}\rfloor }{\displaystyle \lfloor x\cdot 2^{-tt-1}\rfloor }).

• A938tt - MODPOW2 tt + 1: ({\displaystyle x-x{\bmod {2}}^{tt+1}}{\displaystyle x-x{\bmod {2}}^{tt+1}}).

• A985 - MULDIVR (xyz - q'), где q' = ⌊xy/z + 1/2⌋.

• A98C - MULDIVMOD (xyz - qr), где q: = ⌊x·y/z⌋, r: = x·y mod z (аналог */MOD в Forth).

• A9A4 - MULRSHIFT (xyz - {\displaystyle \lfloor xy\cdot 2^{-z}\rfloor }{\displaystyle \lfloor xy\cdot 2^{-z}\rfloor }) для 0 ≤ z ≤ 256.

• A9A5 - MULRSHIFTR (xyz - {\displaystyle \lfloor xy\cdot 2^{-z}+1/2\rfloor }{\displaystyle \lfloor xy\cdot 2^{-z}+1/2\rfloor }) для 0 ≤ z ≤ 256.

• A9B4tt - MULRSHIFT tt + 1 (xy - {\displaystyle \lfloor xy\cdot 2^{-tt-1}\rfloor }{\displaystyle \lfloor xy\cdot 2^{-tt-1}\rfloor }).

• A9B5tt - MULRSHIFTR tt + 1 (xy - {\displaystyle \lfloor xy\cdot 2^{-tt-1}+1/2\rfloor }{\displaystyle \lfloor xy\cdot 2^{-tt-1}+1/2\rfloor }).

• A9C4 - LSHIFTDIV (xyz - {\displaystyle \lfloor 2^{z}x/y\rfloor }{\displaystyle \lfloor 2^{z}x/y\rfloor }) для 0 ≤ z ≤ 256.

• A9C5 - LSHIFTDIVR (xyz - {\displaystyle \lfloor 2^{z}x/y+1/2\rfloor }{\displaystyle \lfloor 2^{z}x/y+1/2\rfloor }) для 0 ≤ z ≤ 256.

• A9D4tt - LSHIFTDIV tt + 1 (xy - {\displaystyle \lfloor 2^{tt+1}x/y\rfloor }{\displaystyle \lfloor 2^{tt+1}x/y\rfloor }).

• A9D5tt - LSHIFTDIVR tt + 1 (xy - {\displaystyle \lfloor 2^{tt+1}x/y+1/2\rfloor }{\displaystyle \lfloor 2^{tt+1}x/y+1/2\rfloor }).

Наиболее полезными команды- DIV, DIVMOD, MOD, DIVR, DIVC, MODPOW2 t и RSHIFTR t (для целочисленной арифметики); и MULDIVMODD, MULDIV, MULDIVR, LSHIFTDIVR t и MULRSHIFTR t (для арифметики с фиксированной точкой).

А.5.3. Сдвиги, логические операции.
• AAcc - LSHIFT cc + 1 (x - {\displaystyle x\cdot 2^{cc+1}}{\displaystyle x\cdot 2^{cc+1}}), 0 ≤ cc ≤ 255.

• AA00 - LSHIFT 1, аналог MULCONST 2 или 2* в Forth

• ABcc - RSHIFT cc + 1 (x - {\displaystyle \lfloor x\cdot 2^{-cc-1}\rfloor }{\displaystyle \lfloor x\cdot 2^{-cc-1}\rfloor }), 0 ≤ cc ≤ 255.

• AC - LSHIFT (xy - {\displaystyle x\cdot 2^{y}}{\displaystyle x\cdot 2^{y}}), 0 ≤ y ≤ 1023.

• AD - RSHIFT (xy - {\displaystyle \lfloor x\cdot 2^{-y}\rfloor }{\displaystyle \lfloor x\cdot 2^{-y}\rfloor }), 0 ≤ y ≤ 1023.

• AE - POW2 (y - {\displaystyle 2^{y}}{\displaystyle 2^{y}} ), 0 ≤ y ≤ 1023, аналог ONE; SWAP; LSHIFT.

• AF - зарезервировано.

• B0 - AND (xy - x & y), побитовое «и» двух целых чисел со знаком x и y, знак расширен до бесконечности.

• B1 - OR (xy - x ∨ y), побитовое «или» двух целых чисел.

• B2 - XOR (xy - x ⊕ y), побитовое «исключающее или» двух целых чисел.

• B3 - NOT (x - x ⊕ −1 = −1 - x), побитовое «не» целого числа.

• B4cc - FITS cc + 1 (x - x), проверяет, является ли x cc + 1-битным целым числом со знаком для 0 ≤ cc ≤ 255 (т.е. независимо от того, верно ли − {\displaystyle -2^{cc}\leq x<2^{cc}}{\displaystyle -2^{cc}\leq x<2^{cc}}). Если нет, либо генерируется ошибка целочисленного переполнения или заменяется x на NaN (тихая версия).

• B400 - FITS 1 или CHKBOOL (x - x), проверяет, является ли x «булевым значением» (т. е. 0 или -1).

• B5cc - UFITS cc + 1 (x - x), проверяет, является ли x cc + 1-битным беззнаковым целым числом для 0 ≤ cc ≤ 255 (то есть, верно ли {\displaystyle 0\leq x<2^{cc+1}}{\displaystyle 0\leq x<2^{cc+1}}).

• B500 - UFITS 1 или CHKBIT, проверяет, является ли x двоичной цифрой (т.е. ноль или один).

• B600 - FITSX (xc - x), проверяет, является ли x c-битовым целым числом со знаком для 0 ≤ c ≤ 1023.

• B601 - UFITSX (xc - x), проверяет, является ли x c-битовым целым числом без знака для 0 ≤ c ≤ 1023.

• B602 - BITSIZE (x - c), вычисляет наименьшее c ≥ 0 такое, что x попадает в c-битовое целое число со знаком ({\displaystyle -2^{c-1}\leq c<2^{c-1}}{\displaystyle -2^{c-1}\leq c<2^{c-1}}).

• B603 - UBITSIZE (x - c), вычисляет наименьшее c ≥ 0 такое, что x попадает в c-битовое целое число без знака ({\displaystyle 0\leq x<2^{c}}{\displaystyle 0\leq x<2^{c}}), иначе генерируется ошибка проверки диапазона.

• B608 - MIN (xy - x или y), вычисляет минимум двух целых чисел x и у.

• B609 - MAX (xy - x или y), вычисляет максимум двух целых чисел x и у.

• B60A - MINMAX или INTSORT2 (xy - xy или yx), проверяет два целых числа. Тиха версия этой операции возвращает два NaN, если какой-либо из аргументов NaN.

• B60B - ABS (x - |x|), вычисляет абсолютное значение целого числа x.

А.5.4. Тихие арифметические элементарные действия.
Мы решили сделать все арифметические элементарные действия «не-тихими» (с генерированием ошибки) по умолчанию, а тихий аналог выделяется префиксом. Такая кодировка определенно не является оптимальной. Пока не ясно, нужно ли оставить все таким образом, или, наоборот, все арифметические операции должны быть тихими по умолчанию, также не ясно, должны ли тихие и не-тихие операции иметь одинаковую длину кодов операции; все решается только на практике.

• B7xx - префикс QUIET, преобразующий любую арифметическую операцию в ее «Тихий» вариант, обозначаемый префиксом Q перед ее символикой. Такие операции возвращают NaN вместо генерирования ошибки целочисленного переполнения, если результаты не подходят для целых чисел или если один из аргументов - NaN. Обратите внимание, что это не распространяется на суммы сдвига и другие параметры, значения которых должны находиться в небольшом диапазоне (например, 0–1023). Также обратите внимание на то, что данный префикс не отменяет генерацию ошибок проверки типов, если значение не принадлежит типу Целое.

• B7A0 - QADD (xy - x + y), всегда работает, если x и y являются целыми числами, но возвращает NaN, если сложение не может быть выполнено.

• B7A904 - QDIV (xy - ⌊x/y⌋), возвращает NaN, если y = 0, или если y = −1 и {\displaystyle x=-2^{256}}{\displaystyle x=-2^{256}}, или если любой из x или y является NaN.

• B7B0 - QAND (xy - x & y), побитовое «и» (аналогично AND), но возвращает NaN, если x или y являются NaN, а не генерирует ошибку целочисленного переполнения. Однако, если один из аргументов равен нулю, а другой - NaN, результат равен нулю.

B7B1 - QOR (xy - {\displaystyle x\vee y}{\displaystyle x\vee y}), побитовое «или». Если x = −1 или y = −1, результат всегда -1, даже если другой аргумент - NaN.

B7B507 - QUFITS 8 (x - {\displaystyle x'}{\displaystyle x'}), проверяет, является ли x байтом без знака (то есть, 0 ≤ x < ), и заменяет x на NaN, если это не так; в противном случае оставляет x без изменений (т. е. если x - беззнаковый байт).

A.6 Примитивы сравнения
А.6.1. Целочисленное сравнение.
Все элементарные действия целочисленного сравнения возвращают -1 («истина») или 0 («ложь») в качестве результата сравнения. Мы не определили их аналоги в «булевой схеме», которые передали бы управление c0 или c1 в зависимости от результата сравнения. При необходимости такие команды могут быть созданы с помощью RETBOOL.

Также доступны тихие версии элементарных действий целочисленного сравнения, отмеченные префиксом QUIET (B7). Если какое-либо из сравниваемых целых чисел - NaN, результатом тихого сравнения также будет NaN («неопределено»), а не -1 («да») или 0 («нет»), что эффективно поддерживает троичную логику.

• B8 - SGN (x - sgn (x)), вычисляет знак целого числа x: −1, если x < 0, 0, если x = 0, 1, если x > 0.

• B9 - LESS (xy - x < y), возвращает -1, если x < y, в противном случае 0.

• BA - EQUAL (xy - x = y), возвращает -1, если x = y, в противном случае 0.

• BB - LEQ (xy - x ≤ y).

• BC - GREATER (xy - x > y).

• BD - NEQ (xy - x = y), аналог EQUAL; NOT.

• BE - GEQ (xy - x ≥ y), аналог LESS; NOT.

• BF - CMP (xy - sgn (x - y)), вычисляет знак x - y: −1, если x < y, 0, если x = y, 1, если x > y. Целочисленное переполнение произойти не может, если только x или y не NaN.

• C0yy - EQINT yy (x - x = yy) для {\displaystyle -2^{7}\leq yy<2^{7}}{\displaystyle -2^{7}\leq yy<2^{7}}.

• C000 - ISZERO, проверяет, равно ли целое число нулю. Аналог 0= в Forth • C1yy - LESSINT yy (x - x <yy) для {\displaystyle -2^{7}\leq yy<2^{7}}{\displaystyle -2^{7}\leq yy<2^{7}}.

• C100 - ISNEG, проверяет, является ли целое число отрицательным. Аналог 0 < в Forth.

• C101 - ISNPOS, проверяет, является ли целое число положительным.

• C2yy - GTINT yy (x - x> yy) для {\displaystyle -2^{7}\leq yy<2^{7}}{\displaystyle -2^{7}\leq yy<2^{7}}.

• C200 - ISPOS, проверяет, является ли целое число положительным. Аналог 0> в Forth.

• C2FF - ISNNEG, проверяет, является ли целое число неотрицательным.

• C3yy - NEQINT yy (x - x = yy) для {\displaystyle -2^{7}\leq yy<2^{7}}{\displaystyle -2^{7}\leq yy<2^{7}}.

• C4 - ISNAN (x - x = NaN), проверяет, является ли x NaN.

• C5 - CHKNAN (x - x), выдает ошибку арифметического переполнения, если x является NaN.

• C6 - зарезервировано для целочисленного сравнения.

А.6.2. Прочие сравнения.
Большинство элементарных действий «прочих сравнений» фактически сравнивают данные части срезов как битные строки.

• C700 - SEMPTY (s - s = ∅), проверяет, является ли срез s пустым (т.е. не содержит битов данных и ссылок на ячейки).

• C701 - SDEMPTY (s - s ≈ ∅), проверяет, не имеет ли срез s битов данных.

• C702 - SREMPTY (s - r (s) = 0), проверяет, не имеет ли срез s ссылок.

• C703 - SDFIRST (s - {\displaystyle s_{0}=1}{\displaystyle s_{0}=1}), проверяет, является ли первый бит среза s единицей.

• C704 - SDLEXCMP ({\displaystyle ss'-c}{\displaystyle ss'-c}), сравнивает данные s лексикографически с данными {\displaystyle s'}{\displaystyle s'}, возвращая -1, 0 или 1 в зависимости от результата.

• C705 - SDEQ ({\displaystyle ss'-s\approx s'}{\displaystyle ss'-s\approx s'}), проверяет, совпадают ли части данных s и {\displaystyle s'}{\displaystyle s'}, аналог SDLEXCMP; ISZERO.

• C708 - SDPFX ({\displaystyle ss'-?}{\displaystyle ss'-?}), Проверяет, является ли s префиксом {\displaystyle s'}{\displaystyle s'}.

• C709 - SDPFXREV ({\displaystyle ss'-?}{\displaystyle ss'-?}), Проверяет, является ли {\displaystyle s'}{\displaystyle s'} префиксом s, аналог SWAP; SDPFX.

• C70A - SDPPFX ({\displaystyle ss'-?}{\displaystyle ss'-?}), Проверяет, является ли s правильным префиксом {\displaystyle s'}{\displaystyle s'} (т.е. префикс, отличный от {\displaystyle s'}{\displaystyle s'}).

• C70B - SDPPFXREV ({\displaystyle ss'-?}{\displaystyle ss'-?}), Проверяет, является ли {\displaystyle s'}{\displaystyle s'} правильным префиксом s.

• C70C - SDSFX ({\displaystyle ss'-?}{\displaystyle ss'-?}), Проверяет, является ли s суффиксом .

• C70D - SDSFXREV ({\displaystyle ss'}{\displaystyle ss'} -?), Проверяет, является ли {\displaystyle s'}{\displaystyle s'} суффиксом s.

• C70E - SDPSFX ({\displaystyle ss'}{\displaystyle ss'} -?), Проверяет, является ли s правильным суффиксом {\displaystyle s'}{\displaystyle s'}.

• C70F - SDPSFXREV ({\displaystyle ss'}{\displaystyle ss'} -?), Проверяет, является ли {\displaystyle s'}{\displaystyle s'} правильным суффиксом s.

• C710 - SDCNTLEAD0 (s - n), возвращает количество ведущих нулей в s.

• C711 - SDCNTLEAD1 (s - n), возвращает количество ведущих единиц в s.

• C712 - SDCNTTRAIL0 (s - n), возвращает количество конечных нулей в s.

• C713 - SDCNTTRAIL1 (s - n), возвращает количество конечных единиц в s.

A.7 Элементарные действия с ячейками
Примитивы ячеек в основном являются примитивами сериализации ячеек, которые работают с построителями или примитивами десериализации ячеек, которые работают с фрагментами.

А.7.1. Элементарные действия сериализации ячеек.
Все эти элементарные действия сначала проверяют достаточно ли места в Builder, а только потом проверяют диапазон сериализуемого значения.

• C8 - NEWC (- b), создает новый пустой Builder.

• C9 - ENDC (b - c), преобразует Builder в обычную ячейку.

• CAcc - STI cc + 1 (xb - {\displaystyle b'}{\displaystyle b'}), сохраняет cc + 1-битное целое со знаком число x в Builder b для 0 ≤ cc ≤ 255, выдает ошибку проверки диапазона, если x не помещается в cc + 1 бит.

• CBcc - STU cc + 1 (xb - {\displaystyle b'}{\displaystyle b'}), хранит беззнаковое cc + 1-битное целое число x в Builder b. Во всем остальном он аналогичен STI.

• CC - STREF (cb - {\displaystyle b'}{\displaystyle b'}), сохраняет ссылку на ячейку c в Builder b.

• CD - STBREFR или ENDCST (b {\displaystyle b''}{\displaystyle b''} - {\displaystyle b}{\displaystyle b}), аналог ENDC;SWAP; STREF.

• CE - STSLICE (sb - {\displaystyle b'}{\displaystyle b'}), сохраняет срез s в Builder b.

• CF00 - STIX (xbl - {\displaystyle b'}{\displaystyle b'}), сохраняет знаковое l-битное целое число x в b для 0 ≤ l ≤ 257.

• CF01 - STUX (xbl - {\displaystyle b'}{\displaystyle b'}), сохраняет l-битовое целое число x без знака в b для 0 ≤ l ≤ 256.

• CF02 - STIXR (bxl - {\displaystyle b'}{\displaystyle b'}), аналог STIX, но с другим порядком аргументов.

• CF03 - STUXR (bxl - {\displaystyle b'}{\displaystyle b'}), аналог STUX, но с другим порядком аргументов.

• CF04 - STIXQ (xbl - xbf или {\displaystyle b'0}{\displaystyle b'0}), тихая версия STIX. Если в b нет места, то {\displaystyle b'}{\displaystyle b'} = b и f = −1. Если x не умещается в l битах, то {\displaystyle b'}{\displaystyle b'} = b и f = 1. Если операция завершается успешно, {\displaystyle b'}{\displaystyle b'} становится новым Builder, а f = 0. Однако 0 ≤ l ≤ 257, с ошибкой проверки диапазона, если это не так.

• CF05 - STUXQ (xbl - {\displaystyle b'}{\displaystyle b'} f).

• CF06 - STIXRQ (bxl - bxf или {\displaystyle b'}{\displaystyle b'} 0).

• CF07 - STUXRQ (bxl - bxf или {\displaystyle b'}{\displaystyle b'} 0).

• CF08cc - длинная версия STI cc + 1.

• CF09cc - длинная версия STU cc + 1.

• CF0Acc - STIR cc + 1 (bx - {\displaystyle b'}{\displaystyle b'}), аналог SWAP; STI cc + 1.

• CF0Bcc - STUR cc + 1 (bx - {\displaystyle b'}{\displaystyle b'}), аналог SWAP; STU cc + 1.

• CF0Ccc - STIQ cc + 1 (xb - xbf или {\displaystyle b'}{\displaystyle b'} 0).

• CF0Dcc - STUQ cc + 1 (xb - xbf или {\displaystyle b'}{\displaystyle b'} 0).

• CF0Ecc - STIRQ cc + 1 (bx - bxf или {\displaystyle b'}{\displaystyle b'} 0).

• CF0Fcc - STURQ cc + 1 (bx - bxf или {\displaystyle b'}{\displaystyle b'} 0).

• CF10 - длинная версия STREF (cb - {\displaystyle b'}{\displaystyle b'}).

• CF11 - STBREF ({\displaystyle b'}{\displaystyle b'} b - {\displaystyle b'}{\displaystyle b'}), аналог SWAP; STBREFREV.

• CF12 - длинная версия STSLICE (s b - {\displaystyle b'}{\displaystyle b'}).

• CF13 - STB ({\displaystyle b'}{\displaystyle b'} b - {\displaystyle b''}{\displaystyle b''}), добавляет все данные из Builder b в Builder b.

• CF14 - STREFR (bc - {\displaystyle b'}{\displaystyle b'}).

• CF15 - STBREFR (b {\displaystyle b'}{\displaystyle b'} - {\displaystyle b''}{\displaystyle b''}), удлиненная кодировка STBREFR.

• CF16 - STSLICER (bs - b').

• CF17 - STBR (bb - b), объединяет двух Builder, аналог SWAP; STB.

• CF18 - STREFQ (cb - cb −1 или {\displaystyle b'}{\displaystyle b'} 0).

• CF19 - STBREFQ ({\displaystyle b'}{\displaystyle b'} b - {\displaystyle b'}{\displaystyle b'} b −1 или {\displaystyle b'}{\displaystyle b'} 0).

• CF1A - STSLICEQ (sb - sb −1 или {\displaystyle b'}{\displaystyle b'} 0).

• CF1B - STBQ ({\displaystyle b'}{\displaystyle b'} b - {\displaystyle b'}{\displaystyle b'} b −1 или {\displaystyle b''}{\displaystyle b''} 0).

• CF1C - STREFRQ (bc - bc −1 или {\displaystyle b'}{\displaystyle b'} 0).

• CF1D - STBREFRQ ( b - b −1 или b 0).

• CF1E - STSLICERQ (bs - bs −1 или {\displaystyle b''}{\displaystyle b''} 0).

• CF1F - STBRQ ( b {\displaystyle b'}{\displaystyle b'} - b {\displaystyle b'}{\displaystyle b'} −1 или {\displaystyle b''}{\displaystyle b''} 0).

• CF20 - STREFCONST, аналог PUSHREF; STREFR.

• CF21 - STREF2CONST, аналог STREFCONST; STREFCONST.

• CF23 - ENDXC (bx - c), если {\displaystyle x\neq 0}{\displaystyle x\neq 0}, создает особую ячейку (см. 3.1.2 ) от Builder b. Тип особой ячейки хранится в первых 8 битах b. Если x = 0, это аналог ENDC. В противном случае выполняются некоторые проверки валидности данных и ссылок b, только после этого создается особая ячейка.

• CF28 - STILE4 (xb - {\displaystyle b'}{\displaystyle b'}), хранит 32-битное целое число со знаком с прямым порядком байтов.

• CF29 - STULE4 (xb - {\displaystyle b'}{\displaystyle b'}), хранит беззнаковое 32-битное целое число с прямым порядком байтов.

• CF2A - STILE8 (xb - {\displaystyle b'}{\displaystyle b'}), хранит 64-битное целое число со знаком с прямым порядком байтов.

• CF2B - STULE8 (xb - {\displaystyle b'}{\displaystyle b'}), хранит беззнаковое 64-битное целое число с прямым порядком байтов.

• CF30 - BDEPTH (b - x), возвращает глубину Builder b. Если в b не хранятся ссылки на ячейки, тогда x = 0; в противном случае x равен 1 плюс максимальная глубина ячеек, указанная в b.

• CF31 - BBITS (b - x), возвращает количество уже сохраненных битов данных в Builder b.

• CF32 - BREFS (b - y), возвращает количество уже имеющихся ссылок на ячейки, которые хранятся в b.

• CF33 - BBITREFS (b - xy), возвращает количество битов данных ссылок на ячейки в b.

• CF35 - BREMBITS (b - {\displaystyle x'}{\displaystyle x'}), возвращает количество битов данных, которые можно сохранить в b.

• CF36 - BREMREFS (b - {\displaystyle y'}{\displaystyle y'}).

• CF37 - BREMBITREFS (b - {\displaystyle x'y'}{\displaystyle x'y'}).

• CF38cc - BCHKBITS cc + 1 (b -), проверяет, можно ли сохранить cc + 1 бит в b, где 0 ≤ cc ≤ 255.

• CF39 - BCHKBITS (bx -), проверяет, можно ли сохранить x бит в b, 0 ≤ x ≤ 1023. Если в b нет места для дополнительных x бит, или если x не в диапазоне 0 ... 1023, генерируется ошибка.

• CF3A - BCHKREFS (by -), проверяет, можно ли сохранить ссылки y в b, 0 ≤ y ≤ 7.

• CF3B - BCHKBITREFS (bxy -), проверяет, можно ли сохранить x бит и y ссылок в b, 0 ≤ x ≤ 1023, 0 ≤ y ≤ 7.

• CF3Ccc - BCHKBITSQ cc + 1 (b -?), Проверяет, можно ли сохранить cc + 1 бит в b, где 0 ≤ cc ≤ 255.

• CF3D - BCHKBITSQ (bx -?), Проверяет, можно ли сохранить x бит в b, где 0 ≤ х ≤ 10 23.

• CF3E - BCHKREFSQ (by -?), Проверяет, можно ли сохранить y ссылок в b, 0 ≤ y ≤ 7.

• CF3F - BCHKBITREFSQ (bxy -?), Проверяет, можно ли сохранить x бит и y ссылок в b, 0 ≤ x ≤ 1023, 0 ≤ y ≤ 7.

• CF40 - STZEROES (bn - {\displaystyle b'}{\displaystyle b'}), сохраняет n двоичных нулей в Builder b.

• CF41 - STONES (bn - {\displaystyle b'}{\displaystyle b'}), сохраняет n двоичных единиц в Builder b.

• CF42 - STSAME (bnx - {\displaystyle b'}{\displaystyle b'}), сохраняет n двоичных x (0 ≤ x ≤ 1) в Builder b.

• CFC0_xysss - STSLICECONST sss (b - {\displaystyle b'}{\displaystyle b'}), сохраняет постоянный подсрез sss, состоящий из 0 ≤ x ≤ 3 ссылок и до 8y + 1 бит данных, 0 ≤ y ≤ 7. Допускается бит завершения.

• CF81 - STSLICECONST «0» или STZERO (b - {\displaystyle b'}{\displaystyle b'}), сохраняет один двоичный ноль.

• CF83 - STSLICECONST «1» или STONE (b - {\displaystyle b'}{\displaystyle b'}), сохраняет одну двоичную единицу.

• CFA2 - аналог STREFCONST.

• CFA3 – почти аналогичен STSLICECONST '1'; STREFCONST.

• CFC2 - аналог STREF2CONST.

• CFE2 - STREF3CONST.

А.7.2. Элементарные действия десериализации ячеек.
• D0 - CTOS (c - s), преобразует ячейку в срез. Обратите внимание, что c – либо обычная, либо особая ячейка (см. 3.1.2 ), которая автоматически загружается, чтобы получить обычную ячейку {\displaystyle c'}{\displaystyle c'}, позже преобразованную в срез.

• D1 - ENDS (s -), удаляет срез s из стека и выдает ошибку, если он не пуст.

• D2cc - LDI cc + 1 (s – x {\displaystyle s'}{\displaystyle s'}), загружает (парсит) cc + 1 битное целое со знаком число x из Среза s и возвращает остаток от s как {\displaystyle s'}{\displaystyle s'}.

• D3cc - LDU cc + 1 (s - x {\displaystyle s'}{\displaystyle s'} ), загружает беззнаковое cc + 1-битное целое число x из среза s.

• D4 - LDREF (s – c {\displaystyle s'}{\displaystyle s'}), загружает ссылку c из s.

• D5 - LDREFRTOS (s - {\displaystyle s'}{\displaystyle s'} {\displaystyle s''}{\displaystyle s''}), аналог LDREF; SWAP; CTOS.

• D6cc - LDSLICE cc + 1 (s - {\displaystyle s''}{\displaystyle s''} {\displaystyle s'}{\displaystyle s'}), отрезает следующий бит cc + 1 s в отдельный срез {\displaystyle s''}{\displaystyle s''}.

• D700 - LDIX (sl - x {\displaystyle s'}{\displaystyle s'}), загружает l-битное со знаком (0 ≤ l ≤ 257) целое число x из среза s и возвращает остаток s как {\displaystyle s'}{\displaystyle s'}.

• D701 - LDUX (sl - x {\displaystyle s'}{\displaystyle s'}), загружает l-битовое целое число x без знака из (первых l бит) s, 0 ≤ l ≤ 256.

• D702 - PLDIX (sl - x), предварительно загружает l-битное целое число со знаком из среза s, 0 ≤ l ≤ 257.

• D703 - PLDUX (sl - x), предварительно загружает l-битное целое число без знака из s, 0 ≤ l ≤ 256.

• D704 - LDIXQ (sl – x {\displaystyle s'}{\displaystyle s'} −1 или s 0), тихая версия LDIX: загружает L-битное целое число со знаком из s, аналогично LDIX, но возвращает флажок успешного завершения, равный-1 в случае успеха или 0 в случае неудачи (если s не имеет l бит), а не генерирует ошибку исчерпани ячейки.

• D705 - LDUXQ (sl – x {\displaystyle s'}{\displaystyle s'} −1 или s 0), тихая версия LDUX.

• D706 - PLDIXQ (sl - x −1 или 0), тихая версия PLDIX.

• D707 - PLDUXQ (sl - x −1 или 0), тихая версия PLDUX.

• D708cc - LDI cc + 1 (s - x {\displaystyle s'}{\displaystyle s'}), длинная кодировка LDI.

• D709cc - LDU cc + 1 (s – x {\displaystyle s'}{\displaystyle s'}), длинная кодировка LDU.

• D70Acc - PLDI cc + 1 (s - x), предварительно загружает cc + 1-битное целое со знаком число из s.

• D70Bcc - PLDU cc + 1 (s - x), предварительно загружает беззнаковое cc + 1-битное целое число из s.

• D70Ccc - LDIQ cc + 1 (s – x {\displaystyle s'}{\displaystyle s'} −1 или s 0), тихая версия LDI.

• D70Dcc - LDUQ cc + 1 (s - x {\displaystyle s'}{\displaystyle s'} −1 или s 0), тихая версия LDU.

• D70Ecc - PLDIQ cc + 1 (s - x −1 или 0), тихая версия PLDI.

• D70Fcc - PLDUQ cc + 1 (s - x −1 или 0), тихая версия PLDU.

• D714_c - PLDUZ 32 (c + 1) (s - sx), предварительно загружает первые 32 (c + 1) бита Среза s в целое число x без знака для 0 ≤ c ≤ 7. Если s короче требуемой длины, недостающие биты считаются равными нулю. Данная операция должна использоваться вместе с IFBITJMP и аналогичными командами.

• D718 - LDSLICEX (s l – {\displaystyle s'}{\displaystyle s'} {\displaystyle s''}{\displaystyle s''}), загружает первые 0 ≤ l ≤ 1023 бита из Среза s в Срез {\displaystyle s''}{\displaystyle s''}, остаток s возвращается как {\displaystyle s'}{\displaystyle s'}.

• D719 - PLDSLICEX (s l - {\displaystyle s''}{\displaystyle s''}), возвращает первые 0 ≤ l ≤ 1023 бита s как {\displaystyle s''}{\displaystyle s''}.

• D71A - LDSLICEXQ (s l – {\displaystyle s''}{\displaystyle s''} {\displaystyle s'}{\displaystyle s'} −1 или s 0), тихая версия LDSLICEX.

• D71B - PLDSLICEXQ ( sl - {\displaystyle s'}{\displaystyle s'} −1 или 0), тихая версия LDSLICEXQ.

• D71Ccc - LDSLICE cc + 1 (s – {\displaystyle s''}{\displaystyle s''} {\displaystyle s'}{\displaystyle s'}), более длинная кодировка LDSLICE.

• D71Dcc - PLDSLICE cc + 1 (s - {\displaystyle s''}{\displaystyle s''}), возвращает первые 0 <cc + 1 ≤ 256 бит s как {\displaystyle s''}{\displaystyle s''}.

• D71Ecc - LDSLICEQ cc + 1 (s - {\displaystyle s''}{\displaystyle s''} {\displaystyle s'}{\displaystyle s'} −1 или s 0), тихая версия LDSLICE.

• D71Fcc - PLDSLICEQ cc + 1 (s - {\displaystyle s''}{\displaystyle s''} −1 или 0), тихая версия PLDSLICE.

• D720 - SDCUTFIRST (s l - {\displaystyle s'}{\displaystyle s'}), возвращает первые 0 ≤ l ≤ 1023 бита s. Аналог PLDSLICEX.

• D721 - SDSKIPFIRST (s l - {\displaystyle s'}{\displaystyle s'}), возвращает все, кроме первых 0 ≤ l ≤ 1023 бит s. Аналог LDSLICEX; NIP.

• D722 - SDCUTLAST (s l - {\displaystyle s'}{\displaystyle s'}), возвращает последние 0 ≤ l ≤ 1023 бита s.

• D723 - SDSKIPLAST (s l – {\displaystyle s'}{\displaystyle s'}), возвращает все, кроме последних 0 ≤ l ≤ 1023 бит s.

• D724 - SDSUBSTR (s l {\displaystyle l'}{\displaystyle l'} - {\displaystyle s'}{\displaystyle s'}), возвращает 0 ≤ l ≤ 1023 бит s, начиная с 0 ≤ l ≤ 1023, таким образом извлекая битную подстроку из данных s.

• D726 - SDBEGINSX (s {\displaystyle s'}{\displaystyle s'} - {\displaystyle s''}{\displaystyle s''}), проверяет, начинается ли s с (битов) {\displaystyle s'}{\displaystyle s'} и удаляет {\displaystyle s'}{\displaystyle s'} из s в случае успеха. В ином случае генерируется ошибка десериализации ячейки. Элементарное действие SDPFXREV можно считать тихой версией SDBEGINSX.

• D727 - SDBEGINSXQ (s {\displaystyle s'}{\displaystyle s'} - {\displaystyle s''}{\displaystyle s''} −1 или s 0), тихая версия SDBEGINSX.

• D72A_xsss - SDBEGINS (s - {\displaystyle s''}{\displaystyle s''}, проверяет, начинается ли s с постоянной битной строки sss длиной 8x + 3 (с предполагаемым битом продолжения), где 0 ≤ x ≤ 127, в случае успеха удаляет sss из s.

• D72802 - SDBEGINS '0' (s - {\displaystyle s''}{\displaystyle s''}), проверяет, начинается ли s с двоичного нуля.

• D72806 - SDBEGINS '1' (s - {\displaystyle s''}{\displaystyle s''}), проверяет, начинается ли s с двоичной единицы.

• D72E_xsss - SDBEGINSQ (s - {\displaystyle s''}{\displaystyle s''} −1 или s 0), тихая версия SDBEGINS.

• D730 - SCUTFIRST (s l r - {\displaystyle s'}{\displaystyle s'}), возвращает первые 0 ≤ l ≤ 1023 бита и первые 0 ≤ r ≤ 4 ссылок s.

• D731 - SSKIPFIRST (s l r - {\displaystyle s'}{\displaystyle s'}).

• D732 - SCUTLAST (s l r - {\displaystyle s'}{\displaystyle s'}), возвращает последние 0 ≤ l ≤ 1023 бита данных и последние 0 ≤ r ≤ 4 ссылки s.

• D733 - SSKIPLAST (s l r - {\displaystyle s'}{\displaystyle s'}).

• D734 - SUBSLICE (s l r {\displaystyle l'}{\displaystyle l'} {\displaystyle r'}{\displaystyle r'} - {\displaystyle s'}{\displaystyle s'}), возвращает 0 ≤ {\displaystyle l'}{\displaystyle l'} ≤ 1023 бит и 0 ≤ {\displaystyle r'}{\displaystyle r'} ≤ 4 ссылки из Среза s, пропустив первый 0 ≤ l ≤ 1023 бит и первые 0 ≤ r ≤ 4 ссылки.

• D736 - SPLIT (s l r – {\displaystyle s'}{\displaystyle s'} {\displaystyle s''}{\displaystyle s''}), разделяет первые 0 ≤ l ≤ 1023 бит данных и первые 0 ≤ r ≤ 4 ссылки из s в {\displaystyle s'}{\displaystyle s'}, возвращая остаток от s как {\displaystyle s''}{\displaystyle s''}.

• D737 - SPLITQ (s l r – {\displaystyle s'}{\displaystyle s'} {\displaystyle s''}{\displaystyle s''} −1 или s 0), тихая версия SPLIT.

• D739 - XCTOS (c – s ?), Превращает обычную или особую ячейку в Срез, как обычную ячейку. Возвращается флажок, указывающий, что ячейка с особая. В этом случае ее тип позже может быть десериализован из первых восьми бит s.

• D73A - XLOAD (c - {\displaystyle c'}{\displaystyle c'}), загружает особую ячейку {\displaystyle c}{\displaystyle c} и возвращает обычную ячейку {\displaystyle c'}{\displaystyle c'}. Если c уже обычная, действий не осуществляется. Если c не может быть загружена, генерируется ошибка.

• D73B - XLOADQ (c - {\displaystyle c'}{\displaystyle c'} −1 или c 0), загружает особую ячейку c как XLOAD, но возвращает 0 в случае ошибки.

• D741 - SCHKBITS (s l -), проверяет наличие минимума l бит данных в срезе s. Если минимум отсутствует, генерируется ошибка десериализации ячейки (т. е. исчерпание ячейки).

• D742 - SCHKREFS (s r -), проверяет, присутствует ли не менее r ссылок в Срезе s.

• D743 - SCHKBITREFS (s l r -), проверяет наличие минимального количества l бит данных и ссылок r в Срезе s.

• D745 - SCHKBITSQ (s l -?), Проверяет наличие минимального количества l бит данных в Срезе s.

• D746 - SCHKREFSQ (s r -?), Проверяет наличие минимального количества r ссылок в Срезе s.

• D747 - SCHKBITREFSQ (s l r -?), Проверяет наличие минимального количества l бит данных и ссылок r в Срезе s.

• D748 - PLDREFVAR (s n - c), возвращает n-ю ссылку на ячейку Среза s для 0 ≤ n ≤ 3.

• D749 - SBITS (s - l), возвращает количество бит данных в Срезе s.

• D74A - SREFS (s - r), возвращает количество ссылок в Срезе s.

• D74B - SBITREFS (s – l r), возвращает количество битов данных и количество ссылок в s.

• D74E_n - PLDREFIDX n (s - c), возвращает n-ю ссылку на ячейку Среза s, где 0 ≤ n ≤ 3.

• D74C - PLDREF (s - c), предварительно загружает первую ссылку на ячейку среза.

• D750 - LDILE4 (s – x {\displaystyle s'}{\displaystyle s'}), загружает 32-разрядное целое число со знаком с прямым порядком байтов.

• D751 - LDULE4 (s – x {\displaystyle s'}{\displaystyle s'}), загружает 32-битное целое число без знака с прямым порядком байтов.

• D752 - LDILE8 (s – x {\displaystyle s'}{\displaystyle s'}), загружает 64-битное целое число со знаком с прямым порядком байтов.

• D753 - LDULE8 (s – x {\displaystyle s'}{\displaystyle s'}), загружает 64-битное целое число без знака с прямым порядком байтов.

• D754 - PLDILE4 (s - x), предварительно загружает 32-разрядное целое число со знаком с прямым порядком байтов.

• D755 - PLDULE4 (s - x), предварительно загружает 32-битное целое число без знака.

• D756 - PLDILE8 (s - x), предварительно загружает 64-битное целое число со знаком прямого порядка байтов.

• D757 - PLDULE8 (s - x), предварительно загружает 64-битное целое число без знака с прямым порядком байтов.

• D758 - LDILE4Q (s – x {\displaystyle s'}{\displaystyle s'} −1 или s 0), тихо загружает 32-битное целое число со знаком с прямым порядком байтов.

• D759 - LDULE4Q (s – x {\displaystyle s'}{\displaystyle s'} −1 или s 0), тихо загружает 32-битное целое число без знака с прямым порядком байтов.

• D75A - LDILE8Q (s – x {\displaystyle s'}{\displaystyle s'} −1 или s 0), тихо загружает 64-битное целое число со знаком с прямым порядком байтов.

• D75B - LDULE8Q (s – x {\displaystyle s'}{\displaystyle s'} −1 или s 0), тихо загружает 64-битное целое число без знака с прямым порядком байтов.

• D75C - PLDILE4Q (s - x −1 или 0), тихо предварительно загружает 32-битное целое число со знаком с прямым порядком байтов.

• D75D - PLDULE4Q (s - x −1 или 0), тихо предварительно загружает 32-битное целое число без знака с прямым порядком байтов.

• D75E - PLDILE8Q (s - x −1 или 0), тихо предварительно загружает 64-битное целое число со знаком с прямым порядком байтов.

• D75F - PLDULE8Q (s - x −1 или 0), тихо предварительно загружает 64-битное целое число без знака с прямым порядком байтов.

• D760 - LDZEROES (s – n {\displaystyle s'}{\displaystyle s'}), возвращает количество n ведущих нулевых битов в s и удаляет эти биты из s.

• D761 - LDONES (s – n ), возвращает количество n единичных битов в s и удаляет эти биты из s.

• D762 - LDSAME (s x – n {\displaystyle s'}{\displaystyle s'}), возвращает количество n ведущих битов, равное 0 ≤ x ≤ 1 в s и удаляет эти биты из s.

• D764 - SDEPTH (s - x), возвращает глубину Среза s. Если s не имеет ссылок, тогда x = 0; в противном случае x = единице плюс максимальная глубина ячеек, на которые есть ссылки в s.

• D765 - CDEPTH (c - x), возвращает глубину ячейки c. Если c не имеет ccskjr, тогда x = 0; в противном случае x = единице плюс максимальная глубина ячеек, на которые есть ссылки в с. Если c – Null, а не Cell, возвращается ноль.

A.8 Элементарные действия продолжения и управляющей логики
А.8.1. Безусловные элементарные действия управляющей логики.
• D8 - EXECUTE или CALLX (c -), вызывает или выполняет продолжение c (т.е. {\displaystyle {cc}\leftarrow c\circ _{0}{cc}}{\displaystyle {cc}\leftarrow c\circ _{0}{cc}}).

• D9 - JMPX (c -), перескакивает или передает управление продолжению c (т. е. {\displaystyle {cc}\leftarrow c\circ _{0}{c0}}{\displaystyle {cc}\leftarrow c\circ _{0}{c0}}, точнее ({\displaystyle {cc}\leftarrow (c\circ _{0}{c0})\circ _{1}{c1}}{\displaystyle {cc}\leftarrow (c\circ _{0}{c0})\circ _{1}{c1}}). Остаток предыдущего текущего продолжения cc отбрасывается.

• DApr - CALLXARGS p, r (c -), вызывает продолжение c с параметрами p, ожидая r возвращаемых значений, 0 ≤ p ≤ 15, 0 ≤ r ≤ 15.

• DB0p - CALLXARGS p, −1 (c -), вызывает продолжение c с 0 ≤ p ≤ 15 параметрами, ожидая произвольное количество возвращаемых значений.

• DB1p - JMPXARGS p (c -), переходит к продолжению c, передавая только верхние 0 ≤ p ≤ 15 значений из текущего стека (остаток текущего стека отбрасывается).

• DB2r - RETARGS r, возвращается к c0, при 0 ≤ r ≤ 15 принятых возвращаемых значений из текущего стека.

• DB30 - RET или RETTRUE, возврат к продолжению в c0 (т.е. образует cc ← c0). Остаток текущего продолжения cc отбрасывается. Близкий аналог PUSH c0; JMPX.

• DB31 - RETALT или RETFALSE, возвращается к продолжению в c1 (т.е. cc ← c1). Близкий аналог PUSH c1; JMPX.

• DB32 - BRANCH или RETBOOL (f -), выполняет RETTRUE, если целое число {\displaystyle f\neq 0}{\displaystyle f\neq 0}, или RETFALSE, если {\displaystyle f=0}{\displaystyle f=0}.

• DB34 - CALLCC (c -), вызов с текущим продолжением, передает управление c, помещая старое значение cc в стек c (вместо того, чтобы отбрасывать его или записывать в новый c0).

• DB35 - JMPXDATA (c -), аналог CALLCC, но остаток текущего продолжения (прежнее значение cc) преобразуется в Срез, а затем проталкивается в стек c.

• DB36pr - CALLCCARGS p, r (c -), аналог CALLXARGS, но проталкивает прежнее значение cc (вместе с верхними 0 ≤ p ≤ 15 значениями из исходного стека) в стек вызванного продолжения c, где cc.nargs −1 ≤ r ≤ 14.

• DB38 - CALLXVARARGS (c p r -), аналог CALLXARGS, но принимает −1 ≤ p, r ≤ 254 из стека. Следующие три операции также берут p и r из стека в диапазоне -1 ... 254.

• DB39 - RETVARARGS (p r -), аналог RETARGS.

• DB3A - JMPXVARARGS (c p r -), аналог JMPXARGS.

• DB3B - CALLCCVARARGS (c p r -), аналог CALLCCARGS.

• DB3C - CALLREF, аналог PUSHREFCONT; CALLX.

• DB3D - JMPREF, аналог PUSHREFCONT; JMPX.

• DB3E - JMPREFDATA, аналог PUSHREFCONT; JMPXDATA.

• DB3F - RETDATA, аналог PUSH c0; JMPXDATA. Таким образом, остаток текущего продолжения конвертируется в Срез и возвращается вызывающему оператору.

А.8.2. Условные элементарные действия управляющей логики.
• DC - IFRET (f -), выполняет RET, но только если целое число f не равно нулю. Если f - NaN, выдает ошибку целочисленного переполнения.

• DD - IFNOTRET (f -), выполняет RET, но только если целое число f равно нулю.

• DE - IF (f c -), выполняет EXECUTE для c (т.е. выполняет c), но только если целое число f не равно нулю. В противном случае оба значения отбрасываются.

• DF - IFNOT (f c -), выполняет продолжение c, но только если целое число f равно нулю. В противном случае оба значения отбрасываются.

• E0 - IFJMP (f c -), переходит к c (аналог JMPX), но только если f не равно нулю.

• E1 - IFNOTJMP (f c -), переходит к c (аналог JMPX), но только если f равно нулю.

• E2 - IFELSE (f c {\displaystyle c'}{\displaystyle c'} -), если целое f не равно нулю, выполняет c, в противном случае выполняет {\displaystyle c'}{\displaystyle c'}. Аналог CONDSELCHK; EXECUTE.

• E300 - IFREF (f -), аналог PUSHREFCONT; IF, но ссылка на ячейку фактически не загружается в срез и затем преобразуется в обычное продолжение, если f = 0. Аналогичные замечания относятся и к следующим трем элементарным действиям.

• E301 - IFNOTREF (f -), аналог PUSHREFCONT; IFNOT.

• E302 - IFJMPREF (f -), аналог PUSHREFCONT; IFJMP.

• E303 - IFNOTJMPREF (f -), аналог PUSHREFCONT; IFNOTJMP.

• E304 - CONDSEL (f x y - x или y), если целое число f не равно нулю, возвращает x, в противном случае возвращает y. Обратите внимание, что для x и у не выполняется проверка типа; по сути, это больше похоже на условную стековую команду. Близкий аналог ROT; ISZERO; INC; ROLLX; NIP.

• E305 - CONDSELCHK (f x y - x или y), аналог CONDSEL, но сначала проверяет, одного ли типа x и y.

• E308 - IFRETALT (f -), выполняет RETALT, если целое число f = 0.

• E309 - IFNOTRETALT (f -), выполняет RETALT, если целое число f = 0.

• E30D - IFREFELSE (fc -), аналог PUSHREFCONT; SWAP; IFELSE, но ссылка на ячейку фактически не загружается в срез, а затем преобразовывается в обычное продолжение, если f = 0. Аналогичные замечания относятся к следующим двум элементарным действиям: Ячейки преобразуются в продолжения только при необходимости.

• E30E - IFELSEREF (f c -), аналог PUSHREFCONT; IFELSE.

• E30F - IFREFELSEREF (f -), аналог PUSHREFCONT; PUSHREFCONT; IFELSE.

• E310 – E31F - зарезервировано для циклов с операторами break, ср. A.8.3 ниже.

• E39_n - IFBITJMP n (x c - x), проверяет, установлен ли бит 0 ≤ n ≤ 31 в целом числе x, и если да, выполняет JMPX для продолжения c. Значение x остается в стеке.

• E3B_n - IFNBITJMP n (x c - x), переходит к c, если бит 0 ≤ n ≤ 31 не задан целым числом x.

• E3D_n - IFBITJMPREF n (x - x), выполняет JMPREF, если бит 0 ≤ n ≤ 31 задан целым числом x.

• E3F_n - IFNBITJMPREF n (x - x), выполняет JMPREF, если бит 0 ≤ n ≤ 31 не задан целым числом x.

А.8.3. Элементарные действия управляющей логики: циклы.
Большинство перечисленных элементарных действий реализованы с помощью особых продолжений, таких как ec_until (см. 4.1.5), тело цикла и исходное текущее продолжением сс хранится как аргумент этого особого продолжения. Чаще всего создается подходящее особое продолжение, которое затем сохраняется в сейвлисте продолжения тела цикла как c0; после этого измененное тело цикла загружается в cc и выполняется обычным образом. Все эти элементарные действия имеют версии *BRK, адаптированные для выхода из цикла; они дополнительно устанавливают c1 на исходное текущее продолжение (или исходное c0 для версий *ENDBRK) и сохраняют старый c1 в сейвлисте исходного текущего продолжения (или исходный c0 для версий * ENDBRK).

• E4 - REPEAT (nc -), выполняет продолжение c n-раз, если целое n неотрицательно. Если n ≥ {\displaystyle 2^{31}}{\displaystyle 2^{31}} или n < {\displaystyle -2^{31}}{\displaystyle -2^{31}} , генерирует ошибку проверки диапазона. Обратите внимание, что RET внутри кода c работает как continue, а не как break. Для выхода из цикла следует использовать либо альтернативные (экспериментальные) циклы, либо альтернативный RETALT (вместе с SETEXITALT перед циклом).

• E5 - REPEATEND (n -), аналог REPEAT, но применяется к текущему продолжению cc.

• E6 - UNTIL (c -), выполняет продолжение c, затем выдает целое число x из получившегося стека. Если x равен нулю, выполняет еще одну итерацию цикла. Фактическая реализация этого элементарного действия включает в себя особое продолжение ec_until (см. 4.1.5 ) с аргументами тела цикла (продолжения c) и исходного текущего продолжения cc. Это особое продолжение затем сохраняется в сейвлисте c как c.c0, а модифицированный c выполняется. Прочие элементарные действия цикла реализуются аналогично с помощью подходящих особых продолжений.

• E7 - UNTILEND (-), аналог UNTIL, но выполняет текущее продолжение cc в цикле. Когда условие выхода из цикла выполнено, выполняет RET.

• E8 - WHILE ( c -), выполняет и извлекает целое число x из полученного стека. Если x равно нулю, цикл существует и передает управление исходному cc. Если x не равно нулю, выполняется c, а затем начинается новая итерация.

• E9 - WHILEEND (c' -), аналог WHILE, но использует текущее продолжение cc в качестве тела цикла.

• EA - AGAIN (c -), аналог REPEAT, но выполняет c бесконечно много раз. RET только начинает новую итерацию бесконечного цикла, из которого можно выйти только с помощью генерации ошибки или RETALT (или явного JMPX).

• EB - AGAINEND (-), аналог AGAIN, но выполняется в отношении текущего продолжения cc.

• E314 - REPEATBRK (n c -), аналог REPEAT, но устанавливает c1 в исходный cc после сохранения старого значения c1 в сейвлисте исходного cc. Таким образом, RETALT может использоваться для выхода из цикла.

• E315 - REPEATENDBRK (n -), аналог REPEATEND, но устанавливает c1 как исходный c0 после сохранения старого значения c1 в сейвлисте исходного c0. Аналог SAMEALTSAVE; REPEATEND.

• E316 - UNTILBRK (c -), аналог UNTIL, но изменяет c1, как и REPEATBRK.

• E317 - UNTILENDBRK (-), аналог SAMEALTSAVE; UNTILEND.

• E318 - WHILEBRK ({\displaystyle c'}{\displaystyle c'} c -), аналог WHILE, но изменяет c1, как и REPEATBRK.

• E319 - WHILEENDBRK (c -), аналог SAMEALTSAVE; WHILEEND.

• E31A - AGAINBRK (c -), аналог AGAIN, но изменяет c1, как b REPEATBRK.

• E31B - AGAINENDBRK (-), аналог SAMEALTSAVE; AGAINAND.

А.8.4. Управление стеком продолжений.
• ECrn - SETCONTARGS r, n ({\displaystyle x_{1}x_{2}\dots x_{r}c-c'}{\displaystyle x_{1}x_{2}\dots x_{r}c-c'}), аналог SETCONTARGS r, но устанавливает c.nargs равным окончательному размеру стека {\displaystyle c'}{\displaystyle c'} плюс n. То есть, превращает c в замкнутое выражение или частично применяемую функцию, где 0 ≤ n ≤ 14 аргументов отсутствуют.

• EC0n - SETNUMARGS n или SETCONTARGS 0, n (c - {\displaystyle c'}{\displaystyle c'}), устанавливает c.nargs равным n плюс текущая глубина стека c, где 0 ≤ n ≤ 14. Если c.nargs равен неотрицательному значению, никаких действий не выполняется.

• ECrF - SETCONTARGS r или SETCONTARGS r, −1 ({\displaystyle x_{1}x_{2}\dots x_{r}c-c'}{\displaystyle x_{1}x_{2}\dots x_{r}c-c'}), помещает 0 ≤ r ≤ 15 значений {\displaystyle x_{1}\ldots x_{r}}{\displaystyle x_{1}\ldots x_{r}} в стек (копию) продолжение z, начиная с {\displaystyle x_{1}}{\displaystyle x_{1}}. Если окончательная глубина стека c оказывается больше c.nargs, генерируется ошибка переполнения стека.

• ED0p - RETURNARGS p (-), оставляет только верхние 0 ≤ p ≤ 15 значений в текущем стеке (близкий аналог ONLYTOPX), а все неиспользованные нижние значения не отбрасываются, а сохраняются в продолжении c0, как и в SETCONTARGS.

• ED10 - RETURNVARARGS (p -), аналог RETURNARGS, но с целым числом 0 ≤ p ≤ 255 из стека.

• ED11 - SETCONTVARARGS ({\displaystyle x_{1}x_{2}\dots x_{r}crn-c'}{\displaystyle x_{1}x_{2}\dots x_{r}crn-c'}), аналог SETCONTARGS, но с 0 ≤ r ≤ 255 и −1 ≤ n ≤ 255, взятыми из стека.

• ED12 - SETNUMVARARGS (c n - {\displaystyle c'}{\displaystyle c'}), где −1 ≤ n ≤ 255. Если n = −1, никаких действий не производится ({\displaystyle c'=c}{\displaystyle c'=c}). В остальном аналогично SETNUMARGS n, но с n, взятым из стека.

А.8.5. Создание простых продолжений и завершений.
• ED1E - BLESS (s - c), превращает Срез s в простое обычное продолжение c, где c.code = s, а сьек и сейвлист пусты.

• ED1F - BLESSVARARGS ({\displaystyle x_{1}\dots x_{r}srn-c}{\displaystyle x_{1}\dots x_{r}srn-c}), аналог ROT; BLESS; ROTREV; SETCONTVARARGS.

• EErn - BLESSARGS r, n ({\displaystyle x_{1}\dots x_{r}s-c}{\displaystyle x_{1}\dots x_{r}s-c}), где 0 ≤ r ≤ 15, −1 ≤n ≤ 14, аналог BLESS; SETCONTARGS r, n. Значение n представлено в команде 4-битным целым числом n mod 16.

• EE0n - BLESSNUMARGS n или BLESSARGS 0, n (s - c), также преобразует Срез s в Продолжение c, но c.nargs равнен 0 ≤ n ≤ 14.

А.8.6. Операции с продолжением сейвлистов и регистрами управления.
• ED4i - PUSH c (i) или PUSHCTR c (i) (- x), проталкивает текущее значение регистра управления c (i). Если регистр управления не поддерживается в текущей кодовой странице, или не обладает значением, генерируется ошибка.

• ED44 - PUSH c4 или PUSHROOT, проталкивает ссылку на ячейку «корень глобальных данных», обеспечивая доступ к постоянным данным смарт-контрактов.

• ED5i - POP c (i) или POPCTR c (i) (x -), извлекает значение x из стека и сохраняет его в регистре управления c (i), если поддерживается текущей кодовой страницей. Обратите внимание, что, если контрольный регистр принимает только значения определенного типа, может сгенерироваться ошибка проверки типа.

• ED54 - POP c4 или POPROOT, устанавливает ссылку на ячейку «корень глобальных данных», позволяя изменять постоянные данные смарт-контракта.

• ED6i - SETCONT c (i) или SETCONTCTR c (i) (x c - {\displaystyle c'}{\displaystyle c'}), сохраняет x в сейвлисте продолжения c как c (i) и возвращает получившееся продолжение c'. Практически все операции с продолжениями можно выразить командами SETCONTCTR, POPCTR и PUSHCTR.

• ED7i - SETRETCTR c (i) (x -), аналог PUSH c0; SETCONTCTR c (i); POP c0.

• ED8i - SETALTCTR c (i) (x -), аналог PUSH c1; SETCONTCTR c (i); POP c0.

• ED9i - POPSAVE c (i) или POPCTRSAVE c (i) (x -), аналог POP c (i), но также сохраняет прежнее значение c (i) в продолжение c0. Аналог (за исключением ошибок) SAVECTR c (i); POP c (i).

• EDAi - SAVE c (i) или SAVECTR c (i) (-), сохраняет текущее значение c (i) в сейвелист продолжения c0. Если запись c (i) уже есть присутствует в сейвелисте c0, никаких действий не осуществляется. Аналог PUSH c (i); SETRETCTR c (i).

• EDBi - SAVEALT c (i) или SAVEALTCTR c (i) (-), аналог SAVE c (i), но сохраняет текущее значение c (i) в сейвлисте c1, а не c0.

• EDCi - SAVEBOTH c (i) или SAVEBOTHCTR c (i) (-), аналог DUP; SAVE c (i); SAVEALT c (i).

• EDE0 - PUSHCTRX (i - x), аналог PUSHCTR c (i), но i, 0 ≤ i ≤ 255 и взяты из стека. Обратите внимание, что это элементарное действие одно из немногих «особых» действий, которые не являются полиморфными, как элементарные действия обработки стека, и в то же время не имеют четко определенных типов параметров и возвращаемых значений, поскольку тип x зависит от i.

• EDE1 - POPCTRX (x i -), аналог POPCTR c (i), но 0 ≤ i ≤ 255 из стека.

• EDE2 - SETCONTCTRX (x c i - ), аналог SETCONTCTR c (i), но 0 ≤ i ≤ 255 из стека.

• EDF0 - COMPOS или BOOLAND (c {\displaystyle c'}{\displaystyle c'} - {\displaystyle c''}{\displaystyle c''}), вычисляет состав {\displaystyle c\circ _{0}c'}{\displaystyle c\circ _{0}c'}, наделенный значением «выполнить c, и, в случае успеха, выполнить {\displaystyle c'}{\displaystyle c'}" (если {\displaystyle c}{\displaystyle c} - логическая схема) или просто «выполнить c, затем {\displaystyle c'}{\displaystyle c'}". Аналог SWAP; SETCONT c0.

• EDF1 - COMPOSALT или BOOLOR (c {\displaystyle c'}{\displaystyle c'} - {\displaystyle c''}{\displaystyle c''}), вычисляет альтернативный состав {\displaystyle c\circ _{0}c'}{\displaystyle c\circ _{0}c'}, что означает «выполнить c, а если неуспешно, выполнить {\displaystyle c'}{\displaystyle c'}"(если {\displaystyle c}{\displaystyle c} - логическая схема). Аналог SWAP; SETCONT c1.

• EDF2 - COMPOSBOTH (c {\displaystyle c'}{\displaystyle c'} - {\displaystyle c''}{\displaystyle c''}), вычисляет {\displaystyle (c\circ _{0}c')\circ _{1}c'}{\displaystyle (c\circ _{0}c')\circ _{1}c'}, наделенный значением «вычислить логическую схему c, затем вычислить {\displaystyle c''}{\displaystyle c''}, независимо от результата {\displaystyle c'}{\displaystyle c'}".

• EDF3 - ATEXIT (c -), устанавливает {\displaystyle {c0}\leftarrow c\circ _{0}{c0}}{\displaystyle {c0}\leftarrow c\circ _{0}{c0}}. Другими словами, c будет выполняется перед выходом из текущей подпрограммы.

• EDF4 - ATEXITALT (c -), устанавливает {\displaystyle {c1}\leftarrow c\circ _{1}{c1}}{\displaystyle {c1}\leftarrow c\circ _{1}{c1}}. Другими словами, c будет выполняться перед выходом из текущей подпрограммы по альтернативному обратному пути.

• EDF5 - SETEXITALT (c -), устанавливает {\displaystyle {c1}\leftarrow (c\circ _{0}{c0})\circ _{1}{c1}}{\displaystyle {c1}\leftarrow (c\circ _{0}{c0})\circ _{1}{c1}}. В этом случае, последующий RETALT сначала выполнит c, а затем передаст управление исходному c0. Использутся, например, для выхода из вложенных циклов.

• EDF6 - THENRET (c - {\displaystyle c'}{\displaystyle c'}), вычисляет {\displaystyle c':=c\circ _{0}{c0}}{\displaystyle c':=c\circ _{0}{c0}}

• EDF7 - THENRETALT (c - {\displaystyle c'}{\displaystyle c'}), вычисляет {\displaystyle c':=c\circ _{0}{c1}}{\displaystyle c':=c\circ _{0}{c1}}

• EDF8 - INVERT (-), меняет местами c0 и c1.

• EDF9 - BOOLEVAL (c -?), Выполняет {\displaystyle {cc}\leftarrow {\bigl (}c\circ _{0}(({PUSH}\,-1)\circ _{0}{cc}){\bigr )}\circ _{1}(({PUSH}\,0)\circ _{0}{cc})}{\displaystyle {cc}\leftarrow {\bigl (}c\circ _{0}(({PUSH}\,-1)\circ _{0}{cc}){\bigr )}\circ _{1}(({PUSH}\,0)\circ _{0}{cc})}. Если c - логическая схема, чистый эффект заключается в оценке и проталкивании в стек либо −1, либо 0.

• EDFA - SAMEALT (-), устанавливает {\displaystyle c1}{\displaystyle c1} : = {\displaystyle c0}{\displaystyle c0}. Аналог PUSH c0; POP c1.

• EDFB - SAMEALTSAVE (-), устанавливает {\displaystyle c1}{\displaystyle c1} : = {\displaystyle c0}{\displaystyle c0}, но сначала сохраняет прежнее значение {\displaystyle c1}{\displaystyle c1} в сейвелист c 0 . Аналог SAVE c1; SAMEALT.

• EErn - BLESSARGS r, n ({\displaystyle x_{1}\dots x_{r}s-c}{\displaystyle x_{1}\dots x_{r}s-c}), описан в A.8.4.

А.8.7. Вызов и переход подпрограмм словаря.
• F0n - CALL n или CALLDICT n (- n), вызывает продолжение в c3, проталкивая целое число 0 ≤ n ≤ 255 в свой стек в качестве аргумента. Близкий аналог PUSHINT n; PUSH c3; EXECUTE.

• F12_n - CALL n для 0 ≤ n < {\displaystyle 2^{14}}{\displaystyle 2^{14}} (- n), кодирование CALL n для больших значений n.

• F16_n - JMP n или JMPDICT n (- n), переходит к продолжению в c3, используя целое число 0 ≤ n < {\displaystyle 2^{14}}{\displaystyle 2^{14}} в качестве аргумента. Близкий аналог PUSH n; PUSH c3; JMPX.

• F1A_n - PREPARE n или PREPAREDICT n (- nc), аналог PUSHINT n; PUSH c3, если 0 ≤ n < {\displaystyle 2^{14}}{\displaystyle 2^{14}}. Таким образом, CALL n близкий аналог PREPARE n; EXECUTE, а JMP n - PREPARE; JMPX. Также можно использовать, например, CALLARGS или CALLCC вместо EXECUTE.

A.9 Элементарные действия генерирования и обработки ошибок
А.9.1. Генерирование ошибки.
• F22_nn - THROW nn (- 0 nn), выдает ошибку 0 ≤ nn ≤ 63 с нулевым параметром. Другими словами, передает управление продолжению c2, проталкивая 0 и nn в его стек и полностью отбрасывая старый стек.

• F26_nn - THROWIF nn (f -), выдает ошибку 0 ≤ nn ≤ 63 с нулевым параметром, только если целое число {\displaystyle f\neq 0}{\displaystyle f\neq 0}.

• F2A_nn - THROWIFNOT nn (f -), выдает ошибку 0 ≤ nn ≤ 63 с нулевым параметром, только если целое число f = 0.

• F2C4_nn - THROW nn для 0 ≤ nn < {\displaystyle 2^{11}}{\displaystyle 2^{11}}, кодирование THROW nn для больших значений nn.

• F2CC_nn - THROWARG nn (x - x nn), выдает ошибку 0 ≤ nn < {\displaystyle 2^{11}}{\displaystyle 2^{11}} с параметром x, скопировав x и nn в стек c2 и передав управления c2.

• F2D4_nn - THROWIF nn (f -) для 0 ≤ nn < {\displaystyle 2^{11}}{\displaystyle 2^{11}}.

• F2DC_nn - THROWARGIF nn (xf -), выдает ошибку 0 ≤ nn < {\displaystyle 2^{11}}{\displaystyle 2^{11}} с параметром x, только если целое число {\displaystyle f\neq 0}{\displaystyle f\neq 0}.

• F2E4_nn - THROWIFNOT nn (f -) для 0 ≤ nn < {\displaystyle 2^{11}}{\displaystyle 2^{11}}.

• F2EC_nn - THROWARGIFNOT nn (xf -), выдает ошибку 0 ≤ nn < {\displaystyle 2^{11}}{\displaystyle 2^{11}} с параметром x, только если целое число f = 0.

• F2F0 - THROWANY (n - 0 n), выдает ошибку 0 ≤ n < {\displaystyle 2^{16}}{\displaystyle 2^{16}} с нулевым параметром. Близкий аналог PUSHINT 0; SWAP; THROWARGANY.

• F2F1 - THROWARGANY (x n – x n), выдает ошибку 0 ≤ n < {\displaystyle 2^{16}}{\displaystyle 2^{16}} с параметром x, передавая управление продолжению в c2. Близкий аналог PUSH c2; JMPXARGS 2.

• F2F2 - THROWANYIF (n f -), выдает ошибку 0 ≤ n < {\displaystyle 2^{16}}{\displaystyle 2^{16}} с нулевым параметром, только если {\displaystyle f\neq 0}{\displaystyle f\neq 0}.

• F2F3 - THROWARGANYIF (x n f -), выдает ошибку 0 ≤ n < {\displaystyle 2^{16}}{\displaystyle 2^{16}} с параметром x, только если {\displaystyle f\neq 0}{\displaystyle f\neq 0}.

• F2F4 - THROWANYIFNOT (n f -), выдает ошибку 0 ≤ n < {\displaystyle 2^{16}}{\displaystyle 2^{16}} с нулевым параметром, только если f = 0.

• F2F5 - THROWARGANYIFNOT (x n f -), выдает ошибку 0 ≤ n < {\displaystyle 2^{16}}{\displaystyle 2^{16}} с параметром x, только если f = 0.

А.9.2. Перехват и обработка ошибок.
• F2FF - TRY (c {\displaystyle c'}{\displaystyle c'} -), устанавливает c2 равным , сначала сохраняя старое значение c2 в сейвлиста {\displaystyle c'}{\displaystyle c'} и в сейвелисте текущего продолжения, которое хранится в c.c0 и {\displaystyle c'}{\displaystyle c'}.c0. Затем запускается c аналогично EXECUTE. Если c не вызывает никаких ошибок, исходное значение c2 автоматически полностью восстанавливается c. Если возникает ошибка, управление передается c', но одновременно восстанавливается исходное значение c2, c' может повторно выдать ошибку THROWANY, если самостоятельная обработка невозможна.

• F3pr - TRYARGS p, r (c {\displaystyle c'}{\displaystyle c'} -), аналог TRY, но используются CALLARGS p, r вместо EXECUTE. Таким образом, все, кроме верхних 0 ≤ p ≤ 15 элементов стека будут сохранены в текущем продолжении стека, а затем восстановлены при возврате из c или {\displaystyle c'}{\displaystyle c'}, а верхние 0 ≤ r ≤ 15 значений стека c или {\displaystyle c'}{\displaystyle c'} будут скопированы в качестве возвращаемого значения.

A.10 Элементарные действия управления словарем
Поддержка словарей в TVM подробно обсуждается в 3.3. Базовые операции со словарями перечислены в 3.3.10, а таксономия элементарных действий со словарями представлена в 3.3.11 . Здесь мы используем понятия и обозначения из этих разделов.

Словари допускают два разных представления в виде значений стека TVM:

• Срез s с сериализацией значения TL-B типа HashmapE (n, X). Другими словами, s состоит либо из одного бита, равного нулю (если словарь пуст), или одного бита, равного единице, и ссылки на ячейку, содержащую корень двоичного дерева, то есть сериализованное значение типа Hashmap (n, X).

• «Возможно, ячейка» {\displaystyle c^{?}}{\displaystyle c^{?}}, т. е. значение, которое является либо ячейкой (содержащей сериализованное значение типа Hashmap (n, X)) или Null (соответствует пустому словарю). Когда такая ячейка используется для представления словаря, мы обычно обозначаем его D.

Большинство словарных элементарных действий, перечисленных ниже, принимают и возвращают словари во второй форме, которая наиболее удобна для работы со стеком. Однако, сериализованные словари внутри более крупных объектов TL-B используют первое представление.

Коды операций, начинающиеся с F4 и F5, зарезервированы для операций со словарем.

А.10.1. Создание словаря.
• 6D - NEWDICT (- D), возвращает новый пустой словарь. Альтернатива PUSHNULL, см. А.3.1.

• 6E - DICTEMPTY (D -?), Проверяет, пуст ли словарь D и возвращает -1 или 0, соответственно. Альтернатива ISNULL, см. А.3.1.

А.10.2. Сериализация и десериализация словаря.
• CE - STDICTS (s b - {\displaystyle b'}{\displaystyle b'}), сохраняет словарь, представленный срезами, в Builder b. Фактически, это синоним STSLICE.

• F400 - STDICT или STOPTREF (D b - {\displaystyle b'}{\displaystyle b'}), сохраняет словарь D в Builder. b, возвращая полученный Builder {\displaystyle b'}{\displaystyle b'}. Другими словами, если D - ячейка, выполняет STONE и STREF; если D равно Null, выполняет NIP и STZERO; в противном случае выдает ошибку проверки типа.

• F401 - SKIPDICT или SKIPOPTREF (s - {\displaystyle s'}{\displaystyle s'}), аналог LDDICT; NIP.

• F402 - LDDICTS (s – {\displaystyle s'}{\displaystyle s'} {\displaystyle s''}{\displaystyle s''}), загружает (парсит) словарь s из Среза s и возвращает остаток s как {\displaystyle s''}{\displaystyle s''}. Это «Функция сплитирования» для всех типов словарей HashmapE (n, X).

• F403 - PLDDICTS (s - {\displaystyle s'}{\displaystyle s'}), предварительно загружает словарь (представленный срезом) s из Среща s. Близкий аналог LDDICTS; DROP.

• F404 - LDDICT или LDOPTREF (s - D {\displaystyle s'}{\displaystyle s'}), загружает (парсит) словарь D из среза s и возвращает остаток s как {\displaystyle s'}{\displaystyle s'}. Может применяться к словарям и значениям произвольного (ˆY){\displaystyle ^{?}}{\displaystyle ^{?}} типа.

• F405 - PLDDICT или PLDOPTREF (s - D), предварительно загружает словарь D из Среза s. Близкий аналог LDDICT; DROP.

• F406 - LDDICTQ (s - D {\displaystyle s'}{\displaystyle s'} −1 или s 0), тихая версия LDDICT.

• F407 - PLDDICTQ (s - D −1 или 0), тихая версия PLDDICT.

А.10.3. Словарные операции GET
• F40A - DICTGET (k D n - x −1 или 0), ищет ключ k (представленный Срезом, первые 0 ≤ n ≤ 1023 бита данных которого используются в качестве ключа) в словаре D типа HashmapE (n, X) с n-битными ключами. В случае успеха возвращает найденное значение как срез x.

• F40B - DICTGETREF (k D n - c −1 или 0), аналог DICTGET, но LDREF; ENDS применяется к x в случае успеха. Эта операция применяется к словарям типа HashmapE (n, ˆY).

• F40C - DICTIGET (i D n - x −1 или 0), аналог DICTGET, но в качестве ключа выступает n-битное целое число i со знаком (с обратным порядком байтов). Если i не вписывается в n битов, возвращается 0. Если i - NaN, выдается ошибка целочисленного переполнения.

• F40D - DICTIGETREF (i D n - c −1 или 0), объединяет DICTIGET с DICTGETREF: использует n-битное целое число i со знаком в качестве ключа и, в случае успеха, возвращает ячейку, а не срез.

• F40E - DICTUGET (i D n - x −1 или 0), аналог DICTIGET, но в качестве ключа выступает n-разрядное целое число i без знака (с обратным порядком байтов).

• F40F - DICTUGETREF (i D n - c −1 или 0), аналог DICTIGETREF, но с беззнаковым n-битным целочисленным ключом i.

А.10.4. Словарные операции SET/REPLACE/ADD.
Мнемоника следующих словарных элементарных действий построена систематически, согласно стандартному выражению DICT [, I, U] (SET, REPLACE, ADD) [GET] [REF] в зависимости от типа используемого ключа (срез, целое число со знаком или без знака), выполняемой словарной операции и способа приема и возврата значений (в виде ячеек или срезом). Поэтому мы предоставляем подробное описание только для некоторых элементарных действий, предполагая, что этой информации достаточно, чтобы читатель мог получить четкое понимание о действии остальных элементарных действий.

• F412 - DICTSET (x k D n - {\displaystyle D'}{\displaystyle D'}), устанавливает значение, связанное с n-битным ключом k (представленным срезом, как в DICTGET) в словаре D (также представленный срезом) равным значению x (снова срез) и возвращает получившийся словарь как {\displaystyle D'}{\displaystyle D'}.

• F413 - DICTSETREF (c k D n - {\displaystyle D'}{\displaystyle D'}), аналог DICTSET, но значение равно ссылке на ячейку c.

• F414 - DICTISET (x i D n - {\displaystyle D'}{\displaystyle D'}), аналог DICTSET, но ключ представлен n-битным целым числом со знаком (с обратным порядком байтов) i. Если i не вмещается в n бит, генерируется ошибка проверки диапазона.

• F415 - DICTISETREF (c i D n - {\displaystyle D'}{\displaystyle D'}), аналог DICTSETREF, но ключ - n-битное целое число со знаком, как в DICTISET.

• F416 - DICTUSET (x i D n - {\displaystyle D'}{\displaystyle D'}), аналог DICTISET, но i - n-разрядное целое число без знака.

• F417 - DICTUSETREF (c i D n - {\displaystyle D'}{\displaystyle D'}), аналог DICTISETREF, но i без знака.

• F41A - DICTSETGET (x k D n - {\displaystyle D'}{\displaystyle D'} y −1 или {\displaystyle D'}{\displaystyle D'} 0), объединяет DICTSET с DICTGET: устанавливает значение, соответствующее ключу k, равным x, но также возвращает старое значение y, связанное с ключом, при его наличии.

• F41B - DICTSETGETREF (c k D n - {\displaystyle D'}{\displaystyle D'} c' −1 или {\displaystyle D'}{\displaystyle D'} 0), объединяет DICTSETREF с DICTGETREF аналог DICTSETGET.

• F41C - DICTISETGET (x i D n - {\displaystyle D'}{\displaystyle D'} y −1 или {\displaystyle D'}{\displaystyle D'} 0), аналог DICTSETGET, но ключом представлен n-битным целым числом i со знаком и прямым порядком байтов.

• F41D - DICTISETGETREF (c i D n - {\displaystyle D'c'}{\displaystyle D'c'} −1 или {\displaystyle D'}{\displaystyle D'} 0), версия DICTSETGETREF, в качестве ключа выступает i со знаком.

• F41E - DICTUSETGET (x i D n - {\displaystyle d'}{\displaystyle d'} y −1 или {\displaystyle D'}{\displaystyle D'} 0), аналог DICTISETGET, но i - n-битное целое число без знака.

• F41F - DICTUSETGETREF (c i D n - {\displaystyle D'c'}{\displaystyle D'c'} −1 или D' 0).

• F422 - DICTREPLACE (x k D n - {\displaystyle D'}{\displaystyle D'} −1 или D 0), операция REPLACE, похожа на DICTSET, но устанавливает значение ключа k в словаре D равным x, только если ключ k уже присутствовал в D.

• F423 - DICTREPLACEREF ( c k D n - {\displaystyle D'}{\displaystyle D'} −1 или D 0), REPLACE, аналог DICTSETREF.

• F424 - DICTIREPLACE (x I D n - {\displaystyle D'}{\displaystyle D'} −1 или D 0), версия DICTREPLACE с n-битным целым числом i со знаком в качестве ключа.

• F425 - DICTIREPLACEREF (c i D n - {\displaystyle D'}{\displaystyle D'} −1 или D 0).

• F426 - DICTUREPLCE (x I D n - {\displaystyle D'}{\displaystyle D'} −1 или D 0).

• F427 - DICTUREPLACEREF (c I D n - {\displaystyle D'}{\displaystyle D'} −1 или D 0).

• F42A - DICTREPLACEGET (x k D n - {\displaystyle D'}{\displaystyle D'} y −1 или D 0), REPLACE, аналог DICTSETGET: в случае успеха возвращает прежнее значение, ассоциирующееся с рассматриваемым ключом.

• F42B - DICTREPLACEGETREF (c k D n - {\displaystyle D'c'}{\displaystyle D'c'} −1 или D 0).

• F42C - DICTIREPLACEGET (x i D n - {\displaystyle D'}{\displaystyle D'} y −1 или D 0).

• F42D - DICTIREPLACEGETREF (c i D n - {\displaystyle D'c'}{\displaystyle D'c'} −1 или D 0).

• F42E - DICTUREPLACEGET (x i D n - {\displaystyle D'}{\displaystyle D'} y −1 или D 0).

• F42F - DICTUREPLACEGETREF (c i D n - {\displaystyle D'c'}{\displaystyle D'c'} −1 или D 0).

• F432 - DICTADD (x k D n - {\displaystyle D'}{\displaystyle D'} −1 или D 0), ADD аналог DICTSET: устанавливает значение, связанное с ключом k в словаре D, равным x, но только если его нет в D.

• F433 - DICTADDREF (c k D n - {\displaystyle D'}{\displaystyle D'} −1 или D 0).

• F434 - DICTIADD (x i D n - {\displaystyle D'}{\displaystyle D'} −1 или D 0).

• F435 - DICTIADDREF (c i D n - {\displaystyle D'}{\displaystyle D'} −1 или D 0).

• F436 - DICTUADD (x i D n - {\displaystyle D'}{\displaystyle D'} −1 или D 0).

• F437 - DICTUADDREF (c i D n - {\displaystyle D'}{\displaystyle D'} −1 или D 0).

• F43A - DICTADDGET (x k D n - {\displaystyle D'}{\displaystyle D'} −1 или D y 0), ADD аналог DICTSETGET: устанавливает значение, связанное с ключом k в словаре D, равным x, но только если ключ k еще не присутствует в D. В противном случае просто возвращает старое значение y без изменения словаря.

• F43B - DICTADDGETREF (c k D n - {\displaystyle D'}{\displaystyle D'} −1 или D {\displaystyle c'}{\displaystyle c'} 0), ADD аналог DICTSETGETREF.

• F43C - DICTIADDGET (x i D n - {\displaystyle D'}{\displaystyle D'} −1 или D y 0).

• F43D - DICTIADDGETREF (c i D n - {\displaystyle D'}{\displaystyle D'} −1 или D c 0).

• F43E - DICTUADDGET (x i D n - {\displaystyle D'}{\displaystyle D'} −1 или D y 0).

• F43F - DICTUADDGETREF (c i D n - {\displaystyle D'}{\displaystyle D'} −1 или D {\displaystyle c'}{\displaystyle c'} 0).

А.10.5. Варианты операций SET со словарем, принимающие значения Builder.
Следующие элементарные значения принимают новое значение как Builder b, а не Срез x, что зачастую удобнее, если значение необходимо сериализовать из несколько компонентов, вычисляемых в стеке. (Это отражается добавлением «B» к мнемонике соответствующих элементарных действий SET, которые работают со срезами.) Чистый эффект примерно аналогичен преобразованию b в Срез с помощью ENDC; CTOS и выполнению соответствующих элементарных действий, перечисленных в A.10.4.

• F441 - DICTSETB (b k D n - {\displaystyle D'}{\displaystyle D'}).

• F442 - DICTISETB (b i D n - {\displaystyle D'}{\displaystyle D'}).

• F443 - DICTUSETB (b i D n - {\displaystyle D'}{\displaystyle D'}).

• F445 - DICTSETGETB (b k D n - {\displaystyle D'}{\displaystyle D'} y −1 или {\displaystyle D'}{\displaystyle D'} 0).

• F446 - DICTISETGETB (b i D n - {\displaystyle D'}{\displaystyle D'} y −1 или {\displaystyle D'}{\displaystyle D'} 0).

• F447 - DICTUSETGETB (b i D n - {\displaystyle D'}{\displaystyle D'} y −1 или {\displaystyle D'}{\displaystyle D'} 0).

• F449 - DICTREPLACEB (b k D n - {\displaystyle D'}{\displaystyle D'} −1 или D 0).

• F44A - DICTIREPLACEB (b i D n - {\displaystyle D'}{\displaystyle D'} −1 или D 0).

• F44B - DICTUREPLACEB (b i D n - {\displaystyle D'}{\displaystyle D'} −1 или D 0).

• F44D - DICTREPLACEGETB (b k D n - {\displaystyle D'}{\displaystyle D'} y −1 или D 0).

• F44E - DICTIREPLACEGETB (b i D n - {\displaystyle D'}{\displaystyle D'} y −1 или D 0).

• F44F - DICTUREPLACEGETB (b i D n - {\displaystyle D'}{\displaystyle D'} y −1 или D 0).

• F451 - DICTADDB (b k D n - {\displaystyle D'}{\displaystyle D'} −1 или D 0).

• F452 - DICTIADDB (b i D n - {\displaystyle D'}{\displaystyle D'} −1 или D 0).

• F453 - DICTUADDB (b i D n - {\displaystyle D'}{\displaystyle D'} −1 или D 0).

• F455 - DICTADDGETB (b k D n - {\displaystyle D'}{\displaystyle D'} −1 или D y 0).

• F456 - DICTIADDGETB (b i D n - {\displaystyle D'}{\displaystyle D'} −1 или D y 0).

• F457 - DICTUADDGETB (b i D n - {\displaystyle D'}{\displaystyle D'} −1 или D y 0).

А.10.6. Словарные операции DELETE.
• F459 - DICTDEL (k D n - {\displaystyle D'}{\displaystyle D'} −1 или D 0), удаляет n-битный ключ, представленный срезом k из словаря D. Если ключ присутствует, возвращается модифицированный словарь D' и флажок успешной операции -1. В противном случае - оригинальный словарь D и 0.

• F45A - DICTIDEL (i D n - {\displaystyle D'}{\displaystyle D'}?), Версия DICTDEL с ключом i, представленным n-битным целым числом со знаком. Если i не помещается в n бит, возвращается D 0 («ключ не найден, словарь не изменен»).

• F45B - DICTUDEL (i D n - {\displaystyle D'}{\displaystyle D'}?), Аналог DICTIDEL, но n-разрядным целым числом без знака.

• F462 - DICTDELGET (k D n - {\displaystyle D'}{\displaystyle D'} x −1 или D 0), удаляет n-битный ключ, представленный срезом k из словаря D. Если ключ присутствует, возвращается измененный словарь D, исходное значение x, связанное с ключом k (представленный срезом) и флажок успешного выполнения операции -1. В противном случае - исходный словарь D и 0.

• F463 - DICTDELGETREF (k D n - {\displaystyle D'}{\displaystyle D'} c −1 или D 0), аналог DICTDELGET, но LDREF; ENDS применяется к x в случае успеха, так что возвращаемое значение c - это ячейка.

• F464 - DICTIDELGET (i D n - {\displaystyle D'}{\displaystyle D'} x −1 или D 0), вариант DICTDELGET с n-битным целым числом i со знаком в качестве ключа.

• F465 - DICTIDELGETREF (i D n - {\displaystyle D'}{\displaystyle D'} c −1 или D 0), вариант DICTIDELGET, возвращает ячейку, а не срез.

• F466 - DICTUDELGET (i D n - {\displaystyle D'}{\displaystyle D'} x −1 или D 0), вариант DICTDELGET с n-битным целым числом i без знака в качестве ключа.

• F467 - DICTUDELGETREF (i D n - {\displaystyle D'}{\displaystyle D'} c −1 или D 0), вариант DICTUDELGET возвращает ячейку, а не срез.

А.10.7. Словарные операции с «Возможно, ссылка».
В следующих операциях предполагается, что словарь используется для хранения значений {\displaystyle c^{?}}{\displaystyle c^{?}} типа {\displaystyle {Cell}^{?}}{\displaystyle {Cell}^{?}} («Возможно, ячейка»), которая может использоваться, в частности, для хранения словарей как значений в других словарях. Представление таково: если {\displaystyle c^{?}}{\displaystyle c^{?}} - это ячейка, она хранится как значение без битов данных и ровно с одной ссылкой на эту ячейку. Если {\displaystyle c^{?}}{\displaystyle c^{?}} равно Null, то соответствующий ключ должен отсутствовать в словаре.

• F469 - DICTGETOPTREF (k D n - {\displaystyle c^{?}}{\displaystyle c^{?}}), Вариант DICTGETREF, который возвращает Null вместо значения , если ключ k отсутствует в словаре D.

• F46A - DICTIGETOPTREF (i D n - {\displaystyle c^{?}}{\displaystyle c^{?}} ), Аналог DICTGETOPTREF, но с ключом, заданным n-битным целым числом со знаком i. Если ключ i вне допустимого диапазона, также возвращается Null.

• F46B - DICTUGETOPTREF (i D n - {\displaystyle c^{?}}{\displaystyle c^{?}} ), Аналог DICTGETOPTREF, но с ключом, заданным беззнаковым n-битным целым числом i.

• F46D - DICTSETGETOPTREF ({\displaystyle c^{?}}{\displaystyle c^{?}} K D n - {\displaystyle D'c^{?}}{\displaystyle D'c^{?}}), Вариант DICTGETOPTREF и DICTSETGETREF, устанавливает значение, соответствующее ключу k в словаре D, равным {\displaystyle c^{?}}{\displaystyle c^{?}} (если {\displaystyle c^{?}}{\displaystyle c^{?}} равно Null, то ключ удаляется) и возвращает старое значение {\displaystyle c^{?}}{\displaystyle c^{?}} (если до этого ключ k отсутствовал, возвращается Null).

• F46E - DICTISETGETOPTREF ({\displaystyle c^{?}}{\displaystyle c^{?}} i D n - {\displaystyle D'c^{?}}{\displaystyle D'c^{?}}), Аналог DICTSETGETOPTREF, но с n-битным целым числом i без знака в качестве ключа. Если i не помещается в n бит, выдает ошибка проверки диапазона.

• F46F - DICTUSETGETOPTREF ({\displaystyle c^{?}}{\displaystyle c^{?}} i D n - {\displaystyle D'c^{?}}{\displaystyle D'c^{?}}), Аналог DICTSETGETOPTREF, но с использованием в качестве ключа n-битного целого числа i без знака.

А.10.8. Операции по созданию словарей с префиксным кодом.
Существует несколько основных операцией по созданию словарей с префиксным кодом (см. 3.4 .2). Основное применение словарей с префиксным кодом - десериализация сериализованных данных TL-B структур или, в более общем плане, парсинг префиксных кодов. Поэтому большинство словарей с префиксными кодами будут постоянными и будут создаваться во время компиляции, а не с помощью указанных элементарных действий.

Некоторые операции GET для словарей с префиксным кодом можно найти в A.10.11.Прочие операции со словарями с префиксным кодом включают:

• F470 - PFXDICTSET (x k D n - {\displaystyle D'}{\displaystyle D'} −1 или D 0).

• F471 - PFXDICTREPLACE (x k D n - {\displaystyle D'}{\displaystyle D'} −1 или D 0).

• F472 - PFXDICTADD (x k D n - {\displaystyle D'}{\displaystyle D'} −1 или D 0).

• F473 - PFXDICTDEL (k D n - {\displaystyle D'}{\displaystyle D'} −1 или D 0).

Эти элементарные действия полностью аналогичны своим аналогам без префиксного кода DICTSET и т.д. (См. A.10.4), с той очевидной разницей, что даже SET может дать сбой в словаре с префиксным кодом, поэтому PFXDICTSET также возвращает флажок успешного выполнения операции.

А.10.9. Варианты операций GetNext и GetPrev.
• F474 - DICTGETNEXT (k D n - {\displaystyle x'}{\displaystyle x'} {\displaystyle n'}{\displaystyle n'} −1 или 0), вычисляет минимальный ключ в словаре D, который лексикографически больше k, и возвращает {\displaystyle k'}{\displaystyle k'} (представлено срезом) вместе со связанным значением {\displaystyle x'}{\displaystyle x'} (также представлено срезом).

• F475 - DICTGETNEXTEQ (k D n - {\displaystyle x'}{\displaystyle x'} {\displaystyle k'}{\displaystyle k'} −1 или 0), аналог DICTGETNEXT, но вычисляет минимальный ключ {\displaystyle k'}{\displaystyle k'}, который лексикографически больше, чем или равен k.

• F476 - DICTGETPREV (k D n - {\displaystyle x'k'}{\displaystyle x'k'} −1 или 0), аналог DICTGETNEXT, но вычисляет максимальный ключ {\displaystyle k'}{\displaystyle k'}, лексикографически меньший, чем k.

• F477 - DICTGETPREVEQ (k D n - {\displaystyle x'k'}{\displaystyle x'k'} −1 или 0), аналог DICTGETPREV, но вычисляет максимальный ключ {\displaystyle k'}{\displaystyle k'}, лексикографически меньший или равный k.

• F478 - DICTIGETNEXT (i D n - {\displaystyle x'i'}{\displaystyle x'i'} −1 или 0), аналог DICTGETNEXT, но интерпретирует все ключи в словаре D как n-битные целые и вычисляет минимальный ключ i', который больше целого i (которое не обязательно умещается в n битах).

• F479 - DICTIGETNEXTEQ (i D n - {\displaystyle x'i'}{\displaystyle x'i'} −1 или 0).

• F47A - DICTIGETPREV (i D n - {\displaystyle x'i'}{\displaystyle x'i'} −1 или 0).

• F47B - DICTIGETPREVEQ (i D n - {\displaystyle x'i'}{\displaystyle x'i'} −1 или 0).

• F47C - DICTUGETNEXT (i D n - {\displaystyle x'i'}{\displaystyle x'i'} −1 или 0), аналог DICTGETNEXT, но интерпретирует все ключи в словаре D как беззнаковые n-битные целые числа с обратным порядком байтов и вычисляет минимальный ключ {\displaystyle i'}{\displaystyle i'}, который больше целого числа i (не обязательно умещается в n битах и не обязательно отрицательный).

• F47D - DICTUGETNEXTEQ (i D n - {\displaystyle x'i'}{\displaystyle x'i'} −1 или 0).

• F47E - DICTUGETPREV (i D n - {\displaystyle x'i'}{\displaystyle x'i'} −1 или 0).

• F47F - DICTUGETPREVEQ (i D n - {\displaystyle x'i'}{\displaystyle x'i'} −1 или 0).

А.10.10. Операции GetMin, GetMax, RemoveMin, RemoveMax.
• F482 - DICTMIN (D n – x k −1 или 0), вычисляет минимальный ключ k (представлен срезом с n битами данных) в словаре D и возвращает k вместе со связанным значением x.

• F483 - DICTMINREF (D n – c k −1 или 0), аналог DICTMIN, но возвращает единственную ссылку в значении в качестве ячейки c.

• F484 - DICTIMIN (D n – x i −1 или 0), примерный аналог DICTMIN, но вычисляет минимальный ключ i с предположением, что все ключи представляют собой n-битные целые числа со знаком с обратным порядком байтов. Обратите внимание, что возвращенные ключ и значение могут отличаться от вычисленных DICTMIN и DICTUMIN.

• F485 - DICTIMINREF (D n – c i −1 или 0).

• F486 - DICTUMIN (D n – x i −1 или 0), аналог DICTMIN, но возвращает ключ как n-битное целое число i без знака.

• F487 - DICTUMINREF (D n – c i −1 или 0).

• F48A - DICTMAX (D n – x k −1 или 0), вычисляет максимальный ключ k (представлен срезом с n битами данных) в словаре D и возвращает k вместе со связанным значением x.

• F48B - DICTMAXREF (D n – c k −1 или 0).

• F48C - DICTIMAX (D n – x i −1 или 0).

• F48D - DICTIMAXREF (D n – c i −1 или 0).

• F48E - DICTUMAX (D n – x i −1 или 0).

• F48F - DICTUMAXREF (D n – c i −1 или 0).

• F492 - DICTREMMIN (D n - {\displaystyle D'}{\displaystyle D'} x k −1 или D 0), вычисляет минимальный ключ k (представленный срезом с n битами данных) в словаре D, удаляет k из словаря и возвращает k вместе со связанным значением x и модифицированным словарем {\displaystyle D'}{\displaystyle D'}.

• F493 - DICTREMMINREF (D n - {\displaystyle D'}{\displaystyle D'} c k −1 или D 0), аналог DICTREMMIN, но возвращает единственную ссылку в значении ячейки c.

• F494 - DICTIREMMIN (D n - {\displaystyle D'}{\displaystyle D'} x i −1 или D 0), приблизительный аналог DICTREMMIN, но вычисляет минимальный ключ i с предположением, что все ключи представляют собой n-битные целые числа со знаком с обратным порядком байтов. Обратите внимание, что возвращаемые ключ и значение могут отличаться от вычисленного DICTREMMIN и DICTUREMMIN.

• F495 - DICTIREMMINREF (D n - {\displaystyle D'}{\displaystyle D'} c i −1 или D 0).

• F496 - DICTUREMMIN (D n - {\displaystyle D'}{\displaystyle D'} x i −1 или D 0), аналог DICTREMMIN, но возвращает ключ i как n-битное целое число без знака.

• F497 - DICTUREMMINREF (D n - {\displaystyle D'}{\displaystyle D'} c i −1 или D 0).

• F49A - DICTREMMAX (D n - {\displaystyle D'}{\displaystyle D'} x k −1 или D 0), вычисляет максимальный ключ k (представленный срезом с n битами данных) в словаре D, удаляет k из словаря и возвращает k вместе со связанным значением x и модифицированным словарем D'.

• F49B - DICTREMMAXREF (D n - {\displaystyle D'}{\displaystyle D'} c k −1 или D 0).

• F49C - DICTIREMMAX (D n - {\displaystyle D'}{\displaystyle D'} x i −1 или D 0).

• F49D - DICTIREMMAXREF (D n - {\displaystyle D'}{\displaystyle D'} c i −1 или D 0).

• F49E - DICTUREMMAX (D n - {\displaystyle D'}{\displaystyle D'} x i −1 или D 0).

• F49F - DICTUREMMAXREF (D n - {\displaystyle D'}{\displaystyle D'} c i −1 или D 0).

А.10.11. Особые операции GET со словарями, словарями с префиксным кодом и постоянными словарями
• F4A0 - DICTIGETJMP (i D n -), аналог DICTIGET (см. A.10.12), но с x BLESSed в продолжение с последующим JMPX в случае успешного завершения. В случае неудачи, никаких действий не осуществляется. Это полезно для реализации конструкции switch/case.

• F4A1 - DICTUGETJMP (I D n -), аналог DICTIGETJMP, но DICTUGET вместо DICTIGET.

• F4A2 - DICTIGETEXEC (I D n -), аналог DICTIGETJMP, но EXECUTE вместо JMPX.

• F4A3 - DICTUGETEXEC (I D n -), аналог DICTUGETJMP, но EXECUTE вместо JMPX.

• F4A6_n - DICTPUSHCONST n (- D n), проталкивает непустой постоянный словарь D (как ячейку {\displaystyle Cell^{?}}{\displaystyle Cell^{?}}) вместе с длиной ключа 0 ≤ n ≤ 1023, который хранится в качестве части команды. Сам словарь создан из первой из оставшихся ссылок текущего продолжения. Полную инструкцию DICTPUSHCONST можно получить, сперва проведя сериализацию xF4A8_, затем самого непустого словаря (один 1 бит и ссылка на ячейку), а затем беззнакового 10-битного целого числа n (как с командой STU 10). Пустой словарь можно протолкнуть с помощью NEWDICT(см. A.10.1).

• F4A8 - PFXDICTGETQ (s D n – {\displaystyle s'}{\displaystyle s'} x {\displaystyle s''}{\displaystyle s''} −1 или s 0), ищет уникальный префикс среза s в словаре префиксных кодов (см. 3.4.2), представленный ячейкой {\displaystyle Cell^{?}}{\displaystyle Cell^{?}} D и 0 ≤ n ≤ 1023. Если найден, префикс s возвращается как {\displaystyle s'}{\displaystyle s'}, а соответствующее значение (также срез) равно x. Остаток s возвращается как срез {\displaystyle s''}{\displaystyle s''}. Если префикс s не является ключом префиксного словаря D, возвращается неизмененный s и нулевой флажок, указывающий на сбой.

• F4A9 - PFXDICTGET (s D n – {\displaystyle s'}{\displaystyle s'} x {\displaystyle s''}{\displaystyle s''}), аналог PFXDICTGET, но выдает ошибку сбоя десериализации ячейки при сбое.

• F4AA - PFXDICTGETJMP (s D n – {\displaystyle s's''}{\displaystyle s's''} или s), аналог PFXDICTGETQ, но в случае успеха BLESSes значение x в Продолжение и передает ему контроль, как JMPX. В случае неудачи возвращает s без изменений и продолжает исполнение.

• F4AB - PFXDICTGETEXEC (s D n - {\displaystyle s'}{\displaystyle s'} {\displaystyle s''}{\displaystyle s''}), аналог PFXDICTGETJMP, но выполняет найденное продолжение, а не переходит к нему. В случае сбоя вызывает ошибку десериализации ячейки.

• F4AE_n - PFXDICTCONSTGETJMP n или PFXDICTSWITCH n (s - {\displaystyle s's''}{\displaystyle s's''} или s), объединяет DICTPUSHCONST n для 0 ≤ n ≤ 1023 с PFXDICTGETJMP.

• F4BC - DICTIGETJMPZ (i D n - i или ничего), вариант DICTIGETJMP который возвращает индекс i в случае ошибки.

• F4BD - DICTUGETJMPZ (i D n - i или ничего), вариант DICTUGETJMP который возвращает индекс i в случае ошибки.

• F4BE - DICTIGETEXECZ (i D n - i или ничего), вариант DICTIGETEXEC который возвращает индекс i в случае ошибки.

• F4BF - DICTUGETEXECZ (i D n - i или ничего), вариант DICTUGETEXEC который возвращает индекс i в случае ошибки.

А.10.12. SUBDICT операции со словарем.
• F4B1 - SUBDICTGET (k l D n - {\displaystyle D'}{\displaystyle D'}), строит подклассовый словарь, состоящий из всех ключей, начинающихся с префикса k (представлен срезом, первые 0 ≤ l ≤ n ≤ 1023 бита данных используются в качестве ключа) длины l в словаре D типа HashmapE (n, X) с n-битными ключами. В случае успеха возвращает новый вложенный словарь того же типа HashmapE (n, X), что и срез D'.

• F4B2 - SUBDUCTIGET (x l D n - {\displaystyle D'}{\displaystyle D'}), вариант SUBDICTGET с префиксом, представленным L-битным целым числом x с обратным порядком байтов со знаком, где обязательно l ≤ 257.

• F4B3 - SUBDICTUGET (x l D n - {\displaystyle D'}{\displaystyle D'}), вариант SUBDICTGET с префиксом, представленным l-битным целым числом x без знака с обратным порядком байтов, где обязательно l ≤ 256.

• F4B5 - SUBDICTRPGET (k l D n - {\displaystyle D'}{\displaystyle D'}), аналог SUBDICTGET, но удаляет общий префикс k из всех ключей нового словаря {\displaystyle D'}{\displaystyle D'}, который становится типом HashmapE (n - l, X).

• F4B6 - SUBDICTIRPGET (x l D n - {\displaystyle D'}{\displaystyle D'}), вариант SUBDICTRPGET с префиксом, представленным L-битным целым числом x с обратным порядком байтов со знаком, где обязательно l ≤ 257.

• F4B7 - SUBDICTURPGET (x l D n - {\displaystyle D'}{\displaystyle D'}), вариант SUBDICTRPGET с префиксом, представленным l-битным целым числом x без знака с обратным порядком байтов, где обязательно l ≤ 256.

• F4BC – F4BF – используются элементарными действиями DICT ... Z в A.10.11.

A.11 Элементарные действия для конкретных приложений
Диапазон кодов операций F8 ... FB зарезервирован для элементарных действий для конкретных приложений. Когда TVM используется для выполнения смарт-контрактов блокчейна TON, эти элементарные действия становятся специфичными именно для блокчейна TON.

А.11.1. Внешние действия и доступ к конфигурации данных блокчейна.
Некоторые из элементарных, перечисленных ниже, осуществляют внешне видимые действия, такие как отправка сообщения другому смарт-контракту. По факту, выполнение смарт-контракта в TVM не имеет никакого эффекта, кроме модификации состояния TVM. Все внешние действия собраны в список, хранящийся в специальном регистре c5 («выходные действия»). Кроме того, некоторые элементарные действия используют данные, хранящиеся в первом компоненте кортежа, хранящемся в c7 («корень временных данных», см. 1.3.2). Смарт-контракты могут изменять любые другие данные, хранящиеся в ячейке c7, при условии, что первая ссылка остается нетронутой (в противном случае некоторые элементарные действия для конкретных приложений могут при вызове генерировать ошибку).

Большинство элементарных действий, перечисленных ниже, используют 16-битные коды операций.

А.11.2. Элементарные действия, связанные с газом.
Из следующих элементарных действий только первые два «чисты» в том плане, что не используют c5 или c7.

• F800 - ACCEPT, устанавливает текущий предел газа {\displaystyle g_{l}}{\displaystyle g_{l}} на максимально допустимое значение {\displaystyle g_{m}}{\displaystyle g_{m}} и сбрасывает газовый баланс {\displaystyle g_{c}}{\displaystyle g_{c}} на ноль (см. 1.4), уменьшая значение {\displaystyle g_{r}}{\displaystyle g_{r}} до {\displaystyle g_{c}}{\displaystyle g_{c}}. Другими словами, текущий смарт-контракт соглашается купить газ для завершения текущей сделки. Это действие требуется для обработки внешних сообщений, которые не приносят никакой пользы (следовательно, и газа).

• F801 - SETGASLIMIT (g -), устанавливает текущий предел газа {\displaystyle g_{l}}{\displaystyle g_{l}} на минимум g и {\displaystyle g_{m}}{\displaystyle g_{m}}, и сбрасывает кредит газа {\displaystyle g_{c}}{\displaystyle g_{c}} до нуля. Если израсходованный газ (включая данную команду) превышает полученное значение {\displaystyle g_{l}}{\displaystyle g_{l}}, выдается (необработанная) ошибка отсутствия газа перед установкой нового лимита. Обратите внимание, что SETGASLIMIT с аргументом g ≥ {\displaystyle 2^{63}}{\displaystyle 2^{63}} – 1 аналог ACCEPT.

• F802 - BUYGAS (x -), вычисляет количество газа, которое может быть куплено за x нанограмм, и устанавливает {\displaystyle g_{l}}{\displaystyle g_{l}} так же, как SETGASLIMIT.

• F804 - GRAMTOGAS (x - g), вычисляет количество газа, которое может быть куплено за х нанограмм. Если x отрицательный, возвращается 0. Если g превышает {\displaystyle 2^{63}-1}{\displaystyle 2^{63}-1}, оно заменяется этим значением.

• F805 – GASTOGRAM (g - x), вычисляет цену за грамм газа в нанограммах.

• F806 – F80E - Зарезервировано для элементарных действий, связанных с газом.

• F80F - COMMIT (-), фиксирует текущее состояние регистров c4 («базы данных») и c5 («действия»), так что текущее выполнение считается «Успешным» с сохраненными значениями, даже если позже возникнет ошибка.

А.11.3. Элементарные действия генератора псевдослучайных чисел.
Генератор псевдо-случайных чисел использует случайное начальное число (параметр # 6, см. A.11.4), 256-битное целое число без знака и (иногда) другие данные, хранящиеся в с7. Начальное значение случайного числа до исполнения смарт-контракта в TON - это хэш-адреса смарт-контракта и глобального случайного числа. Если внутри блока произошло несколько запусков одного смарт-контракта, то все эти запуски будут иметь одно и то же случайное начальное число. Это можно исправить, например, запустив LTIME; ADDRAND перед использованием генератора псевдо-случайных чисел впервые.

• F810 - RANDU256 (- x), генерирует новое псевдослучайное беззнаковое 256-битное целое число x. Алгоритм следующий: если r - старое значение случайного начального числа, рассматриваемого как 32-байтовый массив (путем построения представление с обратным порядком байтов 256-битного целого числа без знака), то вычисляется sha512 (r); первые 32 байта этого хэша сохраняются как новое значение r' случайного начального числа, а оставшиеся 32 байта возвращается как следующее случайное значение x.

• F811 - RAND (y - z), генерирует новое псевдослучайное целое число z в диапазоне 0 ... y - 1 (или y ... - 1, если y < 0). Точнее, беззнаковое случайное значение x генерируется как в RAND256U; тогда z: = ⌊xy / {\displaystyle 2^{256}}{\displaystyle 2^{256}} ⌋. Аналог RANDU256; MULRSHIFT 256.

• F814 - SETRAND (x -), устанавливает для случайного начального числа 256-битное целое число х без знака.

• F815 - ADDRAND (x -), смешивает 256-битное целое число x без знака с рандомизированным r, установив случайное начальное число равным sha256 конкатенации двух 32-байтовых строк: первая – прежнее начальное число r с обратным порядком байтов, а вторая – представление х с обратным порядком байтов.

• F810 – F81F - Зарезервировано для первичного генератора псевдослучайных чисел.

А.11.4. Конфигурационные элементарные действия.
Следующие элементарные действия читают данные конфигурации, представленные в кортеже, хранящемся в первом компоненте контежа в c7. Каждый раз, когда TVM вызывается для выполнения смарт-контракт блокчейна TON, этот кортеж инициализируется структурой SmartContractInfo; конфигурационные элементарные действия подразумевают, что данная структура осталась нетронутой.

• F82i - GETPARAM i (- x), возвращает i-й параметр из кортежа, предоставленного в c7 для 0 ≤ i <16. Аналог PUSH c7; FIRST; INDEX i. Если одна из этих внутренних операций завершилась неуспешно, генерируется соответствующая ошибка проверки типа или проверки диапазона.

• F823 - NOW (- x), возвращает текущее время Unix в виде целого числа. Если невозможно восстановить запрошенное значение, начиная с c7, выдается ошибка проверки типа или диапазона, в зависимости от ситуации. Аналог GETPARAM 3.

• F824 - BLOCKLT (- x), возвращает начальное логическое время текущего блока. Аналог GETPARAM 4.

• F825 - LTIME (- x), возвращает логическое время текущей транзакции. Аналог GETPARAM 5.

• F826 - RANDSEED (- x), возвращает текущее случайное начальное число как 256-битное целое число без знака. Аналог GETPARAM 6.

• F827 - BALANCE (- t), возвращает остаток баланса смарт-контракта как кортеж, состоящий из целого числа (остаток грамм в нанограммах) и Maybe Cell (словарь с 32-битными ключами как остаток «дополнительных валют»). Аналог GETPARAM 7. Обратите внимание, что элементарные действия RAW, такие как SENDRAWMSG, не обновляют данное поле.

• F828 - MYADDR (- s), возвращает внутренний адрес текущего смарт-контракта как срез с MsgAddressInt. При необходимости его можно спарсить с помощью, например, PARSESTDADDR или REWRITESTDADDR. АналогGETPARAM 8.

• F829 - CONFIGROOT (- D), возвращает Возможно, ячейку D с текущим глобальным словарем конфигураций. Аналог GETPARAM 9.

• F830 - CONFIGDICT (- D 32), возвращает глобальный словарь конфигураций вместе с длиной ключа (32). Аналог CONFIGROOT; PUSHINT32.

• F832 - CONFIGPARAM (i - c −1 или 0), возвращает значение глобального параметра конфигурации с целочисленным индексом i в качестве ячейки c и флажком успешного выполнения операции. Аналог CONFIGDICT; DICTIGETREF.

• F833 - CONFIGOPTPARAM (i - {\displaystyle c^{?}}{\displaystyle c^{?}}), Возвращает значение параметра глобальной конфигурации- с целочисленным индексом i в качестве элемента {\displaystyle Cellc^{?}}{\displaystyle Cellc^{?}}. Аналог в CONFIGDICT; DICTIGETOPTREF.

• F820 — F83F - зарезервировано для конфигурационных элементарных действий.

А.11.5. Элементарные действия глобальных переменных.
«Глобальные переменные» могут пригодиться для реализации некоторых языков смарт-контрактов высокого уровня. Они на самом деле хранятся как компоненты кортежа в c7: k-я глобальная переменная просто k-й компонент этого кортежа для 1 ≤ k ≤ 254. По соглашению, 0-й компонент используется для «параметров конфигурации» A.11.4, поэтому не доступен как глобальная переменная.

• F840 - GETGLOBVAR (k - x), возвращает k-ю глобальную переменную для 0 ≤ k <255. Аналог PUSH c7; SWAP; INDEXVARQ (см. A.3.2).

• F85_k - GETGLOB k (- x), возвращает k-ю глобальную переменную для 1 ≤ k ≤ 31. Аналог PUSH c7; INDEXQ k.

• F860 - SETGLOBVAR (xk -), присваивает x k-й глобальной переменной для 0 ≤ k <255. Аналог PUSH c7; ROTREV; SETINDEXVARQ; POP c7.

• F87_k - SETGLOB k (x -), присваивает x k-й глобальной переменной для 1 ≤ k ≤ 31. Аналог PUSH c7; SWAP; SETINDEXQ k; POP c7.

А.11.6. Примитивы хеширования и криптографии.
• F900 - HASHCU (c - x), вычисляет хэш представления (см. 3.1.5 ) ячейки c и возвращает его как 256-битное целое число x без знака. Используется для подписания и проверки подписей произвольных сущностей, представленных древом ячеек.

• F901 - HASHSU (s - x), вычисляет хэш Среза s и возвращает его как 256-битное целое число x без знака. Результат аналогичен созданию обычной ячейки, содержащей только данные и ссылки из s, и последующему вычислению хэш с помощьюHASHCU.

• F902 - SHA256U (s - x), вычисляет sha256 из битов данных Среза s. Если длина s в битах не делится на восемь, генерируется ошибка исчерпания ячейки. Хэш-значение возвращается как 256-битное целое число x без знака.

• F910 - CHKSIGNU (hsk -?), Проверяет подпись Ed25519 s хэшf h (256-битное целое число без знака, обычно вычисляемое как хеш некоторых данны[) с помощью открытого ключа k (также представленного 256-битным беззнаковым целым числом). Подпись s должна быть срезом, содержащим не менее 512 бит данных; используются только первые 512 бит. Результат равен -1, если подпись действительна, в противном случае - 0. Обратите внимание, что CHKSIGNU аналог ROT; NEWB; STU 256; ENDB; NEWC; ROTREV; CHKSIGNS, т.е. CHKSIGNS с первым аргументом d, равным 256-битному срезу, содержащему h. Следовательно, если h вычисляется как хэш некоторых данных, эти данные хешируются дважды, второе хеширование происходит внутри CHKSIGNS.

• F911 - CHKSIGNS (d s k -?), Проверяет, является ли s действительной Ed25519-подписью части данных Среза d с использованием открытого ключа k, аналог CHKSIGNU. Если длина в битах среза d не делится на восемь, генерируется ошибка исчерпания ячейки. Верификация подписей Ed25519 осуществляется стандартно, с помощью sha256, для уменьшения d до 256-битного числа, которое фактически и подписывается.

• F912 – F93F - Зарезервировано для элементарных действий хеширования и криптографии.

А.11.7. Прочие элементарные действия.
• F940 - CDATASIZEQ (c n – x y z −1 или 0), рекурсивно вычисляет количество различных ячеек x, бит данных y и ссылок на ячейки z в dag с корнем в ячейке c, эффективно возвращая общий объем памяти, используемый dag с учетом идентификации равных ячеек. Значения x, y и z вычисляются путем прохождения этого dag в глубину, с хеш-таблицей посещенных ячеек для предотвращения повторного посещения ячеек. Общее количество посещенных ячеек x не может превышать неотрицательное целое число n; в противном случае вычисление прерывается до посещения (n + 1) -я ячейки, возвращается ноль, указывающий на сбой. Если c равно NULL, возвращает x = y = z = 0.

• F941 - CDATASIZE (c n – x y z), не-тихая версия CDATASIZEQ, генерирует ошибку исчерпания ячейки (8) в случае сбоя.

• F942 - SDATASIZEQ (s n – x y z −1 или 0), аналог CDATASIZEQ, но вместо ячейки берет срез. Возвращаемое значение x не учитывает ячейку, содержащую сам срез s; Однако, биты данных и ссылки на ячейки s учитываются в y и z.

• F943 - SDATASIZE (s n – x y z), не-тихая версия SDATASIZEQ, генерирует ошибку исчерпания ячейки (8) в случае сбоя.

• F944 – F97F - Зарезервировано для различных элементарных действий TON, которые не попадают ни в какую другую конкретную категорию.

А.11.8. Элементарные действия с валютой.
• FA00 - LDGRAMS или LDVARUINT16 (s – x {\displaystyle s'}{\displaystyle s'}), загружает (десериализует) Gram или VarUInteger 16 из CellSlice s, и возвращает сумму как целое число x вместе с остатком {\displaystyle s'}{\displaystyle s'} от s. Предполагаемая сериализация x состоит из 4-битового беззнакового целого числа l с обратным порядком байтов, за которым следует 8l-битное беззнаковое число х с обратным порядком байтов. Чистый эффект аналогичен LDU 4; SWAP; LSHIFT 3; LDUX.

• FA01 - LDVARINT16 (s – x {\displaystyle s'}{\displaystyle s'}), аналог LDVARUINT16, но загружает целое число x со знаком. Примерный аналог LDU 4; SWAP; LSHIFT 3; LDIX.

• FA02 - STGRAMS или STVARUINT16 (b x - {\displaystyle b'}{\displaystyle b'}), сохраняет (сериализует) целое число x в диапазоне 0 ... {\displaystyle 2^{120}}{\displaystyle 2^{120}} −1 в Builder b и возвращает результат Builder b'. Сериализация x состоит из 4-битного целого числоа l без знака и с прямым порядком байтов , которое является наименьшим целым числом l ≥ 0, так, что x < {\displaystyle 2^{8l}}{\displaystyle 2^{8l}} l , за чем следует 8l-битное представление x без знака с обратным порядком байтов. Если x не принадлежит поддерживаемому диапазону, генерируется ошибка проверки диапазона.

• FA03 - STVARINT16 (b x - {\displaystyle b'}{\displaystyle b'}), аналог STVARUINT16, но сериализует целое число x со знаком в диапазоне {\displaystyle -2^{119}\ldots 2^{119}-1}{\displaystyle -2^{119}\ldots 2^{119}-1}.

• FA04 - LDVARUINT32 (s – x {\displaystyle s'}{\displaystyle s'}), загружает (десериализует) VarUInteger32 из CellSlice s и возвращает десериализованное значение как целое 0 ≤ х < {\displaystyle 2^{248}}{\displaystyle 2^{248}} . Ожидаемая сериализация x состоит из 5-битного целого числа l без знака с обратным порядком байтов, за которым следует 8l-разрядное число х без знака с обратным порядком байтов. Чистый эффект примерно аналогичен LDU5; SWAP; SHIFT 3; LDUX.

• FA05 - LDVARINT32 (s – x {\displaystyle s'}{\displaystyle s'}), десериализует VarInteger 32 из CellSlice s и возвращает десериализованное значение как целое число − {\displaystyle -2^{247}\leq x<2^{247}}{\displaystyle -2^{247}\leq x<2^{247}}.

• FA06 - STVARUINT32 (b x - {\displaystyle b'}{\displaystyle b'}), сериализует целое число {\displaystyle 0\leq x<2^{248}}{\displaystyle 0\leq x<2^{248}} как VarUInteger 32.

• FA07 - STVARINT32 (bx - b'), сериализует целое число {\displaystyle -2^{247}\leq x<2^{247}}{\displaystyle -2^{247}\leq x<2^{247}}как VarInteger 32.

• FA08 – FA1F - Зарезервировано для элементарных действий с валютой валютой.

А.11.9. Элементарные действия с сообщениями и адресами.
Перечисленные ниже элементарные действия сериализуют и десериализуют значения по следующей схеме TL-B (см. 3.3.4) :

addr_none$00 = MsgAddressExt;

addr_extern$01 len:(## 8) external_address:(bits len)

= MsgAddressExt;

anycast_info$_ depth:(#<= 30) { depth >= 1 }

rewrite_pfx:(bits depth) = Anycast;

addr_std$10 anycast:(Maybe Anycast)

workchain_id:int8 address:bits256 = MsgAddressInt;

addr_var$11 anycast:(Maybe Anycast) addr_len:(## 9)

workchain_id:int32 address:(bits addr_len) = MsgAddressInt;

_ _:MsgAddressInt = MsgAddress;

_ _:MsgAddressExt = MsgAddress;

int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool

src:MsgAddress dest:MsgAddressInt

value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams

created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;

ext_out_msg_info$11 src:MsgAddress dest:MsgAddressExt

created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;

Десериализованный MsgAddress представлен кортежем t следующим образом:

• addr_none представлен t = (0), т.е. Кортежем, содержащим ровно одно целое число, равное нулю.

• addr_extern представлен t = (1, s), где Срез s содержит поле external_address. Другими словами, t - пара (кортеж, состоящий из двух записей), содержащий целое число, равное единице, и срез s.

• addr_std представлен t = (2, u, x, s), где u либо равно нулю (если anycast отсутствует) или срез s, содержащий rewrite_pfx (если присутствует anycast). Далее, Целое число x - это workchain_id, а срез s содержит address.

• addr_var представлен t = (3, u, x, s), где u, x и s имеют то же значение, что и для addr_std.

Определены следующие элементарные действия, подчиняющиеся вышеуказанным соглашениям:

• FA40 - LDMSGADDR (s - {\displaystyle s'}{\displaystyle s'} {\displaystyle s''}{\displaystyle s''}), загружает из CellSlice s единственный префикс, который является допустимым MsgAddress и возвращает префикс {\displaystyle s'}{\displaystyle s'} и остаток {\displaystyle s''}{\displaystyle s''} как CellSlice.

• FA41 - LDMSGADDRQ (s - {\displaystyle s'}{\displaystyle s'} {\displaystyle s''}{\displaystyle s''} −1 или s 0), тихая версия LDMSGADDR: в случае успеха проталкивает дополнительный -1; в противном случае проталкивает исходные s и ноль.

• FA42 - PARSEMSGADDR (s - t), разбивает CellSlice s, содержащий действительный MsgAddress в кортеж t с отдельными полями MsgAddress. Если s не является допустимым MsgAddress, генерируется ошибка десериализации ячейки.

• FA43 - PARSEMSGADDRQ (s - t −1 или 0), тихая версия PARSEMSGADDR: вместо ошибки возвращает ноль.

• FA44 - REWRITESTDADDR (s – x y), парсит CellSlice, содержащий валидный MsgAddressInt (обычно msg_addr_std), перезаписывает из anycast (при его наличии) к префиксу адреса той же длины ивозвращает рабочую цепочку x и 256-битный адрес y как целые числа. Если адрес не 256-битный или если s не является допустимой сериализацией MsgAddressInt, генерируется ошибка десериализации ячейки.

• FA45 - REWRITESTDADDRQ (s – x y −1 или 0), тихая версия REWRITESTDADDR. • FA46 - REWRITEVARADDR (s – x {\displaystyle s'}{\displaystyle s'}), вариант REWRITESTDADDR, который возвращает (перезаписанный) адрес как срез s, даже в нем не 256 бит (представлен msg_addr_var).

• FA47 - REWRITEVARADDRQ (s – x {\displaystyle s'}{\displaystyle s'} −1 или 0), тихая версия REWRITEVARADDR.

• FA48 – FA5F - Зарезервировано для элементарных действий первичной обработки сообщений и адресов.

А.11.10. Элементарные действия исходящих сообщений и выходного воздействия.
• FB00 - SENDRAWMSG (c x -), отправляет необработанное сообщение, содержащееся в ячейке c, в котором должен содержаться правильно сериализованный объект Message X, с единственным исключением, что исходный адрес может иметь фиктивное значение addr_none (автоматически заменяется текущим адресом смарт-контракта), а также ihr_fee, fwd_fee, created_lt и created_at поля могут иметь произвольные значения (перезаписывать правильными значениями во время периода действия текущей транзакции). Целочисленный параметр x содержит флажки. В настоящее время x = 0 используется для обычных сообщений; x = 128 используется для сообщений, которые должны содержать весь остаток текущего смарт-контракта (вместо первоначально указанного в сообщении значения); x = 64 используется для сообщений, содержащих все повторные значения входящего сообщения в дополнение к первоначальному значению, указанному в новом сообщении (если бит 0 не установлен, плата за газ снимается от этой суммы); {\displaystyle x'}{\displaystyle x'} = x + 1 означает, что отправитель хочет оплачивать комиссию за перевод отдельно; {\displaystyle x'}{\displaystyle x'} = x + 2 означает, что любые ошибки во время обработки этого сообщения на этапе действия следует игнорировать. Наконец, {\displaystyle x'}{\displaystyle x'} = x + 32 означает, что текущий счет должен быть уничтожен, если его баланс равен нулю. Этот флажок обычно используется вместе с +128.

• FB02 - RAWRESERVE (x y -), создает выходное воздействие, для которого потребуется ровно x нанограммов (если y = 0), не более x нанограммов (если y = 2), или все, кроме x нанограмм (если y = 1 или y = 3), из оставшегося баланса. Это приблизительно аналогично созданию исходящего сообщения самому себе, в котором содержится x нанограмм (или b - x нанограмм, где b – оставшийся баланс), чтобы последующие выходные действия не смогли потратить больше денег, чем есть в остатке. +2 в y означает, что внешнее воздействие не завершится неудачно, если указанная сумма не может быть зарезервирована; вместо этого зарезервирован весь оставшийся баланс. +8 в y означает x ← −x перед выполнением любых дальнейших действий. +4 в y означает, что x увеличивается на исходный баланс текущего счета (до этапа вычислений), включая все дополнительные валюты, перед выполнением любых иных проверок и действий. В настоящее время x должен быть неотрицательным целым числом, а y должен быть в диапазоне 0 ... 15.

• FB03 - RAWRESERVEX (x D y -), аналог RAWRESERVE, но также принимает словарь D (представленный ячейкой или нулем) с дополнительными валютами. Таким образом, можно зарезервировать валюту, отличную от граммов.

• FB04 - SETCODE (c -), создает выходное воздействие, которое изменит код смарт-контракта на указанный ячейкой c. Обратите внимание, что это изменение вступит в силу только после успешного завершения текущего запуска смарт-контракта.

• FB06 - SETLIBCODE (c x -), создает выходное воздействие, которое изменяет сбор библиотеки смарт-контрактов, добавляя или удаляя библиотеку с кодом, приведенным в ячейке c. Если x = 0, библиотека фактически удаляется, если она ранее присутствовал в подборке (если нет, никаких действий не совершается). Если x = 1, библиотека добавляется как частная библиотека, если x = 2, библиотека добавляется как публичная (и становится доступной для всех смарт-контрактов, если текущий смарт-контракт находится в мастерчейне); если библиотека ранее присутствовала в подборке, ее публичный/частный статус изменяется согласно x. Значения x, отличные от 0 ... 2 недействительны.

• FB07 - CHANGELIB (hx -), создает выходное воздействие аналогично SETLIBCODE, но вместо кода библиотеки принимает хеш как беззнаковое 256-битное целое число h. Если x 0 и библиотека с хешем h отсутствует в подборке библиотеки этого смарт-контракта, данное действие не будет успешным.

• FB08 – FB3F - Зарезервировано для элементарных действий выходного воздействия.

A.12 Элементарных действий отладки
Коды операций, начинающиеся с FE, зарезервированы для элементарных действий отладки. Они имеют известную фиксированную длину операции и ведут себя как (многобайтовые) рабочие протоколы операции. В частности, они никогда не меняют содержимое стека и никогда не генерируют ошибки, за исключением отсутствия достаточного количества бит для полной декодировки кода операции. Однако, при вызове в TVM с активным режимом отладки, эти элементарные действия могут производить конкретный вывод в текстовый журнал ошибок TVM, не оказывая никакого влияния на состояние TVM (так что, с точки зрения TVM, их поведение в режиме отладки такое же). Например, элементарное действие отладки может сбрасывать все или некоторые значения в верхней части стека, отображать текущее состояние TVM и т.д.

А.12.1 Элементарные действия отладки как многобайтовые рабочие протоколы
• FEnn - DEBUG nn, для 0 ≤ nn <240, является двухбайтовым рабочим протоколом.

• FEFnssss - DEBUGSTR ssss, для 0 ≤ n <16, является (n + 3) –байтовым рабочим протоколом с пропущенной (n + 1)-байтной «строкой содержимого» ssss.

А.12.2. Элементарные действия отладки как операции без побочных эффектов.
Сейчас мы опишем элементарные действия отладки, которые могут быть применены (и фактически реализованы) в версии TVM. Обратите внимание, что другая реализация TVM может использовать эти коды для других целей или рассматривайте их как многобайтовые рабочие протоколы. Когда этим элементарным действиям требуются аргументы из стека, они проверяют эти аргументы, но оставляют их нетронутыми в самом стеке. Если в стеке недостаточно значений или они неправильных типов, элементарные действия отладки могут выводить сообщения об ошибках в журнал отладки или вести себя как рабочие протоколы, но они не генерировать исключения.

• FE00 - DUMPSTK, выгружает стек (максимум 255 верхних значений) и показывает общую глубину стека.

• FE0n - DUMPSTKTOP n, 1 ≤ n <15, выгружает верхние n значений из стека, начиная с самого глубокого. Если есть d < n значений, выводится только d значений.

• FE10 - HEXDUMP, выводит s0 в шестнадцатеричной форме, либо в виде среза, либо в виде целого числа.

• FE11 - HEXPRINT, аналог HEXDUMP, за исключением шестнадцатеричного представления s0 не выводится сразу, а скорее объединяется в текстовом буфере.

• FE12 - BINDUMP, выводит s0 в двоичной форме, аналог HEXDUMP.

• FE13 - BINPRINT, вывод двоичного представления s0 в текстовом буфере.

• FE14 - STRDUMP, выгружает срез в s0 как строку UTF-8.

• FE15 - STRPRINT, аналог STRDUMP, но выводит строку в текстовый буфер (без возврата каретки).

• FE1E - DEBUGOFF, отключает все действия по отладке, пока не будет повторно включен DEBAGON. Точнее, это элементарное действие увеличивает внутренний счетчик, который отключает все операции отладки (кроме DEBUGOFF и DEBUGON).

• FE1F - DEBUGON, включает режим отладки (в отладочной версии TVM).

• FE2n - DUMP s(n), 0 ≤ n <15, сбрасывает s(n).

• FE3n - PRINT s(n), 0 ≤ n <15, объединяет текстовое представление s(n) (без начальных или конечных пробелов или возврата каретки) в текстовый буфер, который будет выводиться перед выводом любой другой операции отладки.

• FEC0 – FEEF - используйте эти коды операций для пользовательских/экспериментальных операций отладки.

• FEFnssss - DUMPTOSFMT ssss, выводит s0, отформатированный в соответствии с (n + 1) -байтной строка ssss. Эта строка может содержать (префикс) типа TL-B, поддерживаемый отладчиком. Если строка начинается с нулевого байта, просто выводит его (без первого байта) в журнал отладки. Если строка начинается с байта, равного единице, объединяет его в буфер, который будет выводиться перед выводом любой другой операции по отладке (фактически выводит строку без возврата каретки).

• FEFn00ssss - LOGSTR ssss, строка ssss имеет длину n байтов.

• FEF000 - LOGFLUSH, сбрасывает все ожидающие отладочные данные из буфера в журнал отладки.

• FEFn01ssss - PRINTSTR ssss, строка ssss имеет длину n байтов.

A.13 Элементарные действия кодовой страницы
Следующие элементарные действия, начинающиеся с байта FF, обычно используются в самом начале кода смарт-контракта или подпрограммы библиотеки для выбора другой кодовой страницы TVM. Обратите внимание, что мы ожидаем, что все кодовые страницы будут содержать элементарные действия с одинаковыми кодами, иначе переключение обратно на другую кодовую страницу может быть невозможно (см. 5.1.8).

• FFnn - SETCP nn, выбирает кодовую страницу TVM 0 ≤ nn <240. Если кодовая страница не поддерживается, вызывает ошибку недопустимого кода операции.

FF00 - SETCP0, выбирает нулевую (тестовую) кодовую страницу TVM, описанную в настоящем документе.

• FFFz - SETCP z - 16, выбирает кодовую страницу TVM z - 16 для 1 ≤ z ≤ 15. Отрицательные кодовые страницы −13 ... - 1 зарезервированы для ограниченных версий TVM для проверки TVM на других кодовых страницах, согласно описанию в B.2.6 . Отрицательная кодовая страница -14 зарезервирована для экспериментальной страницы, не обязательно совместимой с различными реализациями TVM и подлежит отключению в производственных версиях TVM.

• FFF0 - SETCPX (c -), выбирает кодовую страницу c, где в верхней части стека {\displaystyle -2^{15}\leq c<2^{15}}{\displaystyle -2^{15}\leq c<2^{15}}.

B. Формальные свойства и характеристики TVM
В этом приложении мы затронем некоторые формальные свойства TVM, необходимые для выполнения смарт-контрактов в блокчейне TON и их последующей валидации.

B.1 Сериализация состояния TVM
Напомним, что виртуальная машина, используемая для выполнения смарт-контрактов в блокчейне должна быть детерминированной, иначе валидация каждого выполнения будет требовать включения всех промежуточных этапов выполнения в блок, или, по крайней мере, выбранных вариантов в рамках недетерминированных операций.

Кроме того, состояние такой виртуальной машины должно быть (уникально) сериализуемым., так что даже если само состояние обычно не включается в блок, его хеш все еще четко определен и может быть включен в блок в целях верификации.

В.1.1. Значения стека TVM. Значения стека TVM можно сериализовать следующим образом:

vm_stk_tinyint#01 value:int64 = VmStackValue;

vm_stk_int#0201_ value:int257 = VmStackValue;

vm_stk_nan#02FF = VmStackValue;

vm_stk_cell#03 cell:^Cell = VmStackValue;

_ cell:^Cell st_bits:(## 10) end_bits:(## 10)

{ st_bits <= end_bits }

st_ref:(#<= 4) end_ref:(#<= 4)

{ st_ref <= end_ref } = VmCellSlice;

vm_stk_slice#04 _:VmCellSlice = VmStackValue;

vm_stk_builder#05 cell:^Cell = VmStackValue;

vm_stk_cont#06 cont:VmCont = VmStackValue;

vm_stk_tinyint никогда не используется TVM в нулевой кодовой странице, а используется только в ограниченных режимах.

В.1.2. Стек TVM.
Стек TVM можно сериализовать следующим образом:

vm_stack#_ depth:(## 24) stack:(VmStackList depth) = VmStack;

vm_stk_cons#_ {n:#} head:VmStackValue tail:^(VmStackList n)

= VmStackList (n + 1);

vm_stk_nil#_ = VmStackList 0;

В.1.3. Регистры управления TVM.
Регистры управления в TVM можно сериализовать следующим образом:

_ cregs:(HashmapE 4 VmStackValue) = VmSaveList;

В.1.4. Лимиты газа TVM.
Лимиты газа в TVM могут быть сериализованы следующим образом:

gas_limits#_ remaining:int64 _:^[

max_limit:int64 cur_limit:int64 credit:int64 ]

= VmGasLimits;

В.1.5. Библиотечная среда TVM.
Библиотечная среда TVM может быть сериализована следующим образом:

_ libraries:(HashmapE 256 ^Cell) = VmLibraries;

В.1.6. Продолжения TVM.
Продолжения TVM можно сериализовать следующим образом:
vmc_std$00 nargs:(## 22) stack:(Maybe VmStack) save:VmSaveList

cp:int16 code:VmCellSlice = VmCont;

vmc_envelope$01 nargs:(## 22) stack:(Maybe VmStack)

save:VmSaveList next:^VmCont = VmCont;

vmc_quit$1000 exit_code:int32 = VmCont;

vmc_quit_exc$1001 = VmCont;

vmc_until$1010 body:^VmCont after:^VmCont = VmCont;

vmc_again$1011 body:^VmCont = VmCont;

vmc_while_cond$1100 cond:^VmCont body:^VmCont

after:^VmCont = VmCont;

vmc_while_body$1101 cond:^VmCont body:^VmCont

after:^VmCont = VmCont;

vmc_pushint$1111 value:int32 next:^VmCont = VmCont;

В.1.7. Состояние TVM.
Общее состояние TVM можно сериализовать следующим образом:

vms_init$00 cp:int16 step:int32 gas:GasLimits

stack:(Maybe VmStack) save:VmSaveList code:VmCellSlice

lib:VmLibraries = VmState;

vms_exception$01 cp:int16 step:int32 gas:GasLimits

exc_no:int32 exc_arg:VmStackValue

save:VmSaveList lib:VmLibraries = VmState;

vms_running$10 cp:int16 step:int32 gas:GasLimits stack:VmStack

save:VmSaveList code:VmCellSlice lib:VmLibraries

= VmState;

vms_finished$11 cp:int16 step:int32 gas:GasLimits

exit_code:int32 no_gas:Boolean stack:VmStack

save:VmSaveList lib:VmLibraries = VmState;

При инициализации TVM ее состояние описывается vms_init, обычно с нулевым шагом. Ступенчатая функция TVM не осуществляет никаких действий с vms_finished state и преобразует все остальные состояния в vms_running, vms_exception или vms_finished, с шагом, увеличенным на единицу.

В.2 Ступенчатая функция TVM
Формальная характеристика TVM будет завершена определением ступенчатой функции f: VmState → VmState. Эта функция детерминированно трансформирует истинное состояние виртуальной машины в истинное последующее состояние виртуальной машины и может генерировать ошибки или возвращать недопустимое последующее состояние, если исходное состояние было недопустимым.

В.2.1. Высокоуровневое определение ступенчатой функции.
Мы могли бы представить очень развернутое формальное определение ступенчатой функции TVM на языке высокого уровня. Однако такая спецификация в основном пригодилась бы в качестве справочной информации для разработчиков (людей). Мы выбрали другой подход, более адаптированный для автоматизированной формальной проверки с помощью компьютеров.

В.2.2. Операционное определение ступенчатой функции.
Обратите внимание, что ступенчатая функция f - это четко определенная поддающаяся вычислению функция из древа ячеек в древа ячеек. Таким образом, ее можно вычислить с помощью универсальной машины Тьюринга. Тогда программа P, вычисляющая f на такой машине, предоставит машиночитаемую спецификацию ступенчатой функции f. Программа P - эмулятор TVM на этой машине Тьюринга.

В.2.3. Эталонная реализация эмулятора TVM.
Мы видим, что ступенчатая функция TVM может быть определена эталонной реализацией эмулятора TVM на другой машине. Очевидная идея заключается в использовании самой TVM, так как она отлично приспособлена для работы с деревьями ячеек. Однако, эмулятор TVM в самой TVM не так эффективен, если у нас есть сомнения относительно конкретной реализации TVM и если нам надо это проверить. Например, если такой эмулятор интерпретировал команду DICTISET, просто вызвав саму команду, тогда ошибка в базовой реализации TVM останется незамеченной.

В.2.4. Эталонная реализация в урезанной версии TVM.
Мы видим, что использование самой TVM в качестве хост-машины для эталонной реализации эмулятора TVM дало бы слишком мало информации. Лучше всего взять минимальную версию TVM, которая поддерживает только минимум элементарных действий и 64-битную целочисленную арифметику, а также предоставить справочное описание P ступенчатой функции TVM f для этой урезанной версии TVM.

В этом случае необходимо тщательно реализовать и проверить только несколько элементарных действий, чтобы получить урезанную версию TVM, и сравнить эталонную реализацию P, работающую на этой урезанной версии с кастомной реализацией TVM. В частности, если существуют сомнения в правильности конкретного запуска пользовательской реализации TVM, их можно легко развеять с помощью эталонной реализации.

В.2.5. Актуальность для блокчейна TON.
Блокчейн TON принимает этот подход к проверке прогонов TVM (например, используемых для обработки входящих сообщений смарт-контрактов), когда результаты валидаторов не совпадают друг с другом. В этом случае эталонная реализация TVM, которая хранится внутри мастерчейна в качестве настраиваемого параметра (таким образом определяя текущую версию TVM), используется для получения правильного результата.

В.2.6. Кодовая страница -1.
Кодовая страница -1 TVM зарезервирована для урезанной версии TVM. Ее основная цель - выполнить эталонную реализацию ступенчатой функции полной TVM. Эта кодовая страница содержит только специальные версии арифметических элементарных действий, работающих с «крошечными целыми числами» (64-битные целые числа со знаком); следовательно, 257-битная целочисленная арифметика TVM должна быть переосмыслена в рамках 64-битной арифметики. Криптографические элементарные действия на эллиптических кривых также реализованы непосредственно в кодовой странице -1, без использования сторонних библиотек. Наконец, эталонная реализация хеш-функции sha256: также предоставлена на кодовой странице -1.

В.2.7. Кодовая страница −2.
Этот процесс начальной загрузки может быть подвергнуть дальнейшей итерации, предоставив эмулятор урезанной версии TVM, написанный для еще более простой версии TVM, поддерживающей только логические значения (или целые числа 0 и 1) - «кодовая страница -2». 64-битная арифметика, используемая в кодовой странице−1 тогда, должна быть переосмыслена в рамках логических операций, таким образом предоставляя эталонную реализацию урезанной версии TVM, которая применяется в кодовой странице -1. Таким образом, если некоторые из валидаторов блокчейна TON не согласились с результатами 64-битной арифметики, они могут вернуться к эту эталонную реализацию, чтобы найти правильный ответ. (сноска 30)

C. Плотность кода стековых и регистровых машин
Это приложение расширяет общие сведения о стековых операциях, описанных в 2.2, объясняя выбор таких элементарных действий для TVM, предоставляя сравнение стековых и регистровых машин по количеству используемых элементарных действий и плотности кода. Для этого мы сравниваем машинный код, который может быть сгенерирован оптимизирующим компилятором для одинаковых исходных файлов для разных (абстрактных) стековых и регистровых машин.

Оказывается, стековые машины (по крайней мере, те, которые оснащены базовыми элементарными действиями стековых операций, описанные в 2.2.1) обладают повышенной плотностью кода. Кроме того, стековые машины отличаются отличной расширяемостью в отношении дополнительных арифметических операций и операций произвольной обработки данных, особенно, если учесть, что машинный код автоматически генерируется путем оптимизации компиляторов.

C.1 Пример листовой функции
Начнем со сравнения машинного кода, сгенерированного (воображаемым) оптимизирующим компилятором для нескольких абстрактных регистровых и стековых машин, соответствующий тому же исходному коду на языке высокого уровня, который содержит определение листовой функции (т. е. функции, которая не вызывает никаких других функций). Как для регистровых машин, так и для стековых мы соблюдаем обозначения и соглашения, введенные в 2.1.

C.1.1. Пример исходного файла для листовой функции.
Исходный файл, который мы рассматриваем содержит одну функцию f, которая принимает шесть (целых) аргументов, a, b, c, d, e, f, и возвращает два (целых) значения, x и y, которые являются решениями системы двух линейных уравнений

Func 3.png

Исходный код функции на языке программирования, например C, может выглядеть так:

(int, int) f(int a, int b, int c, int d, int e, int f) {

int D = a*d - b*c;

int Dx = e*d - b*f;

int Dy = a*f - e*c;

return (Dx / D, Dy / D);

}

Мы предполагаем (см. 2.1), что рассматриваемые нами регистровые машины принимают шесть параметров a ... f в регистрах r0 ... r5 и возвращают два значения x и y в r0 и r1. Мы также предполагаем, что регистровые машины имеют 16 регистров, а стековая машина может напрямую обращаться к s0 - s15 посредством элементарных действий стековой обработки; стековая машина принимает параметры от s5 до s0, и возвращает два значения в s0 и s1, что в целом аналогично регистровой машине. Мы предполагаем, что регистровой машине разрешается уничтожать значения во всех регистрах (что немного несправедливо по отношению к стековой машине); к этому предположению мы вернемся позже.

C.1.2. Трехадресная регистровая машина.
Машинный код (а точнее соответствующий ассемблерный код) для машины с трехадресным регистром (см. 2.1.7) может выглядеть так:

IMUL r6,r0,r3 // r6 := r0 * r3 = ad

IMUL r7,r1,r2 // r7 := bc

SUB r6,r6,r7 // r6 := ad-bc = D

IMUL r3,r4,r3 // r3 := ed

IMUL r1,r1,r5 // r1 := bf

SUB r3,r3,r1 // r3 := ed-bf = Dx

IMUL r1,r0,r5 // r1 := af

IMUL r7,r4,r2 // r7 := ec

SUB r1,r1,r7 // r1 := af-ec = Dy

IDIV r0,r3,r6 // x := Dx/D

IDIV r1,r1,r6 // y := Dy/D

RET

Мы использовали 12 операций и не менее 23 байтов (каждая операция использует 3 × 4 =12 бит для указания трех задействованных регистров и не менее 4 бит для указания выполненной операции; поэтому нам требуется два или три байта для кодирования каждой операции). Более реалистичная оценка будет 34 (по три байта для каждой арифметической операции) или 31 байт (два байта для сложения и вычитания, три байта для умножения и деления).

C.1.3. Двухадресная регистровая машина.
Машинный код для двухадресной регистровой машины может выглядеть следующим образом:

MOV r6,r0 // r6 := r0 = a

MOV r7,r1 // r7 := b

IMUL r6,r3 // r6 := r6*r3 = ad

IMUL r7,r2 // r7 := bc

IMUL r3,r4 // r3 := de

IMUL r1,r5 // r1 := bf

SUB r6,r7 // r6 := ad-bc = D

IMUL r5,r0 // r5 := af

SUB r3,r1 // r3 := de-bf = Dx

IMUL r2,r4 // r2 := ce

MOV r0,r3 // r0 := Dx

SUB r5,r2 // r5 := af-ce = Dy

IDIV r0,r6 // r0 := x = Dx/D

MOV r1,r5 // r1 := Dy

IDIV r1,r6 // r1 := Dy/D

RET

Мы использовали 16 операций; оптимистично предполагая, что каждая из них (за исключением RET) может быть закодирована двумя байтами, для этого кода потребуется 31 байт. (сноска 31)

C.1.4. Одноадресная регистровая машина.
Машинный код для одноадресной регистровой машины может выглядеть следующим образом:

MOV r8,r0 // r8 := r0 = a

XCHG r1 // r0 <-> r1; r0 := b, r1 := a

MOV r6,r0 // r6 := b

IMUL r2 // r0 := r0*r2; r0 := bc

MOV r7,r0 // r7 := bc

MOV r0,r8 // r0 := a

IMUL r3 // r0 := ad

SUB r7 // r0 := ad-bc = D

XCHG r1 // r1 := D, r0 := b

IMUL r5 // r0 := bf

XCHG r3 // r0 := d, r3 := bf

IMUL r4 // r0 := de

SUB r3 // r0 := de-bf = Dx

IDIV r1 // r0 := Dx/D = x

XCHG r2 // r0 := c, r2 := x

IMUL r4 // r0 := ce

XCHG r5 // r0 := f, r5 := ce

IMUL r8 // r0 := af

SUB r5 // r0 := af-ce = Dy

IDIV r1 // r0 := Dy/D = y

MOV r1,r0 // r1 := y

MOV r0,r2 // r0 := x RET

Мы использовали 23 операции; если предположить однобайтовую кодировку для всех арифметических операций и XCHG, а также двухбайтовую кодировку для MOV, общий размер кода будет 29 байт. Обратите внимание, однако, что для получения компактного кода, описанного выше, мы должны были выбрать определенный порядок вычислений и сделать упор на коммутативности умножения. (Например, мы вычисляем b c перед a f, а a f – b c сразу после a f). Непонятно, сможет ли компилятор произвести такие оптимизации самостоятельно.

C.1.5. Стековая машина с базовыми элементарными действиями стековой обработки.
Машинный код стековой машины с базовыми элементарными действиями стековой обработки, описанный в 2.2.1, может выглядеть следующим образом:

PUSH s5 // a b c d e f a

PUSH s3 // a b c d e f a d

IMUL // a b c d e f ad

PUSH s5 // a b c d e f ad b

PUSH s5 // a b c d e f ad b c

IMUL // a b c d e f ad bc

SUB // a b c d e f ad-bc

XCHG s3 // a b c ad-bc e f d

PUSH s2 // a b c ad-bc e f d e

IMUL // a b c ad-bc e f de

XCHG s5 // a de c ad-bc e f b

PUSH s1 // a de c ad-bc e f b f

IMUL // a de c ad-bc e f bf

XCHG s1,s5 // a f c ad-bc e de bf

SUB // a f c ad-bc e de-bf

XCHG s3 // a f de-bf ad-bc e c

IMUL // a f de-bf ad-bc ec

XCHG s3 // a ec de-bf ad-bc f

XCHG s1,s4 // ad-bc ec de-bf a f

IMUL // D ec Dx af

XCHG s1 // D ec af Dx

XCHG s2 // D Dx af ec

SUB // D Dx Dy

XCHG s1 // D Dy Dx

PUSH s2 // D Dy Dx D

IDIV // D Dy x

XCHG s2 // x Dy D

IDIV // x y

RET

Мы провели 29 операций; предполагается однобайтовая кодировка для всех стековых операций (включая XCHG s1, s (i)). Мы также использовали 29 байтов кода. Обратите внимание, что при однобайтовом кодировании «несистематическая» операция ROT (аналог XCHG s1; XCHG s2) уменьшит количество операций и байтов до 28. Это показывает, что такие «бессистемные» операции, заимствованные в Forth, действительно могут в некоторых случаях уменьшить размер кода.

Заметьте, что мы неявно использовали коммутативность умножения в этом коде, вычисляя d e – b f вместо e d – b f, как указано в исходном коде языка высокого уровня. Если бы нам это запретили, необходимо вставить дополнительно XCHG s1 перед третьим IMUL, увеличивая общий размер кода на одну операцию и один байт.

Код, представленный выше, мог быть создан довольно простым компилятором, который просто вычислял все выражения и подвыражения в том порядке, в котором они появляются, затем переставил аргументы на вершине стека перед каждой операцией, как описано в 2.2.2. Единственная «ручная» оптимизация включает вычисление e c до a f; другой порядок приведет к немного более короткому коду из 28 операций и байтов (или 29, если нам запрещено использовать коммутативность умножения), но оптимизация ROT неприменима.

C.1.6. Стековая машина с составными элементарными действиями стековой обработки.
Стековая машина с составными элементарными действиями стековой обработки (см. 2.2.3) не сможет значительно улучшить плотность представленного выше кода, по крайней мере, в байтах. Единственная разница в том, что если бы нам запрещалось использовать коммутативной умножения, дополнительный XCHG s1 перед третьим IMUL мог быть объединен с двумя предыдущими операциями XCHG s3, PUSH s2 в PUXC s2, s3; мы предоставляем получившийся код ниже. Для простоты, мы показываем версию кода, который вычисляет подвыражения a f до e c, как указано в исходном файле. Мы видим, что это заменяет шесть операций (начиная со строки 15) пятью другими операциями, и отключает оптимизацию ROT:

PUSH s5 // a b c d e f a

PUSH s3 // a b c d e f a d

IMUL // a b c d e f ad

PUSH s5 // a b c d e f ad b

PUSH s5 // a b c d e f ad b c

IMUL // a b c d e f ad bc

SUB // a b c d e f ad-bc

PUXC s2,s3 // a b c ad-bc e f e d

IMUL // a b c ad-bc e f ed

XCHG s5 // a ed c ad-bc e f b

PUSH s1 // a ed c ad-bc e f b f

IMUL // a ed c ad-bc e f bf

XCHG s1,s5 // a f c ad-bc e ed bf

SUB // a f c ad-bc e ed-bf

XCHG s4 // a ed-bf c ad-bc e f

XCHG s1,s5 // e Dx c D a f

IMUL // e Dx c D af

XCHG s2 // e Dx af D c

XCHG s1,s4 // D Dx af e c

IMUL // D Dx af ec

SUB // D Dx Dy

XCHG s1 // D Dy Dx

PUSH s2 // D Dy Dx D

IDIV // D Dy x

XCHG s2 // x Dy D

IDIV // x y

RET

Мы использовали в общей сложности 27 операций и 28 байтов, как и в предыдущей версии (с оптимизацией ROT). Однако мы не использовали коммутативность умножения, поэтому мы можем сказать, что составные элементарные действия стековой обработки позволяют уменьшить размер кода с 29 до 28 байт.

Еще раз обратите внимание, что приведенный выше код мог быть сгенерирован простым компилятором. В результате ручной оптимизации можно было бы получить более компактный код; например, мы могли бы использовать составные операции, такие как XCHG3, заранее подготовить не только правильные значения s0 и s1 для следующих арифметических операций, но также значение s2 для последующей арифметической операции. В следующем разделе приводится пример такой оптимизации.

C.1.7. Стековая машина с составными элементарными действиями и неавтоматической оптимизацией.
Предыдущая версия кода стековой машины с составными элементарными действиями можно вручную оптимизировать следующим образом.

Произведем замену XCHG предыдущими XCHG, PUSH и арифметическими операциями по возможности, получаем фрагмент кода XCHG s2, s6; XCHG s1, s0; XCHG s0, s5, который затем может быть заменен составным операцией XCHG3 s6, s0, s5. Эта составная операция допускала бы двухбайтовое кодирование, а в результате получим 27-байтовой код с использованием всего 21 операции:

PUSH2 s5,s2 // a b c d e f a d

IMUL // a b c d e f ad

PUSH2 s5,s4 // a b c d e f ad b c

IMUL // a b c d e f ad bc

SUB // a b c d e f ad-bc

PUXC s2,s3 // a b c ad-bc e f e d

IMUL // a b c D e f ed

XCHG3 s6,s0,s5 // (same as XCHG s2,s6; XCHG s1,s0; XCHG s0,s5)

// e f c D a ed b

PUSH s5 // e f c D a ed b f

IMUL // e f c D a ed bf

SUB // e f c D a ed-bf

XCHG s4 // e Dx c D a f

IMUL // e Dx c D af

XCHG2 s4,s2 // D Dx af e c

IMUL // D Dx af ec

SUB // D Dx Dy

XCPU s1,s2 // D Dy Dx D

IDIV // D Dy x

XCHG s2 // x Dy D

IDIV // x y

RET

Интересно отметить, что эта версия кода стековой машины содержит только 9 элементарных действий управления стеком для 11 арифметических операций. Не ясно, однако, сможет ли оптимизирующий компилятор создать такой код самостоятельно.

C.2 Сравнение машинного кода для примера листовой функции
В таблице 1 приведены свойства машинного кода, соответствующие тому же исходному файлу, описанному в C.1.1, сгенерированному для гипотетической трехадресной регистровой машины (см. C.1.2), как с «оптимистическими», так и с «реалистическими» командами; двухадресная машина (см. C.1.3); одноадресная машина (см. C.1.4); и стековая машина, похожая на TVM, использующая только базовые элементарные действия стековой обработки (см. C.1.5) или базовые и составные элементарные действия (см. C.1.7).

Значение столбцов в таблице 1:

• «Операции» - количество использованных команд, разделенных на «данные». (т. е. команды перемещения и обмена регистров для регистровых машин, и команды управления стеком для стековых машин) и «арифметические» (команды сложения, вычитания, умножения и деления целых чисел). «Итог» на единицу больше, чем сумма этих двух, т.к. в конце машинного кода есть также однобайтовая команда RET.

• «Байты кода» - общий объем использованных байтов кода.

• «Кодовое пространство» - часть «кодового пространства» (т.е. возможные варианты первого байта кодировки команды), используемые данные и арифметические команды в предполагаемой кодировке команды. Например, «оптимистическая» кодировка для трехадресной машины предполагает двухбайтовую кодировку для всех арифметических команд op r (i), r (j), r (k). Каждая арифметическая команды будет потреблять часть 16/256 = 1/16 кодового пространства. Обратите внимание, что для стековой машины мы приняли однобайтовую кодировку для XCHG s (i), PUSH s (i) и POP s (i) во всех случаях, с дополнением в виде XCHG s1, s (i) базовых стековых элементарных действий. Что касается составных команд, мы приняли двухбайтовую кодировку для PUSH3, XCHG3, XCHG2, XCPU, PUXC, PUSH2, исключение составляет XCHG s1, s (i).

Tab1.png

Таблица 1: Сводка характеристик машинного кода для гипотетических 3-адресных, 2-адресных, одноадресных и стековых машин, созданные для примера листовой функции (см . C.1.1 ). Два наиболее важных столбца, отражающие плотность кода и возможность расширения на другие операции, выделены жирным шрифтом. Чем меньше значение в этих столбцах – тем лучше.

Столбец «байты кода» отражает плотность кода для конкретного примера. Однако «кодовое пространство» также важно, поскольку оно отражает возможность расширения достигнутой плотности на другие классы операций (например, если бы можно было дополнить арифметические операции операциями со строками и так далее). Здесь колонка «арифметика» важнее колонки «данные», потому что никаких дальнейших операций с данными не потребуется для таких расширений.

Мы видим, что трехадресная регистровая машина с «оптимистическим» кодированием, предполагающим двухбайтовое кодирование для всех трех-регистровых арифметических операций обеспечивает наилучшую плотность кода, занимая всего 23 байта. Однако, каждая арифметическая операция занимает 1/16 часть кодового пространства, поэтому четыре операции уже используют четверть кодового пространства. Максимум 11 других операций, арифметических или нет, могут быть добавлены к этой архитектуре. При сохранении такой высокой плотности кода. С другой стороны, когда мы рассматривает «реалистичную» кодировку для трехадресной машины, используя двух-байтовые кодировки только для наиболее часто используемых операций сложения/вычитания (и более длинные кодировки для реже используемых умножения/деления, следовательно, возможные операции расширения скорее всего попадут в этот класс), то трехадресная машина перестает предлагать такую привлекательную плотность кода. Фактически, двухадресная машина в этот момент становится не менее привлекательной: она способна достигать того же размера кода в 31 байт, что и трехадресная машина с «реалистичной» кодировкой, используя только 6/256 кодового пространства для этого! Однако 31 байт - худший результат в этой таблице.

Одноадресная машина использует 29 байтов, что немного меньше, чем двухадресная машина. Тем не менее, она использует четверть кодового пространства для своих арифметических операций, что затрудняет возможность расширения. В этом отношении она похож на трехадресную машину с «оптимистической» кодировкой, но требует 29 байт вместо 23! Таким образом, нет никаких причин использовать одноадресную машину с точки зрения расширяемости (отражается кодовым пространством, используемым для арифметических операций) по сравнению с плотностью кода.

Наконец, стековая машина выигрывает по плотности кода (27 или 28 байт), проигрывая только трехадресной машине с оптимистическим кодированием (которое, однако, ужасно с точки зрения расширяемости).

Подводя итог: двухадресная машина и стековая машина достигает лучшей расширяемости в отношении дополнительных арифметических операций или обработки данных (используя только 1/256 кодового пространства для каждой такой команды), а стековая машина дополнительно достигает лучшей плотности кода за счет небольшого интервала. Стековая машина использует значительную часть своего кодового пространства (более четверти) для команд по обработке данными (т. е. стековой обработки); тем не менее, это не сильно затрудняет расширяемость, так как команды стековой обработки занимают постоянную часть этапа кода операции, независимо от всех остальных команд и расширений.

Хотя все еще может возникнуть соблазн использовать двухадресную регистровую машину, мы скоро поясним (см. C.3), почему двухадресная регистровая машина предлагает меньшую плотность кода и расширяемость на практике, чем кажется на основании данных таблицы. Что касается выбора между стековой машиной только с базовыми элементарными действиями стековой обработки и с составными элементарными действиями, то выбор в пользу более сложной машины не представляется рациональным: она предлагает код всего на один или два байта меньше за счет использования значительно большего кодового пространства для операций стековой обработки, а оптимизированный код, использующий эти дополнительные команды, программистам написать, а компиляторам - автоматически сгенерировать.

C.2.1. Соглашения о вызове регистров: некоторые регистры должны быть сохранены функциями.
До этого момента мы рассматривали машинный код только одной функции, без учета взаимодействия между этой функцией и другими функциями в той же программе.

Обычно программа состоит из более чем одной функции, а когда функция не является «простой» или «листовой», она должна вызывать другие функции. Поэтому важно, сохраняет ли вызываемая функция все или хотя бы некоторые регистры. Если она сохраняет все регистры, кроме тех, которые используются для возврата значений, вызывающий оператор может безопасно хранить свои локальные и временные переменные в определенных регистрах; однако вызываемый должен сохранить все регистры, которые будут использоваться для его временных значений (обычно в стеке, который также существует в регистровых машинах), а затем восстановить исходные значения. С другой стороны, если вызываемой функции разрешено уничтожить все регистры, ее можно записать способом, описанным в C.1.2, C.1.3 и C.1.4, но теперь вызывающий оператор будет отвечать за сохранение всех своих временных значений в стеке перед вызовом, а затем восстановливать эти значения.

В большинстве случаев соглашения о вызовах для регистровых машин требуют сохранения некоторых, но не всех регистров. Предположим, что m ≤ n регистров будут сохраняться функциями (если они не используются для возвращаемых значений), и что эти регистры - r (n − m) ... r (n − 1). m = 0 означает, что «Вызываемый может уничтожить все регистры», рассмотренные до сих пор; это довольно болезненно для вызывающего оператора. m = n означает «вызываемый должен сохранить все регистры»; это довольно болезненно для вызываемого, как мы вскоре увидим. Обычно на практике используется значение m около n / 2.

В следующих разделах рассматриваются случаи m = 0, m = 8 и m = 16 для регистровых машин с n = 16 регистрами.

C.2.2. m = 0: регистров для сохранения нет.
Этот случай рассмотрен и обобщены в C.2 и таблице 1 выше.

C.2.3. Случай m = n = 16: все регистры должны быть сохранены.
Этот случай самый болезненный для вызываемой функции. Особенно трудно приходится листовой функции, которые не получают никакой выгоды из того, что другие функции сохраняют некоторые регистры при вызове – они не вызывают никаких функций, а должны сохранять сами все регистры.

Для оценки последствий m = n = 16, мы предположим, что все регистровые машины имеют стек и однобайтовые команды PUSH r (i) и POP r (i), которые проталкивают или извлекают регистр в/из стека. Например, трехадресный машинный код в C.1.2 уничтожает значения в регистрах r2, r3, r6 и r7; это означает, что код этой функции необходимо дополнить четырьмя командами PUSH r2; PUSH r3; PUSH r6; НАЖМИТЕ r7 в начале и четырьмя командами POP r7; POP r6; POP r3; POP r2 прямо перед командой RET для восстановления исходных значений этих регистров из стека. Эти четыре дополнительные пары PUSH / POP увеличат количество операций и размер кода в байтах на 4 × 2 = 8. Аналогичный анализ можно провести для другой регистровой машины, приведенной в Таблице 2.

Мы видим, что с учетом вышеупомянутого стековые машины очевидно выигрывают с точки зрения плотности кода и находятся в топе с точки зрения расширяемости.

Tab2.png

Таблица 2: Сводка характеристик машинного кода для гипотетических 3-адресных, 2-адресных, одноадресных и стековых машин, созданные для примера листовой функции (см . C.1.1 ). Все из 16 регистров должны быть сохранены вызываемыми функциями (m = n = 16). Новая колонка с меткой r обозначает количество регистров, которые необходимо сохранить и восстановить, что приведет к увеличению на 2r операций и байтов кода по сравнению с таблицей 1. Недавно добавленные команды PUSH и POP для регистровых машин также используют 32/256 кодового пространства. Две строки, соответствующие стековым машинах, без изменений.

C.2.4. Случай m = 8, n = 16: регистры r8 ... r15 должны быть сохранены.
Разбор этого случая аналогичен предыдущему. Результаты собраны в таблице 3.

Обратите внимание, что итоговая таблица очень похожа на таблицу 1, за исключением столбца «Кодовое пространство операции» и строки одноадресной машины. Следовательно, выводы C.2 все еще применимы в этом случае с некоторыми незначительными изменениями. Однако, следует подчеркнуть, что эти выводы справедливы только для листовых функций, т. е. функций, которые не вызывают другие функции. Любая программа, кроме простейшей, будет иметь множество нелистовых функций, особенно если мы пытаемся минимизировать размер машинного кода (что предотвращает встраивание функций в большинстве случаев).

C.2.5. Более справедливое сравнение с использованием двоичного кода вместо байтового.
Tab3.png

Таблица 3: Сводка характеристик машинного кода для гипотетических 3-адресных, 2-адресных, одноадресных и стековых машин, созданные для примера листовой функции (см. C.1.1). Последние 8 из 16 регистров должны быть сохранены вызываемыми функциями (m = 8, n = 16). Эта таблица похожа на таблицу 2, но имеет меньшие значения r.

Читатель, возможно, заметил, что наше предыдущее обсуждение k-адресных регистровых и стековых машины очень сильно зависело от нашего решения, что полные инструкции должны кодироваться целым числом байтов. Если бы нам разрешили использовать «битным» или «двоичный код» вместо байтового кода в командах кодирования, мы могли бы более равномерно сбалансировать кодовое пространство, используемое различными машинами. Например, код операции SUB для трехадресной машины должен быть либо 4-битный (хорошо для плотности кода, плохо для кода операции) или 12-битный (очень плохо для плотности кода), потому что полная команда должна быть кратна восьми битам (например, 16 или 24 бита), и 3 · 4 = 12 этих битов должны использоваться для трех наименований регистров.

Поэтому давайте избавимся от этого ограничения.

Теперь, когда мы можем использовать любое количество бит для кодирования команды, мы можем выбрать все коды операций одинаковой длины для всех рассматриваемых машин. Например, все арифметические команды могут иметь 8-битные коды операций, как в стековой машине, каждая команда будет занимать 1/256 кодового пространства; тогда трехадресная регистровая машина будет использовать 20 битов для кодирования каждой полной арифметической команды. Можно предположить, что все MOV, XCHG, PUSH и POP на регистровых машинах имеют 4-битные коды операций, так как это наиболее распространенный вариант для стековой машины. Результаты этих изменений приведены в таблице 4.

Мы видим, что производительность различных машин намного более сбалансирована, причем стековая машина по-прежнему остается победителем с точки зрения плотности кода, но трехадресная машина, занимающая второе место, также заслуживает внимания. Если бы мы рассмотрели скорость декодирования и возможность параллельного выполнения команд, мы бы выбрали трехадресную машину, поскольку использует всего 12 команд вместо 21.

Tab4.png

Таблица 4: Сводка характеристик машинного кода для гипотетических 3-адресных, 2-адресных, одноадресных и стековых машин, созданные для примера листовой функции (см. C.1.1). Последние 8 из 16 регистров должны быть сохранены вызываемыми функциями (m = 8, n = 16). На этот раз мы используем фрагменты байтов для кодирования команды, чтобы привести в соответствие кодовое пространство на разных машинах. Все арифметические команды имеют 8-битные коды операций, все команды по обработке стека/данных имеют 4-битные коды. В остальном таблица похожа на Таблица 3.

C.3 Пример нелистовой функции
В этом разделе сравнивается машинный код для разных регистровых машин на примере нелистовой функции. Снова предполагаем, что, либо m = 0, m = 8, либо m = 16 регистров сохраняются вызываемыми функциями, при этом m = 8 – это компромисс, на который пошли большинство современных компиляторов и операционных систем.

C.3.1. Пример исходного кода для функции, не являющейся листовой.
Образец исходного файла может быть получен заменой встроенного целочисленного типа на пользовательский тип Rational, представленный указателем на объект в памяти, в нашей функции для решения системы двух линейных уравнений (см. C.1.1):

struct Rational;

typedef struct Rational *num;

extern num r_add(num, num);

extern num r_sub(num, num);

extern num r_mul(num, num);

extern num r_div(num, num);

(num, num) r_f(num a, num b, num c, num d, num e, num f) {

num D = r_sub(r_mul(a, d), r_mul(b, c)); // a*d-b*c

num Dx = r_sub(r_mul(e, d), r_mul(b, f)); // e*d-b*f

num Dy = r_sub(r_mul(a, f), r_mul(e, c)); // a*f-e*c

return (r_div(Dx, D), r_div(Dy, D)); // Dx/D, Dy/D

Мы проигнорируем все вопросы, связанные с размещением новых объектов типа Rational. в памяти (например, в динамической памяти) и для предотвращения утечек памяти. Мы можем предположить, что вызываемые подпрограммы r_sub, r_mul и т. д. выделяют новые объекты просто продвигая некоторый указатель в предварительно выделенном буфере, и этот неиспользуемый объект позже освобождаются сборщиком мусора, внешним по отношению к коду.

Рациональные числа теперь будут представлены указателями, адресами или ссылками, которые будут помещены в регистры наших гипотетических регистровых машин или в стек наших стековых машин. Если мы хотим использовать TVM, как пример стековой машины, мы должны использовать значения типа Cell для представления ссылок на объекты типа Rational в памяти.

Мы предполагаем, что подпрограммы (или функции) вызываются специальной командой CALL, которая кодируется тремя байтами, включая характеристику вызываемой функции (например, индекс в «таблице глобальных функций»).

C.3.2. Трехадресные и двухадресные регистровые машины, m = 0 сохраненных регистров.
Поскольку наш пример функции вообще не использует встроенные арифметические команды, компиляторы для наших гипотетических трехадресных и двухадресных регистровых машин производят одинаковый машинный код. Помимо ранее представленных однобайтовых команд PUSH r (i) и POP r (i), мы предполагаем, что наши двух- и трехадресные машины поддерживают следующие двухбайтовые команды: MOV r (i), s (j), MOV s (j), r (i) и XCHG r (i), s (j), где 0 ≤ i, j ≤ 15. Такие команды занимают только 3/256 пространства кода операции, поэтому их добавление кажется вполне естественным.

Сперва допустим, что m = 0 (т.е. все подпрограммы могут уничтожать значения всех регистров). В этом случае наш машинный код для r_f не должен сохранять какие-либо регистры, но необходимо сохранять все регистры, содержащие полезные значения, в стек перед вызовом любых подпрограмм. Оптимизирующий размер компилятор может выдать следующий код:

PUSH r4 // STACK: e

PUSH r1 // STACK: e b

PUSH r0 // .. e b a

PUSH r6 // .. e b a f

PUSH r2 // .. e b a f c

PUSH r3 // .. e b a f c d

MOV r0,r1 // b

MOV r1,r2 // c

CALL r_mul // bc

PUSH r0 // .. e b a f c d bc

MOV r0,s4 // a

MOV r1,s1 // d

CALL r_mul // ad

POP r1 // bc; .. e b a f c d

CALL r_sub // D:=ad-bc

XCHG r0,s4 // b ; .. e D a f c d

MOV r1,s2 // f

CALL r_mul // bf

POP r1 // d ; .. e D a f c

PUSH r0 // .. e D a f c bf

MOV r0,s5 // e

CALL r_mul // ed

POP r1 // bf; .. e D a f c

CALL r_sub // Dx:=ed-bf

XCHG r0,s4 // e ; .. Dx D a f c

POP r1 // c ; .. Dx D a f

CALL r_mul // ec

XCHG r0,s1 // a ; .. Dx D ec f

POP r1 // f ; .. Dx D ec

CALL r_mul // af

POP r1 // ec; .. Dx D

CALL r_sub // Dy:=af-ec

XCHG r0,s1 // Dx; .. Dy D

MOV r1,s0 // D

CALL r_div // x:=Dx/D

XCHG r0,s1 // Dy; .. x D

POP r1 // D ; .. x

CALL r_div // y:=Dy/D

MOV r1,r0 // y

POP r0 // x ; ..

RET

Мы использовали 41 команду: 17 однобайтных (восемь пар PUSH / POP и одна RET), 13 двухбайтовых (MOV и XCHG; из них 11 «новых», включая стековые) и 11 трехбайтовых (CALL), всего 17 · 1 + 13 · 2 + 11 · 3 = 76 байт. (сноска 32)

C.3.3. Трехадресные и двухадресные регистровые машины, m = 8 сохраненных регистров.
Теперь у нас есть восемь регистров, от r8 до r15, которые сохраняются вызовами подпрограмм. Мы можем оставить промежуточные значения, а не проталкивать их в стек. Однако, в результате мы получим пару PUSH / POP для каждого такого регистра, который мы решили использовать, так как наша функция также должна сохранять исходное значение. Видимо, использование этих регистров не улучшает плотность кода, поэтому оптимальный код для трех- и двухадресных машин для m = 8 сохраненных регистров аналогичен приведенному в C.3.2, с 42 командами и 74 байтами кода.

C.3.4. Трехадресные и двухадресные регистровые машины, m = 16 сохраненных регистров. На этот раз все регистры должны быть сохранены подпрограммой, за исключением тех, которые используются для возврата результатов. Это означает, что код должен сохранять исходные значения от r2 до r5, а также любые другие регистры, которые он использует для временных значений. Простой способ создания кода подпрограммы - помещать регистры от r2 до, скажем, r8 в стек, затем выполнить все необходимые операции, используя r6 – r8 для промежуточных значения и, наконец, восстановить регистры из стека. Однако, размер кода не будет оптимален. Выбираем другой подход:

PUSH r0 // STACK: a

PUSH r1 // STACK: a b

MOV r0,r1 // b

MOV r1,r2 // c

CALL r_mul // bc

PUSH r0 // .. a b bc

MOV r0,s2 // a

MOV r1,r3 // d

CALL r_mul // ad

POP r1 // bc; .. a b

CALL r_sub // D:=ad-bc

XCHG r0,s0 // b; .. a D

MOV r1,r5 // f

CALL r_mul // bf

PUSH r0 // .. a D bf

MOV r0,r4 // e

MOV r1,r3 // d

CALL r_mul // ed

POP r1 // bf; .. a D

CALL r_sub // Dx:=ed-bf

XCHG r0,s1 // a ; .. Dx D

MOV r1,r5 // f

CALL r_mul // af

PUSH r0 // .. Dx D af

MOV r0,r4 // e

MOV r1,r2 // c

CALL r_mul // ec

MOV r1,r0 // ec

POP r0 // af; .. Dx D

CALL r_sub // Dy:=af-ec

XCHG r0,s1 // Dx; .. Dy D

MOV r1,s0 // D

CALL r_div // x:=Dx/D

XCHG r0,s1 // Dy; .. x D

POP r1 // D ; .. x

CALL r_div // y:=Dy/D

MOV r1,r0 // y

POP r0 // x

RET

Мы использовали 39 команд: 11 однобайтовых, 17 двухбайтовых (из них 5 «новых») и 11 трехбайтовых, всего 11 · 1 + 17 · 2 + 11 · 3 = 78 байт. Как это ни парадоксально, размер кода в байтах немного больше, чем в предыдущем примере (см. C.3.2). Частично это связано с тем, что мы приняли двухбайтовую кодировку для «Новых» команд MOV и XCHG аналогично «старым». Большинство существующих архитектур (например, x86-64) используют более длинные кодировки (может быть, даже вдвое длиннее) для аналогов наших «новых» команд по сравнению с «обычными» регистровыми. Учитывая все вышеупомянутое, мы получили бы 83 байта (по сравнению с 87 для кода в C.3.2), предполагая трехбайтовое кодирование новых операций, и 88 байт (против 98) при четырехбайтовом кодировании. Следовательно, для двухадресных архитектур без оптимизированных кодировок операции перемещения и обмена, m = 16 сохраненных регистров могут иметь немного более короткий код для некоторых функций, не являющихся листовыми, за счет листовой функции (см. C.2. 3 и C.2.4), которые станут значительно длиннее.

C.3.5. Одноадресная регистровая машина, m = 0 сохраненных регистров.
Для нашей одноадресной регистровой машины мы предполагаем, что новые команды работают только через суммирующий регистр. Следовательно, у нас есть три новые команды, LD s (j) (аналог MOV r0, s (j) двухадресных машин), ST s (j) (аналог MOV s (j), r0) и XCHG s (j) (аналог XCHG r0, s (j)). Чтобы сравнение с двухадресными машинами было интереснее, мы предлагаем однобайтовые кодировки для этих новых команд, даже хотя это займет 48/256 = 3/16 кодового пространства операции.

Адаптировав код, представленный в C.3.2, к одноадресной машине, мы получим следующее:

PUSH r4 // STACK: e

PUSH r1 // STACK: e b

PUSH r0 // .. e b a

PUSH r6 // .. e b a f

PUSH r2 // .. e b a f c

PUSH r3 // .. e b a f c d

LD s1 // r0:=c

XCHG r1 // r0:=b, r1:=c

CALL r_mul // bc

PUSH r0 // .. e b a f c d bc

LD s1 // d

XCHG r1 // r1:=d

LD s4 // a

CALL r_mul // ad

POP r1 // bc; .. e b a f c d

CALL r_sub // D:=ad-bc

XCHG s4 // b ; .. e D a f c d

XCHG r1

LD s2 // f

XCHG r1 // r0:=b, r1:=f

CALL r_mul // bf

POP r1 // d ; .. e D a f c

PUSH r0 // .. e D a f c bf

LD s5 // e

CALL r_mul // ed

POP r1 // bf; .. e D a f c

CALL r_sub // Dx:=ed-bf

XCHG s4 // e ; .. Dx D a f c

POP r1 // c ; .. Dx D a f

CALL r_mul // ec

XCHG s1 // a ; .. Dx D ec f

POP r1 // f ; .. Dx D ec

CALL r_mul // af

POP r1 // ec; .. Dx D

CALL r_sub // Dy:=af-ec

XCHG s1 // Dx; .. Dy D

POP r1 // D ; .. Dy

PUSH r1 // .. Dy D

CALL r_div // x:=Dx/D

XCHG s1 // Dy; .. x D

POP r1 // D ; .. x

CALL r_div // y:=Dy/D

XCHG r1 // r1:=y

POP r0 // r0:=x ; ..

RET

Мы использовали 45 команд: 34 однобайтовых и 11 трехбайтовых, всего 67 байт. По сравнению с 76 байтами, используемыми двух- и трехадресными машинами в C.3.2 мы видим, что машинный код с одноадресным регистром может быть плотнее, чем у двух-регистровых машин, за счет использования большего кодового пространство операции (как показано в C.2). Однако, на этот раз лишние 3/16 кодового пространства использовалось для команд по обработке данных, которые не зависят от конкретных арифметических операций или вызываемых пользовательских функций.

C.3.6. Одноадресная регистровая машина, m = 8 сохраняемых регистров.
Как объяснено в C.3.3, сохранение r8 – r15 между вызовами подпрограмм не оптимизирует размер кода, поэтому одноадресная машина будет использовать для m = 8 тот же код, что и в C.3.5.

C.3.7. Одноадресная регистровая машина, m = 16 сохраняемых регистров.
Мы просто адаптируем код, представленный в C.3.4, к одноадресной регистровой машине:

PUSH r0 // STACK: a

PUSH r1 // STACK: a b

MOV r0,r1 // b

MOV r1,r2 // c

CALL r_mul // bc

PUSH r0 // .. a b bc

LD s2 // a

MOV r1,r3 // d

CALL r_mul // ad

POP r1 // bc; .. a b

CALL r_sub // D:=ad-bc

XCHG s0 // b; .. a D

MOV r1,r5 // f

CALL r_mul // bf

PUSH r0 // .. a D bf

MOV r0,r4 // e


MOV r1,r3 // d

CALL r_mul // ed

POP r1 // bf; .. a D

CALL r_sub // Dx:=ed-bf

XCHG s1 // a ; .. Dx D

MOV r1,r5 // f

CALL r_mul // af

PUSH r0 // .. Dx D af

MOV r0,r4 // e

MOV r1,r2 // c

CALL r_mul // ec

MOV r1,r0 // ec

POP r0 // af; .. Dx D

CALL r_sub // Dy:=af-ec

XCHG s1 // Dx; .. Dy D


POP r1 // D ; .. Dy

PUSH r1 // .. Dy D

CALL r_div // x:=Dx/D

XCHG s1 // Dy; .. x D

POP r1 // D ; .. x

CALL r_div // y:=Dy/D

MOV r1,r0 // y

POP r0 // x

RET

Мы использовали 40 инструкций: 18 однобайтовых, 11 двухбайтовых и 11 трехбайтовых, всего 18 · 1 + 11 · 2 + 11 · 3 = 73 байта.

C.3.8. Стековая машина с базовыми элементарными действиями стековой обработки.
Мы повторно используем код из C.1.5, просто заменяя арифметические элементарные действия (команды виртуальной машины) вызовами подпрограмм. Единственное существенное изменение - это вставка ранее необязательного XCHG s1 перед третьим умножением, потому что даже оптимизирующий компилятор не может узнать, является ли CALL r_mul коммутативной операцией. Мы также использовали «оптимизацию хвостовой рекурсии» путем замены последнего CALL r_div, за которым следует RET, на JMP r_div.

PUSH s5 // a b c d e f a

PUSH s3 // a b c d e f a d

CALL r_mul // a b c d e f ad

PUSH s5 // a b c d e f ad b

PUSH s5 // a b c d e f ad b c

CALL r_mul // a b c d e f ad bc

CALL r_sub // a b c d e f ad-bc

XCHG s3 // a b c ad-bc e f d

PUSH s2 // a b c ad-bc e f d e

XCHG s1 // a b c ad-bc e f e d

CALL r_mul // a b c ad-bc e f ed

XCHG s5 // a ed c ad-bc e f b

PUSH s1 // a ed c ad-bc e f b f

CALL r_mul // a ed c ad-bc e f bf

XCHG s1,s5 // a f c ad-bc e ed bf

CALL r_sub // a f c ad-bc e ed-bf

XCHG s3 // a f ed-bf ad-bc e c

CALL r_mul // a f ed-bf ad-bc ec

XCHG s3 // a ec ed-bf ad-bc f

XCHG s1,s4 // ad-bc ec ed-bf a f

CALL r_mul // D ec Dx af

XCHG s1 // D ec af Dx

XCHG s2 // D Dx af ec

CALL r_sub // D Dx Dy

XCHG s1 // D Dy Dx

PUSH s2 // D Dy Dx D

CALL r_div // D Dy x

XCHG s2 // x Dy D

JMP r_div // x y

Мы использовали 29 команд; предполагая однобайтовую кодировку для всех стековых операций и трехбайтовую кодировку для команд CALL и JMP, в итоге получаем 51 байта.

C.3.9. Стековая машина с составными элементарными действиями стековой обработки.
Мы снова используем код из C.1.7, заменяя арифметические элементарные действия вызовом подпрограмм и оптимизацией хвостовой рекурсии:

PUSH2 s5,s2 // a b c d e f a d

CALL r_mul // a b c d e f ad

PUSH2 s5,s4 // a b c d e f ad b c

CALL r_mul // a b c d e f ad bc

CALL r_sub // a b c d e f ad-bc

PUXC s2,s3 // a b c ad-bc e f e d

CALL r_mul // a b c D e f ed

XCHG3 s6,s0,s5 // (same as XCHG s2,s6; XCHG s1,s0; XCHG s0,s5)

// e f c D a ed b

PUSH s5 // e f c D a ed b f

CALL r_mul // e f c D a ed bf

CALL r_sub // e f c D a ed-bf

XCHG s4 // e Dx c D a f

CALL r_mul // e Dx c D af

XCHG2 s4,s2 // D Dx af e c

CALL r_mul // D Dx af ec

CALL r_sub // D Dx Dy

XCPU s1,s2 // D Dy Dx D

CALL r_div // D Dy x

XCHG s2 // x Dy D

JMP r_div // x y

Этот код использует только 20 команд, 9 команд стековой обработки и 11 команд управляющей логики (CALL и JMP), всего 48 байтов.

Tab5.png

Таблица 5: Сводка характеристик машинного кода для гипотетических 3-адресных, 2-адресных, одноадресных и стековых машин, созданные для примера нелистовой функции (см. C.3.1). 16 регистров должны быть сохранены вызываемыми подпрограммами.

C.4 Сравнение машинного кода для образца нелистовой функции
Таблица 5 суммирует свойства машинного кода, соответствующего исходному файлу из C.3.1. Мы рассматриваем только «реалистично» закодированные трехадресные машины. Трехадресные и двухадресные машины имеют одинаковые свойства плотности кода, но различаются использованием кодового пространства. Как ни странно, одноадресная машина смогла добиться более короткого кода, чем у двухадресных и трехадресных машин, за счет использования более половины всего кодового пространства. Стековая машина является очевидным победителем касательно плотности кода, без ущерба для расширяемости (измеряется в кодовом пространстве, используемом для арифметических и других команд по обработке данных).

C.4.1. Объединение с результатами листовых функций.
Интересно сравнить таблицу с результатами C.2 для примера листовой функции, сведенными в Таблицу 1 ( для m = 0 сохраненных регистров), с похожей Таблицей 3 (для m = 8 сохраненных регистров), и, если вас все еще интересует m = 16 (что почти во всех примерах хуже m = 8), с таблицей 2.

Мы видим, что стековая машина превосходит все регистровые машины, когда мы говорим о нелистовых функциях. Что касается листовых функций, то только трехадресная машина с «Оптимистичным» кодированием арифметических команд смогла превзойти стековую машину, выиграв на 15% за счет расширяемости. Однако, та же трехадресная машина производит на 25% более длинный код для нелистовых функций.

Tab6.png

Таблица 6: Сводка характеристик машинного кода для гипотетических 3-адресных, 2-адресных, одноадресных и стековых машин, созданные для примера нелистовой функции (см. C.3.1). 16 регистров должны быть сохранены вызываемыми подпрограммами. На этот раз мы используем фрагменты байтов для кодирования команд. Так, сравнение более справедливо. В противном случае, таблица была бы аналогична таблице 5. Если типичная программа состоит из нескольких листовых и нелистовых функций в примерно в равной пропорции, тогда все равно выиграет стековая машина.

C.4.2. Более справедливое сравнение с использованием двоичного кода вместо байтового.
Как и в C.2.5, мы можем предложить более справедливое сравнение различных регистровых и стековых машин с помощью произвольных двоичных кодов вместо байтовых кодов для кодирования команд и соответствия кодового пространства для обработки данных и арифметических команд на разных машинах.

Результаты этого модифицированного сравнения представлены в таблице 6. Мы видим, что стековые машины по-прежнему выигрывают с большим отрывом, используя меньше кодового пространства для работы со стеком/данными.

C.4.3. Сравнение с реальными машинами.
Обратите внимание, что наши гипотетические регистровые машины были значительно оптимизированы для создания более короткого кода, чем реально существующие регистровые машины; последние, помимо плотности кода и расширяемости, берут во внимание и другие характеристики, например, обратную совместимость, ускоренное декодирование команд, параллельное выполнение смежных команд, простота автоматического создания оптимизированного кода компиляторами, и так далее.

Например, очень популярная двухадресная архитектура регистров x86-64 дает код, который примерно в два раза длиннее наших «идеальных» результатов для двухадресные машины. С другой стороны, наши результаты стековоймашины напрямую применимы к TVM, которая была специально разработана с учетом соображений, представленных в этом приложении. Кроме того, фактический код TVM даже короче (в байтах), чем показано в таблице 5, благодаря двухбайтовой команде CALL, позволяющей TVM вызывать до 256 пользовательских функций из словаря c3. Это означает, что следует вычесть 10 байтов из результатов для стековых машин в таблице 5, если необходимо рассмотреть TVM, а не абстрактную стековую машину; то есть размер кода примерно 40 байт (или меньше), почти в половину короче абстрактной двухадресной или трехадресной машины.

C.4.4. Автоматическая генерация оптимизированного кода.
Интересно то, что код стековой машины в наших примерах мог быть сгенерирован автоматически очень простым оптимизирующим компилятором, который меняет порядок значений рядом с вершиной стека перед вызовом каждого элементарного действия или функции, как описано в 2.2. 2 и 2.2.5. Единственное исключение – не такая важная «ручная» оптимизация XCHG3, описанная в C.1.7, которая позволила сократить код еще на один байт.

Напротив, сильно оптимизированный (по размеру) код для регистровой машины, представленный в C.3.2 и C.3.3, вряд ли будет генерироваться автоматически с помощью оптимизирующего компилятора. Следовательно, если бы мы сравнили код, созданный компилятором, с созданным вручную кодом, преимущества стековой машины в отношении плотности кода были бы еще более поразительными.


Сноски
1) Например, отсутствуют арифметические операции с плавающей запятой (которые могут быть эффективно реализованы с использованием аппаратно-поддерживаемого двойного типа на большинстве современных процессоров) в TVM, поскольку результат выполнения таких операций зависит от конкретной аппаратной реализации и настроек режима округления. Вместо этого TVM поддерживает специальные целочисленные арифметические операции, которые могут, при необходимости, использоваться для моделирования арифметики с фиксированной точкой.

2) Производственная версия, вероятно, потребует некоторых настроек и модификаций до запуска, эти настройки и модификации будут понятны только после использования экспериментальной версии в тестовой среде.

3) Язык смарт-контрактов высокого уровня может создать видимость переменных для простоты программирования; однако исходный код высокого уровня, работающий с переменными, будет трансформирован в машинный код TVM, сохраняя все значения этих переменных в стеке TVM.

4) В контексте блокчейна TON c7 инициализируется одноэлементным кортежем, единственный компонент которого является кортежем, содержащим данные, специфичные для блокчейна. Смарт-контракт может свободно изменять c7 для хранения временных данных при условии, что первый компонент этого кортежа остается нетронутым.

5) Грубо говоря, существует еще и текущий библиотечный контекст, состоящий из словаря с 256-битными ключами и значениями ячеек, используемыми для загрузки ссылочных ячеек библиотеки 3.1.7.

6) Наше включение r0 создает немного противоречит нашим предположениям, что регистр сумматора, если присутствует, также является r0; для простоты мы решим эту проблему допущением, что первый аргумент функции передается в сумматор.

7) Например, если написать функцию для извлечения квадратного корня, эта функция всегда будет принимать ее аргумент и возвращать результат в тех же регистрах, в отличие от гипотетической встроенной инструкции извлечения квадратного корня, которая позволит программисту произвольно выбирать регистры источника и назначения. Следовательно, определяемая пользователем функция намного менее гибкая, чем встроенная инструкция на регистровой машине.

8) Конечно, если будет применен второй вариант, будет нарушено исходное расположение x в верхней части стека. В этом случае следует либо выполнить SWAP перед XCHG s (j 0), либо заменить предыдущую операцию XCHG s (i) на XCHG s1, s (i), чтобы x был заменен на s1 с самого начала.

9) Обратите внимание, что наиболее распространенная операция XCHG s (i) здесь на самом деле не требуется, если мы не настаиваем на сохранении одного и того же временного значения или переменной всегда в одном и том же месте стека, а скорее отслеживаем ее последующие местоположения. Мы перемещаем ее в другое место, когда осуществляем подготовку аргументов к следующему вызову элементарного действия или функции.

10) Возможно, лучшая альтернатива({\displaystyle {PU}O'{s}(i_{1}),\ldots ,{s}(i_{\gamma })}{\displaystyle {PU}O'{s}(i_{1}),\ldots ,{s}(i_{\gamma })}) состоит из перевода {\displaystyle O'{s}(i_{2}),\ldots ,{s}(i_{\gamma })}{\displaystyle O'{s}(i_{2}),\ldots ,{s}(i_{\gamma })}), а затем {\displaystyle {PUSHs(i_{1}+\alpha -1)};{XCHGs(\gamma -1)}}{\displaystyle {PUSHs(i_{1}+\alpha -1)};{XCHGs(\gamma -1)}}.

11) С точки зрения операций с ячейками низкого уровня эти биты данных и ссылки на ячейки не смешиваются. Другими словами, (обычная) ячейка по сути представляет собой пару, состоящую из списка до 1023 бит и списка до четырех ссылок на ячейки, без четкого порядка, в котором ссылки и биты данных подлежат десериализации, даже если TL-B схемы предлагают такой порядок.

12) С теоретической точки зрения можно сказать, что ячейка c имеет бесконечную последовательность хэшей {\displaystyle ({Hash}_{i}(c){\bigr )}_{i\geq 1}}{\displaystyle ({Hash}_{i}(c){\bigr )}_{i\geq 1}}, которая в конечном итоге стабилизируется {\displaystyle Hash_{i}(c)\to Hash_{\infty }(c)}{\displaystyle Hash_{i}(c)\to Hash_{\infty }(c)}. Тогда уровень l - это просто самый большой индекс i такой, что {\displaystyle {Hash}_{i}(c)\neq {Hash}_{\infty }(c)}{\displaystyle {Hash}_{i}(c)\neq {Hash}_{\infty }(c)}.

13) Отсеченная ячейка ветви {\displaystyle c'}{\displaystyle c'} уровня l связана ячейкой Меркла (проверка или обновление) c, если на пути от c к ее наследнику {\displaystyle c'}{\displaystyle c'}, включая c, находится ровно l клеток Меркла.

14) Отрицательные числа представлены в виде дополнения до двойки. Например, целое число −17 сериализуется командой STI 8 в битовую строку xEF.

15) Описание старой версии TL доступно по адресу https://core.telegram.org/mtproto/TL.

16) Наименование поля может использоваться для отражения значения типа в удобочитаемом для человека виде и не влияет на двоичную сериализацию.

17) Это «линейная операция» {\displaystyle (-)^{\perp }}{\displaystyle (-)^{\perp }} с линейной логикой, следовательно, {\displaystyle ~}{\displaystyle ~}.

18) Фактически, f может получать m дополнительных аргументов и возвращать m измененных значений, которые передаются следующему вызову f. Это применимо в случае реализации операций «сопоставления» и «сокращения» со словарями.

19) Могут быть представлены версии этой операции, в которых f и g получают дополнительный аргумент битной строки, равный ключу (для листьев) или общему префиксу всех ключей (для форков) в соответствующем поддереве.

20) Если в коде не осталось бит данных, но осталась ровно одна ссылка, осуществляется явный переход JMP к ячейке по ссылке, а не явный RET.

21) Технически, TVM может просто инициировать виртуальный метод run() текущего продолжения сс.

22) Использованный сейвлист cc.save нового сс опустошается перед новым исполнением.

23) Реализация REPEAT включает в себя особое продолжение, которое запоминает оставшееся количество итераций, тело цикла c и возвращаемое продолжение {\displaystyle c'}{\displaystyle c'}. (Последний термин представляет собой остаток тела функции, которая вызвала REPEAT и которая будет храниться в нового cc.)

24) Важно отметить, что древо ячеек, представляющее программу TVM, не может иметь циклические ссылки, поэтому использование CALLREF со ссылкой на ячейку, находящуюся выше в древе, не сработает.

25) Это не совсем так. Точнее сказать, что обычно кодовая страница нового продолжения является известной функцией текущей кодовой страницы.

26) Это еще один важный механизм обратной совместимости. Все значения вновь добавленных типов, а также значения, принадлежащие расширенным исходным типам, которые не принадлежат исходным типам (например, 513-битные целые числа, которые не помещаются в 257 битов в приведенном выше примере), обрабатываются всеми командами (кроме команд стековой обработки, которые естественно полиморфны (см. 2.2.6) в старых кодовых страницах как «значения неправильного типа», и соответственно генерируют ошибку проверки типов.

27) Если дампы ячеек являются шестнадцатеричными, то кодирование, состоящее из целого числа шестнадцатеричных цифр (т.е. имеющее длину, кратную четырем битам), может оказаться столь же удобным.

28) Обратите внимание, что важная вероятность появления в коде, а не вероятность его выполнения. Команда, встречающаяся в теле цикла, выполненная миллион раз, по-прежнему считается только один раз.

29) Обратите внимание, что любые изменения после запуска не могут быть сделаны в одностороннем порядке; потребуется поддержки минимум двух третей валидаторов.

30) Предварительная версия TVM не использует кодовую страницу -2 в этих целях. В будущем что-то может измениться.

31) Интересно сравнить этот код с кодом, сгенерированным с оптимизацией компиляторов C для архитектуры x86-64. Прежде всего, операция целочисленного деления для x86-64 использует одноадресную форму, при этом делимое (двойной длины) передается в паре сумматоров r2: r0. Частное также возвращается в r0. Как следствие, необходимо добавить две операции расширения от простого к двойному (CDQ или CQO) и по меньшей мере одну операцию перемещения. Во-вторых, кодирование, используемое для арифметических операций и операций перемещения, менее оптимистично, чем в нашем примере, требуя в среднем около трех байтов на операцию. В результате мы получаем всего 43 байта для 32-битных целых чисел и 68 байтов для 64-битных целых чисел.

32) Код, созданный для этой функции оптимизирующим компилятором для архитектуры х86-64 с оптимизацией размера, занимал 150 байт в связи с тем, что реальные команды оказались вдвое длиннее, чем мы оптимистично предполагали.

Навигациядействия на странице
статьяобсуждениепросмотр кодаистория
персональные инструменты
создать учётную записьвойти
навигация
Заглавная страница
Свежие правки
Случайная статья
Справка по MediaWiki
поиск
Искать в FreeTON Wiki Site

инструменты
Ссылки сюда
Связанные правки
Служебные страницы
Версия для печати
Постоянная ссылка
Сведения о странице
Creative Commons Attribution Share AlikePowered by MediaWiki
Эта страница в последний раз была отредактирована 18 сентября 2020 в 17:50.Содержание доступно по лицензии Creative Commons Attribution Share Alike (если не указано иное).Политика конфиденциальностиО FreeTON Wiki SiteОтказ от ответственности
